// frontend/syntax/ast.rs
use std::fmt::Write;

// frontend/ast.rs
use crate::{
    frontend::semantics::analyzer::{PrimitiveKind, ScopeId, SymbolTable, Type, ValueSymbolId},
    utils::kind::*,
};
use colored::*;
use indexmap::IndexMap;

/// The various denominations of an AstNode.
#[derive(Debug, Clone)]
pub enum AstNodeKind {
    IntegerLiteral(i64),
    FloatLiteral(f64),
    BooleanLiteral(bool),
    StringLiteral(String),
    CharLiteral(char),

    /// A named entity with no semantic meaning.
    Identifier(String),
    VariableDeclaration {
        name: String,
        mutable: bool,
        type_annotation: Option<BoxedAstNode>,
        initializer: Option<BoxedAstNode>,
    },

    UnaryOperation {
        operator: Operation,
        operand: BoxedAstNode,
    },
    BinaryOperation {
        operator: Operation,
        left: BoxedAstNode,
        right: BoxedAstNode,
    },
    ConditionalOperation {
        operator: Operation,
        left: BoxedAstNode,
        right: BoxedAstNode,
    },

    TypeCast {
        expr: BoxedAstNode,
        target_type: BoxedAstNode,
    },
    PathQualifier {
        ty: BoxedAstNode,
        tr: Option<BoxedAstNode>,
    },

    // A sequence of statements encapsulated by braces.
    Block(Vec<AstNode>),
    IfStatement {
        condition: BoxedAstNode,
        then_branch: BoxedAstNode,
        else_if_branches: Vec<(BoxedAstNode, BoxedAstNode)>,
        else_branch: Option<BoxedAstNode>,
    },
    ForLoop {
        initializer: Option<BoxedAstNode>,
        condition: Option<BoxedAstNode>,
        increment: Option<BoxedAstNode>,
        body: BoxedAstNode,
    },
    WhileLoop {
        condition: BoxedAstNode,
        body: BoxedAstNode,
    },
    Return(Option<BoxedAstNode>),
    Break,
    Continue,

    /// An expression or declaration that takes inputs and returns an output.
    Function {
        qualifier: Option<QualifierKind>,
        name: String,
        generic_parameters: Vec<AstNode>,
        parameters: Vec<AstNode>,
        return_type: Option<BoxedAstNode>,
        instance: Option<ReferenceKind>,
        body: Option<BoxedAstNode>,
    },
    /// A type that denotes the signature of a function.
    FunctionPointer {
        params: Vec<AstNode>,
        return_type: Option<BoxedAstNode>,
    },
    /// A parameter inside a function declaration or expression.
    FunctionParameter {
        name: String,
        type_annotation: BoxedAstNode,
        mutable: bool,
    },

    StructDeclaration {
        name: String,
        generic_parameters: Vec<AstNode>,
        fields: Vec<AstNode>,
    },
    StructField {
        qualifier: QualifierKind,
        name: String,
        type_annotation: BoxedAstNode,
    },
    StructLiteral {
        name: String,
        fields: IndexMap<String, AstNode>,
    },

    EnumDeclaration {
        name: String,
        variants: IndexMap<String, (AstNode, Option<AstNode>)>,
    },
    EnumVariant(String),

    ImplDeclaration {
        generic_parameters: Vec<AstNode>,
        type_reference: BoxedAstNode,
        trait_node: Option<BoxedAstNode>,
        associated_constants: Vec<AstNode>,
        associated_functions: Vec<AstNode>,
        associated_types: Vec<AstNode>,
    },
    AssociatedConstant {
        qualifier: QualifierKind,
        name: String,
        type_annotation: Option<BoxedAstNode>,
        initializer: BoxedAstNode,
    },
    AssociatedType {
        qualifier: QualifierKind,
        name: String,
        value: BoxedAstNode,
    },

    ///`this`
    SelfValue,
    /// `Self`, used as the type annotation for `this`, `&this`, and `&mut this`
    /// in an associated function.
    SelfType(ReferenceKind),

    /// A member access operation (i.e. `x.y`).
    FieldAccess {
        left: BoxedAstNode,
        right: BoxedAstNode,
    },
    /// A function call (i.e. `f()`).
    FunctionCall {
        function: BoxedAstNode,
        arguments: Vec<AstNode>,
    },

    TraitDeclaration {
        name: String,
        generic_parameters: Vec<AstNode>,
        types: Vec<AstNode>,
        constants: Vec<AstNode>,
        signatures: Vec<AstNode>,
    },
    TraitConstant {
        name: String,
        type_annotation: BoxedAstNode,
    },
    TraitType(String),

    GenericParameter {
        name: String,
        constraints: Vec<String>,
    },

    TypeReference {
        type_name: String,
        generic_types: Vec<AstNode>,
        reference_kind: ReferenceKind,
    },
    TypeDeclaration {
        name: String,
        generic_parameters: Vec<AstNode>,
        value: BoxedAstNode,
    },

    /// An expression node with a semicolon.
    ExpressionStatement(BoxedAstNode),

    // PROGRAM //
    Program(Vec<AstNode>),
}

#[derive(Debug, Clone)]
pub struct AstNode {
    /// The type of node.
    pub kind: AstNodeKind,
    /// The location of the node in the source file.
    pub span: Span,
    /// A pointer to the value it holds in the symbol table.
    pub value_id: Option<ValueSymbolId>,
    /// A pointer to the type it holds in the symbol table.
    pub type_id: Option<Type>,
    /// The scope the node lives in.
    pub scope_id: Option<ScopeId>,
}

pub type BoxedAstNode = Box<AstNode>;

impl AstNode {
    pub fn get_name(&self) -> Option<String> {
        match &self.kind {
            AstNodeKind::Identifier(name) => Some(name.clone()),

            AstNodeKind::VariableDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::Function { name, .. } => {
                if name.is_empty() {
                    None
                } else {
                    Some(name.clone())
                }
            }
            AstNodeKind::FunctionParameter { name, .. } => Some(name.clone()),

            AstNodeKind::StructDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::StructField { name, .. } => Some(name.clone()),
            AstNodeKind::StructLiteral { name, .. } => Some(name.clone()),

            AstNodeKind::EnumDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::EnumVariant(name) => Some(name.clone()),

            AstNodeKind::TraitDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::TraitConstant { name, .. } => Some(name.clone()),
            AstNodeKind::TraitType(name) => Some(name.clone()),

            AstNodeKind::AssociatedConstant { name, .. } => Some(name.clone()),
            AstNodeKind::AssociatedType { name, .. } => Some(name.clone()),

            AstNodeKind::GenericParameter { name, .. } => Some(name.clone()),

            AstNodeKind::TypeReference { type_name, .. } => Some(type_name.clone()),
            AstNodeKind::TypeDeclaration { name, .. } => Some(name.clone()),

            _ => None,
        }
    }
}

impl std::fmt::Display for AstNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.fmt_with_indent(f, 0, None)
    }
}

impl AstNode {
    pub fn fmt_with_indent<W: Write>(
        &self,
        f: &mut W,
        indent: usize,
        table: Option<&SymbolTable>,
    ) -> std::fmt::Result {
        let indent_str = " ".repeat(indent);
        let child_indent = indent + 4;

        match &self.kind {
            AstNodeKind::Program(nodes) => {
                let header = format!(
                    "{} ({} top-level items)",
                    "Program".bright_blue().bold(),
                    nodes.len()
                );
                writeln!(f, "{}", header)?;
                for node in nodes {
                    node.fmt_with_indent(f, indent, table)?;
                    writeln!(f)?;
                }
            }
            AstNodeKind::IntegerLiteral(val) => write!(f, "{}{}", indent_str, val.to_string().blue())?,
            AstNodeKind::FloatLiteral(val) => write!(f, "{}{}", indent_str, val.to_string().blue())?,
            AstNodeKind::BooleanLiteral(val) => {
                write!(f, "{}{}", indent_str, val.to_string().magenta())?
            }
            AstNodeKind::StringLiteral(s) => {
                write!(f, "{}{}", indent_str, format!("\"{s}\"").green())?
            }
            AstNodeKind::CharLiteral(c) => write!(f, "{}\'{}\'", indent_str, c.to_string().red())?,
            AstNodeKind::Identifier(name) => write!(f, "{}{}", indent_str, name.yellow())?,
            AstNodeKind::VariableDeclaration {
                mutable,
                name,
                type_annotation,
                initializer,
            } => {
                write!(f, "{}", indent_str)?;
                let decl_type = if *mutable {
                    "let".bright_green()
                } else {
                    "const".green()
                };
                write!(f, "{} {}", decl_type, name.yellow())?;
                if let Some(ty) = type_annotation {
                    write!(f, ": ")?;
                    ty.fmt_with_indent(f, 0, table)?;
                }
                if let Some(init) = initializer {
                    write!(f, " = ")?;
                    init.fmt_with_indent(f, 0, table)?;
                }
            }
            AstNodeKind::UnaryOperation { operator, operand } => {
                write!(f, "{}", indent_str)?;
                write!(f, "{}", operator)?;
                operand.fmt_with_indent(f, 0, table)?;
            }
            AstNodeKind::BinaryOperation {
                operator,
                left,
                right,
            } => {
                write!(f, "{}(", indent_str)?;
                left.fmt_with_indent(f, 0, table)?;
                write!(f, " {} ", operator)?;
                right.fmt_with_indent(f, 0, table)?;
                write!(f, ")")?
            }
            AstNodeKind::ConditionalOperation {
                operator,
                left,
                right,
            } => {
                write!(f, "{}(", indent_str)?;
                left.fmt_with_indent(f, 0, table)?;
                write!(f, " {} ", operator)?;
                right.fmt_with_indent(f, 0, table)?;
                write!(f, ")")?
            }
            AstNodeKind::TypeCast { expr, target_type } => {
                write!(f, "{}(", indent_str)?;
                expr.fmt_with_indent(f, 0, table)?;
                write!(f, " {} ", "as".yellow())?;
                target_type.fmt_with_indent(f, 0, table)?;
                write!(f, ")")?;
            }
            AstNodeKind::PathQualifier { ty, tr } => {
                write!(f, "{}{}", indent_str, "<".dimmed())?;
                ty.fmt_with_indent(f, 0, table)?;
                if let Some(tr_node) = tr {
                    write!(f, " {} ", "as".yellow())?;
                    tr_node.fmt_with_indent(f, 0, table)?;
                }
                write!(f, "{}", ">".dimmed())?;
            }

            AstNodeKind::Block(nodes) => {
                write!(f, "{}", "{".dimmed())?;
                if !nodes.is_empty() {
                    writeln!(f)?;
                    for node in nodes {
                        write!(f, "{}", " ".repeat(child_indent))?;
                        node.fmt_with_indent(f, child_indent, table)?;
                        writeln!(f)?;
                    }
                    write!(f, "{}", indent_str)?;
                }
                write!(f, "{}", " ".repeat(child_indent))?;
                write!(f, "{}", "}".dimmed())?
            }

            AstNodeKind::Function {
                qualifier,
                name,
                generic_parameters,
                parameters,
                return_type,
                body,
                ..
            } => {
                write!(f, "{}", indent_str)?;
                if let Some(q) = qualifier {
                    write!(
                        f,
                        "{} ",
                        match q {
                            QualifierKind::Public => "public".purple(),
                            QualifierKind::Private => "private".purple(),
                        }
                    )?;
                }
                write!(
                    f,
                    "{} {}",
                    "fn".bright_blue(),
                    if name.is_empty() {
                        "".white()
                    } else {
                        name.yellow()
                    }
                )?;

                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0, table)?;
                    }
                    write!(f, "]")?;
                }

                write!(f, "(")?;
                for (i, param) in parameters.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    param.fmt_with_indent(f, 0, table)?;
                }
                write!(f, ")")?;

                if let Some(ret_ty) = return_type {
                    write!(f, ": ")?;
                    ret_ty.fmt_with_indent(f, 0, table)?;
                }

                if let Some(b) = body {
                    write!(f, " ")?;
                    b.fmt_with_indent(f, indent, table)?;
                } else {
                    write!(f, ";")?;
                }
            }

            AstNodeKind::ImplDeclaration {
                generic_parameters,
                type_reference: name,
                trait_node: trait_name,
                associated_constants,
                associated_functions,
                associated_types,
            } => {
                write!(f, "{}{} ", indent_str, "impl".bright_cyan())?;
                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0, table)?;
                    }
                    write!(f, "]")?;
                }

                if let Some(trait_name) = trait_name {
                    trait_name.fmt_with_indent(f, 0, table)?;
                    write!(f, " for ")?;
                }
                name.fmt_with_indent(f, 0, table)?;

                writeln!(f, " {}", "{".dimmed())?;
                for type_node in associated_types {
                    write!(f, "    ")?;
                    type_node.fmt_with_indent(f, 0, table)?;
                    writeln!(f)?;
                }
                for constant in associated_constants {
                    write!(f, "    ")?;
                    constant.fmt_with_indent(f, 0, table)?;
                    writeln!(f)?;
                }
                for function in associated_functions {
                    write!(f, "    ")?;
                    function.fmt_with_indent(f, 0, table)?;
                    writeln!(f)?;
                }
                write!(f, "{}", "}".dimmed())?
            }

            AstNodeKind::AssociatedType {
                qualifier,
                name,
                value,
            } => {
                write!(
                    f,
                    "{} ",
                    match qualifier {
                        QualifierKind::Public => "public",
                        QualifierKind::Private => "private",
                    }
                    .purple()
                )?;

                write!(f, "type ")?;
                write!(f, "{}", name.yellow())?;
                write!(f, " = ")?;
                value.fmt_with_indent(f, 0, table)?;
            }

            AstNodeKind::AssociatedConstant {
                qualifier,
                name,
                type_annotation,
                initializer,
            } => {
                write!(
                    f,
                    "{} ",
                    match qualifier {
                        QualifierKind::Public => "public",
                        QualifierKind::Private => "private",
                    }
                    .purple()
                )?;

                write!(f, "const ")?;
                write!(f, "{}", name.yellow())?;

                if let Some(type_annotation) = type_annotation {
                    write!(f, ": ")?;
                    type_annotation.fmt_with_indent(f, 0, table)?;
                }

                write!(f, " = ")?;
                initializer.fmt_with_indent(f, 0, table)?;
            }

            AstNodeKind::SelfValue => write!(f, "{}this", indent_str)?,
            AstNodeKind::SelfType(operation) => {
                let operation_str = match operation {
                    ReferenceKind::Reference => "&",
                    ReferenceKind::MutableReference => "&mut ",
                    ReferenceKind::Value => "",
                };

                write!(f, "{}{operation_str}Self", indent_str)?
            }

            AstNodeKind::IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => {
                write!(f, "{}if (", indent_str)?;
                condition.fmt_with_indent(f, 0, table)?;
                write!(f, ") ")?;
                then_branch.fmt_with_indent(f, indent, table)?;

                for (cond, branch) in else_if_branches {
                    write!(f, "{}else if (", indent_str)?;
                    cond.fmt_with_indent(f, 0, table)?;
                    write!(f, ") ")?;
                    branch.fmt_with_indent(f, indent, table)?;
                }

                if let Some(else_node) = else_branch {
                    write!(f, "{}else ", indent_str)?;
                    else_node.fmt_with_indent(f, indent, table)?;
                }
            }

            AstNodeKind::ForLoop {
                initializer,
                condition,
                increment,
                body,
            } => {
                write!(f, "{}for (", indent_str)?;
                if let Some(init) = initializer {
                    init.fmt_with_indent(f, 0, table)?;
                }
                write!(f, "; ")?;
                if let Some(cond) = condition {
                    cond.fmt_with_indent(f, 0, table)?;
                }
                write!(f, "; ")?;
                if let Some(inc) = increment {
                    inc.fmt_with_indent(f, 0, table)?;
                }
                write!(f, ") ")?;
                body.fmt_with_indent(f, indent, table)?
            }

            AstNodeKind::WhileLoop { condition, body } => {
                write!(f, "{}while (", indent_str)?;
                condition.fmt_with_indent(f, 0, table)?;
                write!(f, ") ")?;
                body.fmt_with_indent(f, indent, table)?
            }

            AstNodeKind::Return(Some(expr)) => {
                write!(f, "{}return ", indent_str)?;
                expr.fmt_with_indent(f, 0, table)?
            }
            AstNodeKind::Return(None) => write!(f, "{}return", indent_str)?,
            AstNodeKind::Break => write!(f, "{}break", indent_str)?,
            AstNodeKind::Continue => write!(f, "{}continue", indent_str)?,

            AstNodeKind::FunctionParameter {
                name,
                type_annotation,
                mutable,
            } => {
                write!(f, "{}", indent_str)?;
                write!(
                    f,
                    "{}{}: ",
                    if *mutable { "mut ".purple() } else { "".white() },
                    name.yellow(),
                )?;
                type_annotation.fmt_with_indent(f, 0, table)?;
            }

            AstNodeKind::StructDeclaration {
                name,
                generic_parameters,
                fields,
            } => {
                write!(f, "{}struct {}", indent_str, name.yellow())?;

                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0, table)?;
                    }
                    write!(f, "]")?;
                }

                writeln!(f, " {}", "{".dimmed())?;

                for field in fields {
                    field.fmt_with_indent(f, child_indent, table)?;
                    writeln!(f)?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::StructField {
                qualifier,
                name,
                type_annotation,
            } => {
                write!(f, "{}", indent_str)?;
                write!(
                    f,
                    "{} ",
                    match qualifier {
                        QualifierKind::Public => "public".purple(),
                        QualifierKind::Private => "private".purple(),
                    }
                )?;

                write!(f, "{}", name.yellow())?;
                write!(f, ": ")?;
                type_annotation.fmt_with_indent(f, 0, table)?;
            }
            AstNodeKind::StructLiteral { name, fields } => {
                write!(f, "{}{}{}", indent_str, name.yellow(), " ".dimmed())?;
                write!(f, "{}", "{".dimmed())?;

                for (i, (field_name, expr)) in fields.iter().enumerate() {
                    write!(f, " ")?;
                    write!(f, "{}: ", field_name.yellow())?;
                    expr.fmt_with_indent(f, 0, table)?;

                    write!(f, "{}", if i + 1 < fields.len() { "," } else { " " })?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::EnumDeclaration { name, variants } => {
                write!(f, "{}enum {}", indent_str, name.yellow())?;
                writeln!(f, " {}", "{".dimmed())?;

                for (_, (variant, expr)) in variants {
                    write!(f, "{}", " ".repeat(child_indent + 4))?;
                    variant.fmt_with_indent(f, 0, table)?;

                    if let Some(expr) = expr {
                        write!(f, " = ")?;
                        expr.fmt_with_indent(f, 0, table)?;
                    }
                    writeln!(f)?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::EnumVariant(name) => write!(f, "{}", name)?,
            AstNodeKind::TypeReference {
                type_name,
                generic_types,
                reference_kind,
            } => {
                let type_name = match reference_kind {
                    ReferenceKind::Value => type_name.clone(),
                    ReferenceKind::MutableReference => format!("&mut {type_name}"),
                    ReferenceKind::Reference => format!("&{type_name}"),
                };

                write!(f, "{}{}", indent_str, type_name.bright_blue())?;
                if !generic_types.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_types.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0, table)?;
                    }
                    write!(f, "]")?;
                }
            }
            AstNodeKind::TypeDeclaration {
                name,
                generic_parameters,
                value,
            } => {
                write!(f, "{}", "type ".purple())?;
                write!(f, "{}", name)?;

                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0, table)?;
                    }
                    write!(f, "]")?;
                }

                write!(f, "= ")?;
                value.fmt_with_indent(f, 0, table)?;
            }
            AstNodeKind::FieldAccess { left, right } => {
                write!(f, "{}(", indent_str)?;
                left.fmt_with_indent(f, 0, table)?;
                write!(f, ".")?;
                right.fmt_with_indent(f, 0, table)?;
                write!(f, ")")?
            }
            AstNodeKind::FunctionCall { function, arguments } => {
                write!(f, "{}", indent_str)?;
                function.fmt_with_indent(f, 0, table)?;
                write!(f, "(")?;
                for (i, param) in arguments.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    param.fmt_with_indent(f, 0, table)?;
                }
                write!(f, ")")?
            }
            AstNodeKind::TraitDeclaration {
                name,
                generic_parameters,
                signatures,
                types,
                constants,
            } => {
                write!(f, "{}trait", indent_str)?;
                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0, table)?;
                    }
                    write!(f, "]")?;
                }

                write!(f, " {}", name.yellow())?;

                writeln!(f, " {}", "{".dimmed())?;

                for type_node in types {
                    write!(f, "{}    ", indent_str)?;
                    type_node.fmt_with_indent(f, 0, table)?;
                    writeln!(f)?;
                }

                for constant in constants {
                    write!(f, "{}    ", indent_str)?;
                    constant.fmt_with_indent(f, 0, table)?;
                    writeln!(f)?;
                }

                for signature in signatures {
                    signature.fmt_with_indent(f, child_indent, table)?;
                    writeln!(f)?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::TraitConstant {
                name,
                type_annotation,
            } => {
                write!(f, "{}const {}: ", indent_str, name.yellow())?;
                type_annotation.fmt_with_indent(f, 0, table)?;
            }
            AstNodeKind::TraitType(name) => {
                write!(f, "{}type {}", indent_str, name.bright_blue())?;
            }
            AstNodeKind::GenericParameter { name, constraints } => {
                write!(f, "{}{}", indent_str, name.yellow())?;

                if !constraints.is_empty() {
                    write!(f, ": ")?;
                }

                for (i, constraint) in constraints.iter().enumerate() {
                    write!(f, "{}", constraint)?;
                    if i + 1 < constraints.len() {
                        write!(f, " + ")?;
                    }
                }
            }
            AstNodeKind::FunctionPointer { params, return_type } => {
                write!(f, "{}{}", indent_str, "fn".bright_blue())?;
                write!(f, "(")?;
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    param.fmt_with_indent(f, 0, table)?;
                }
                write!(f, ")")?;

                if let Some(return_type) = return_type {
                    write!(f, ": ")?;
                    return_type.fmt_with_indent(f, 0, table)?;
                }
            }
            AstNodeKind::ExpressionStatement(expr) => {
                expr.fmt_with_indent(f, indent, table)?;
                write!(f, ";")?;
            }
        }

        if let (Some(ty), Some(table)) = (&self.type_id, table) {
            if ty.get_base_symbol() == PrimitiveKind::Void as usize {
                return Ok(());
            }
            
            let type_str = table.display_type(ty);
            write!(f, " {}", format!("<{}>", type_str).cyan())?;
        } else if let Some(ty) = &self.type_id {
            if ty.get_base_symbol() == PrimitiveKind::Void as usize {
                return Ok(());
            }

            write!(f, " {}", format_args!("[{}]", ty))?;
        }

        if let Some(id) = self.value_id {
            write!(f, " [Symbol({})]", id)?;
        }

        Ok(())
    }
}

impl AstNode {
    pub fn children_mut(&mut self) -> Vec<&mut AstNode> {
        use AstNodeKind::*;

        match &mut self.kind {
            IntegerLiteral(_)
            | FloatLiteral(_)
            | BooleanLiteral(_)
            | StringLiteral(_)
            | CharLiteral(_)
            | Identifier(_)
            | EnumVariant(_)
            | SelfValue
            | SelfType(_) => vec![],

            Program(statements) => statements.iter_mut().collect(),

            VariableDeclaration {
                type_annotation,
                initializer,
                ..
            } => {
                let mut children = vec![];

                if let Some(node) = type_annotation.as_mut() {
                    children.push(node.as_mut());
                }

                if let Some(node) = initializer.as_mut() {
                    children.push(node.as_mut());
                }

                children
            }

            UnaryOperation { operand, .. } => vec![operand.as_mut()],

            BinaryOperation { left, right, .. } | ConditionalOperation { left, right, .. } => {
                vec![left.as_mut(), right.as_mut()]
            }

            TypeCast { expr, target_type } => vec![expr.as_mut(), target_type.as_mut()],
            PathQualifier { ty, tr } => {
                let mut children = vec![ty.as_mut()];
                if let Some(trait_node) = tr.as_mut() {
                    children.push(trait_node.as_mut());
                }
                children
            }

            Block(statements) => statements.iter_mut().collect(),

            IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => {
                let mut children = vec![];

                children.push(condition.as_mut());
                children.push(then_branch.as_mut());

                for (elif_cond, elif_branch) in else_if_branches.iter_mut() {
                    children.push(elif_cond.as_mut());
                    children.push(elif_branch.as_mut());
                }

                if let Some(else_node) = else_branch.as_mut() {
                    children.push(else_node.as_mut());
                }

                children
            }

            ForLoop {
                initializer,
                condition,
                increment,
                body,
            } => {
                let mut children = vec![];

                if let Some(init) = initializer.as_mut() {
                    children.push(init.as_mut());
                }

                if let Some(cond) = condition.as_mut() {
                    children.push(cond.as_mut());
                }

                if let Some(inc) = increment.as_mut() {
                    children.push(inc.as_mut());
                }

                children.push(body.as_mut());

                children
            }

            WhileLoop { condition, body } => vec![condition.as_mut(), body.as_mut()],

            Return(opt_expr) => {
                if let Some(expr) = opt_expr.as_mut() {
                    vec![expr.as_mut()]
                } else {
                    vec![]
                }
            }

            Break | Continue => vec![],

            Function {
                generic_parameters,
                parameters,
                return_type,
                body,
                ..
            } => {
                let mut children = vec![];

                children.extend(generic_parameters.iter_mut());
                children.extend(parameters.iter_mut());

                if let Some(rt) = return_type.as_mut() {
                    children.push(rt.as_mut());
                }

                if let Some(b) = body.as_mut() {
                    children.push(b.as_mut());
                }

                children
            }

            FunctionPointer { params, return_type } => {
                let mut children = vec![];

                for p in params.iter_mut() {
                    children.push(p);
                }

                if let Some(ret) = return_type.as_mut() {
                    children.push(ret.as_mut());
                }

                children
            }

            FunctionParameter {
                type_annotation, ..
            } => vec![type_annotation.as_mut()],

            StructDeclaration {
                generic_parameters,
                fields,
                ..
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                for field_node in fields.iter_mut() {
                    children.push(field_node);
                }

                children
            }

            StructField {
                type_annotation, ..
            } => vec![type_annotation.as_mut()],

            StructLiteral { fields, .. } => fields.values_mut().collect(),

            EnumDeclaration { variants, .. } => {
                let mut children = vec![];

                for (_, (variant_node, opt_payload)) in variants.iter_mut() {
                    children.push(variant_node);
                    if let Some(payload) = opt_payload.as_mut() {
                        children.push(payload);
                    }
                }

                children
            }

            ImplDeclaration {
                generic_parameters,
                trait_node,
                type_reference,
                associated_constants,
                associated_functions,
                associated_types,
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                if let Some(tn) = trait_node.as_mut() {
                    children.push(tn.as_mut());
                }

                children.push(type_reference.as_mut());

                for const_node in associated_constants.iter_mut() {
                    children.push(const_node);
                }

                for func_node in associated_functions.iter_mut() {
                    children.push(func_node);
                }

                for type_node in associated_types.iter_mut() {
                    children.push(type_node);
                }

                children
            }

            AssociatedConstant {
                type_annotation,
                initializer,
                ..
            } => {
                let mut children = vec![];

                if let Some(ta) = type_annotation.as_mut() {
                    children.push(ta.as_mut());
                }

                children.push(initializer.as_mut());
                children
            }

            AssociatedType { value, .. } => vec![value.as_mut()],

            TraitDeclaration {
                generic_parameters,
                types,
                constants,
                signatures,
                ..
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                for t in types.iter_mut() {
                    children.push(t);
                }

                for c in constants.iter_mut() {
                    children.push(c);
                }

                for s in signatures.iter_mut() {
                    children.push(s);
                }

                children
            }

            TraitConstant {
                type_annotation, ..
            } => vec![type_annotation.as_mut()],

            TraitType(_) => vec![],

            TypeReference { generic_types, .. } => generic_types.iter_mut().collect(),

            TypeDeclaration {
                generic_parameters,
                value,
                ..
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                children.push(value.as_mut());
                children
            }

            FieldAccess { left, right } => vec![left.as_mut(), right.as_mut()],

            FunctionCall {
                function,
                arguments,
            } => {
                let mut children = vec![];
                children.push(function.as_mut());

                for arg in arguments.iter_mut() {
                    children.push(arg);
                }

                children
            }

            GenericParameter { .. } => vec![],
            ExpressionStatement(expr) => vec![expr.as_mut()],
        }
    }
}

// frontend/syntax/lexer.rs
use crate::utils::{error::*, kind::*};

trait CharClassifier {
    fn is_operation(self) -> bool;
    fn valid_alphabetic_hex(self) -> bool;
}

impl CharClassifier for char {
    fn is_operation(self) -> bool {
        matches!(
            self,
            NOT_TOKEN
                | BITWISE_NEGATE_TOKEN
                | ADD_TOKEN
                | SUB_TOKEN
                | MUL_TOKEN
                | DIV_TOKEN
                | MOD_TOKEN
                | BITWISE_AND_TOKEN
                | BITWISE_OR_TOKEN
                | BITWISE_XOR_TOKEN
                | ASSIGNMENT_TOKEN
                | GREATER_THAN_TOKEN
                | LESS_THAN_TOKEN
                | FIELD_ACCESS_TOKEN
        )
    }

    fn valid_alphabetic_hex(self) -> bool {
        matches!(self.to_ascii_lowercase(), 'a' | 'b' | 'c' | 'd' | 'e' | 'f')
    }
}

pub struct Lexer {
    /// The source program, in lines.
    lines: Vec<String>,
    /// The source program, as characters.
    source: Vec<char>,
    /// The line the lexer is reading.
    line: usize,
    /// The index in the line the lexer is reading.
    column: usize,
    /// The index in the source the lexer is reading.
    index: usize,
    /// The tokens collected from the source.
    tokens: Vec<Token>,
}

impl Lexer {
    /// Goes to the next line.
    fn next_line(&mut self) {
        self.line += 1;
        self.column = 1;
    }

    /// Goes to the index, or next line if '\n' is encountered.
    fn next_index(&mut self) {
        if self.source[self.index] == '\n' {
            self.next_line();
        } else {
            self.column += 1;
        }

        self.index += 1;
    }

    /// Generates an Error struct based on the position of the lexer.
    fn generate_error(&self, kind: ErrorKind, span: Option<Span>) -> BoxedError {
        let span = if let Some(span) = span {
            span.set_end_from_values(self.index, self.line, self.column)
        } else {
            Span {
                start: self.index,
                end: self.index,
                start_pos: Position {
                    line: self.line,
                    column: self.column,
                },
                end_pos: Position {
                    line: self.line,
                    column: self.column,
                },
            }
        };

        Error::from_one_error(kind, span, (self.lines[span.end_pos.line - 1].clone(), self.line))
    }

    /// Peeks at the next character.
    fn peek(&self) -> Result<char, BoxedError> {
        self.source
            .get(self.index + 1)
            .ok_or(self.generate_error(ErrorKind::UnexpectedEOF, None))
            .copied()
    }

    /// Consumes the next character.
    fn consume(&mut self) -> Result<char, BoxedError> {
        self.next_index();
        self.source
            .get(self.index)
            .ok_or(self.generate_error(ErrorKind::UnexpectedEOF, None))
            .copied()
    }

    fn parse_escape_char(&mut self) -> Result<char, BoxedError> {
        match self.consume()? {
            'n' => Ok('\n'),
            't' => Ok('\t'),
            'r' => Ok('\r'),
            '0' => Ok('\0'),
            '\\' => Ok('\\'),
            '\'' => Ok('\''),
            '\"' => Ok('\"'),
            'b' => Ok('\x08'),
            'f' => Ok('\x0C'),
            'v' => Ok('\x0B'),

            'x' => {
                let mut hex = String::new();
                for _ in 0..2 {
                    match self.consume()? {
                        c if c.is_ascii_hexdigit() => hex.push(c),
                        c => {
                            return Err(self.generate_error(
                                ErrorKind::InvalidEscapeSequence(format!(
                                    "\\x{} (invalid char '{}')",
                                    hex, c
                                )),
                                None,
                            ));
                        }
                    }
                }
                let value = u8::from_str_radix(&hex, 16).unwrap();
                Ok(value as char)
            }

            'u' => {
                if self.consume()? != '{' {
                    return Err(self.generate_error(
                        ErrorKind::InvalidEscapeSequence("\\u (does not have opening brace)".to_string()),
                        None,
                    ));
                }

                let mut hex = String::new();
                while let Ok(c) = self.consume() {
                    if c == '}' {
                        break;
                    }

                    if !c.is_ascii_hexdigit() {
                        return Err(self.generate_error(
                            ErrorKind::InvalidEscapeSequence(format!(
                                "\\u{{{}}} (invalid char '{}')",
                                hex + &c.to_string(),
                                c
                            )),
                            None,
                        ));
                    }

                    hex.push(c);

                    if hex.len() > 6 {
                        return Err(self.generate_error(
                            ErrorKind::InvalidEscapeSequence(format!(
                                "\\u{{{}}} (too long of an escape sequence)",
                                hex
                            )),
                            None,
                        ));
                    }
                }

                if hex.is_empty() {
                    return Err(
                        self.generate_error(ErrorKind::InvalidEscapeSequence("\\u{}".to_string()), None)
                    );
                }

                let value = u32::from_str_radix(&hex, 16).unwrap();
                match char::from_u32(value) {
                    Some(ch) => Ok(ch),
                    None => Err(self.generate_error(
                        ErrorKind::InvalidEscapeSequence(format!("\\u{{{}}} (invalid Unicode scalar)", hex)),
                        None,
                    )),
                }
            }

            other => Err(self.generate_error(ErrorKind::InvalidEscapeSequence(format!("\\{}", other)), None)),
        }
    }
}

impl Lexer {
    /// Parses an operation.
    fn parse_operator(&mut self) -> Result<Token, BoxedError> {
        let mut operator = self.source[self.index].to_string();
        let span = Span {
            start: self.index,
            end: 0,
            start_pos: Position {
                line: self.line,
                column: self.column,
            },
            end_pos: Position::default(),
        };

        match operator.chars().next().unwrap() {
            NOT_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::NotEqual)
                    }
                    _ => TokenKind::Operator(Operation::Not),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            BITWISE_NEGATE_TOKEN => Ok(Token::new(
                operator,
                TokenKind::Operator(Operation::BitwiseNegate),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            ADD_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::PlusEq)
                    }
                    _ => TokenKind::Operator(Operation::Plus),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            SUB_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::MinusEq)
                    }
                    _ => TokenKind::Operator(Operation::Minus),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            MUL_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::MulEq)
                    }
                    Ok(c) if c == MUL_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::Exp)
                    }
                    _ => TokenKind::Operator(Operation::Mul),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            DIV_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::DivEq)
                    }
                    _ => TokenKind::Operator(Operation::Div),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            MOD_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::ModEq)
                    }
                    _ => TokenKind::Operator(Operation::Mod),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            BITWISE_AND_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == BITWISE_AND_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::And)
                    }
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::BitwiseAndEq)
                    }
                    _ => TokenKind::Operator(Operation::BitwiseAnd),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            BITWISE_OR_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == BITWISE_OR_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::Or)
                    }
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::BitwiseOrEq)
                    }
                    _ => TokenKind::Operator(Operation::BitwiseOr),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            BITWISE_XOR_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::BitwiseXorEq)
                    }
                    _ => TokenKind::Operator(Operation::BitwiseXor),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            ASSIGNMENT_TOKEN => {
                let token_type = match self.peek() {
                    Ok(c) if c == ASSIGNMENT_TOKEN => {
                        operator.push(self.consume()?);
                        TokenKind::Operator(Operation::Equivalence)
                    }
                    _ => TokenKind::Operator(Operation::Assign),
                };
                Ok(Token::new(
                    operator,
                    token_type,
                    span.set_end_from_values(self.index, self.line, self.column),
                ))
            }
            GREATER_THAN_TOKEN => match self.peek() {
                Ok(c) if c == ASSIGNMENT_TOKEN => {
                    operator.push(self.consume()?);
                    Ok(Token::new(
                        operator,
                        TokenKind::Operator(Operation::Geq),
                        span.set_end_from_values(self.index, self.line, self.column),
                    ))
                }
                Ok(c) if c == GREATER_THAN_TOKEN => {
                    operator.push(self.consume()?);
                    if let Ok(c2) = self.peek() {
                        if c2 == ASSIGNMENT_TOKEN {
                            operator.push(self.consume()?);
                            return Ok(Token::new(
                                operator,
                                TokenKind::Operator(Operation::RightBitShiftEq),
                                span.set_end_from_values(self.index, self.line, self.column),
                            ));
                        }
                    }
                    Ok(Token::new(
                        operator,
                        TokenKind::Operator(Operation::RightBitShift),
                        span.set_end_from_values(self.index, self.line, self.column),
                    ))
                }
                _ => Ok(Token::new(
                    operator,
                    TokenKind::Operator(Operation::GreaterThan),
                    span.set_end_from_values(self.index, self.line, self.column),
                )),
            },
            LESS_THAN_TOKEN => match self.peek() {
                Ok(c) if c == ASSIGNMENT_TOKEN => {
                    operator.push(self.consume()?);
                    Ok(Token::new(
                        operator,
                        TokenKind::Operator(Operation::Leq),
                        span.set_end_from_values(self.index, self.line, self.column),
                    ))
                }
                Ok(c) if c == LESS_THAN_TOKEN => {
                    operator.push(self.consume()?);
                    if let Ok(c2) = self.peek() {
                        if c2 == ASSIGNMENT_TOKEN {
                            operator.push(self.consume()?);
                            return Ok(Token::new(
                                operator,
                                TokenKind::Operator(Operation::LeftBitShiftEq),
                                span.set_end_from_values(self.index, self.line, self.column),
                            ));
                        }
                    }
                    Ok(Token::new(
                        operator,
                        TokenKind::Operator(Operation::LeftBitShift),
                        span.set_end_from_values(self.index, self.line, self.column),
                    ))
                }
                _ => Ok(Token::new(
                    operator,
                    TokenKind::Operator(Operation::LessThan),
                    span.set_end_from_values(self.index, self.line, self.column),
                )),
            },
            FIELD_ACCESS_TOKEN => Ok(Token::new(
                operator,
                TokenKind::Operator(Operation::FieldAccess),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            _ => Err(self.generate_error(ErrorKind::UnrecognizedSymbol(operator), Some(span))),
        }
    }

    /// Parses a word.
    fn parse_word(&mut self) -> Result<Token, BoxedError> {
        let mut word = self.source[self.index].to_string();
        let span = Span {
            start: self.index,
            end: 0,
            start_pos: Position {
                line: self.line,
                column: self.column,
            },
            end_pos: Position::default(),
        };

        while let Ok(char) = self.peek()
            && (char.is_alphanumeric() || char == '_')
        {
            self.next_index();
            word.push(self.source[self.index]);
        }

        match word.as_str() {
            INT_TYPE => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Int),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            FLOAT_TYPE => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Float),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            BOOL_TYPE => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Bool),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            STRING_TYPE => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::String),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            CHAR_TYPE => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Char),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            LET_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Let),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            CONST_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Const),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            STRUCT_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Struct),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            ENUM_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Enum),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            TRUE_KEYWORD | FALSE_KEYWORD => Ok(Token::new(
                word,
                TokenKind::BooleanLiteral,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            FN_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Fn),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            FOR_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::For),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            WHILE_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::While),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            RETURN_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Return),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            BREAK_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Break),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            CONTINUE_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Continue),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            IF_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::If),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            ELSE_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Else),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            THIS_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::This),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            PUBLIC_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Public),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            PRIVATE_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Private),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            IMPL_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Impl),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            TRAIT_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Trait),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            TYPE_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Type),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            MUT_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Keyword(KeywordKind::Mut),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            AS_KEYWORD => Ok(Token::new(
                word,
                TokenKind::Operator(Operation::As),
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            _ => Ok(Token::new(
                word,
                TokenKind::Identifier,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
        }
    }

    /// Parses a number.
    fn parse_number(&mut self) -> Result<Token, BoxedError> {
        let mut number_str = String::new();
        let mut has_decimal_point = false;
        let mut has_exponent = false;

        let first_char = self.source[self.index];
        number_str.push(first_char);
        let span = Span {
            start: self.index,
            end: 0,
            start_pos: Position {
                line: self.line,
                column: self.column,
            },
            end_pos: Position::default(),
        };

        if first_char == '0' {
            if let Ok(next_char) = self.peek() {
                if let Some(base) = match next_char.to_ascii_lowercase() {
                    'b' => Some(2),
                    'o' => Some(8),
                    'x' => Some(16),
                    _ => None,
                } {
                    number_str.push(self.consume()?);
                    let mut has_digits = false;

                    while let Ok(c) = self.peek() {
                        if c.is_digit(base) {
                            number_str.push(self.consume()?);
                            has_digits = true;
                        } else {
                            break;
                        }
                    }

                    if !has_digits {
                        let invalid_char = self.peek().unwrap_or('\0');
                        return Err(self
                            .generate_error(ErrorKind::InvalidDigit(invalid_char.to_string()), Some(span)));
                    }

                    let number_type = match base {
                        2 => NumberKind::Binary,
                        8 => NumberKind::Octal,
                        16 => NumberKind::Hex,
                        _ => unreachable!(),
                    };

                    return Ok(Token::new(
                        number_str,
                        TokenKind::NumberLiteral(number_type),
                        span.set_end_from_values(self.index, self.line, self.column),
                    ));
                }
            }
        }

        while let Ok(next_char) = self.peek() {
            if next_char.is_ascii_digit() {
                number_str.push(self.consume()?);
            } else if next_char == '.' && !has_decimal_point && !has_exponent {
                self.consume()?;

                if let Ok(peek_after_dot) = self.peek() {
                    if peek_after_dot.is_ascii_digit() {
                        has_decimal_point = true;
                        number_str.push('.');
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            } else if (next_char == 'e' || next_char == 'E') && !has_exponent {
                has_exponent = true;
                number_str.push(self.consume()?);

                if let Ok(sign) = self.peek() {
                    if sign == '+' || sign == '-' {
                        number_str.push(self.consume()?);
                    }
                }

                let mut exponent_digit_found = false;
                while let Ok(digit) = self.peek() {
                    if digit.is_ascii_digit() {
                        exponent_digit_found = true;
                        number_str.push(self.consume()?);
                    } else {
                        break;
                    }
                }

                if !exponent_digit_found {
                    let invalid_char = self.peek().unwrap_or('\0');
                    return Err(
                        self.generate_error(ErrorKind::InvalidDigit(invalid_char.to_string()), Some(span))
                    );
                }
            } else {
                break;
            }
        }

        let number_type = if has_decimal_point || has_exponent {
            NumberKind::Float
        } else {
            NumberKind::Decimal
        };

        Ok(Token::new(
            number_str,
            TokenKind::NumberLiteral(number_type),
            span.set_end_from_values(self.index, self.line, self.column),
        ))
    }

    fn parse_symbol(&mut self) -> Result<Token, BoxedError> {
        let symbol = self.source[self.index];
        let mut symbol_buffer = symbol.to_string();

        let span = Span {
            start: self.index,
            end: 0,
            start_pos: Position {
                line: self.line,
                column: self.column,
            },
            end_pos: Position::default(),
        };

        match symbol {
            END_OF_LINE => Ok(Token::new(
                symbol_buffer,
                TokenKind::Semicolon,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            OPEN_PARENTHESIS => Ok(Token::new(
                symbol_buffer,
                TokenKind::OpenParenthesis,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            CLOSE_PARENTHESIS => Ok(Token::new(
                symbol_buffer,
                TokenKind::CloseParenthesis,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            OPEN_BRACKET => Ok(Token::new(
                symbol_buffer,
                TokenKind::OpenBracket,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            CLOSE_BRACKET => Ok(Token::new(
                symbol_buffer,
                TokenKind::CloseBracket,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            OPEN_BRACE => Ok(Token::new(
                symbol_buffer,
                TokenKind::OpenBrace,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            CLOSE_BRACE => Ok(Token::new(
                symbol_buffer,
                TokenKind::CloseBrace,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            COMMA => Ok(Token::new(
                symbol_buffer,
                TokenKind::Comma,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            COLON => Ok(Token::new(
                symbol_buffer,
                TokenKind::Colon,
                span.set_end_from_values(self.index, self.line, self.column),
            )),
            STRING_DELIMITER => {
                while let Ok(c) = self.peek() {
                    if c == STRING_DELIMITER {
                        self.consume()?;
                        symbol_buffer.push(c);
                        return Ok(Token::new(
                            symbol_buffer,
                            TokenKind::StringLiteral,
                            span.set_end_from_values(self.index, self.line, self.column),
                        ));
                    }

                    if c == '\\' {
                        self.consume()?;
                        let ch = self.parse_escape_char()?;
                        symbol_buffer.push(ch);
                    } else {
                        symbol_buffer.push(self.consume()?);
                    }
                }

                return Err(self.generate_error(ErrorKind::UnterminatedString, Some(span)));
            }
            CHAR_DELIMITER => {
                let c = self.consume()?;

                if c == '\\' {
                    let ch = self.parse_escape_char()?;
                    symbol_buffer.push(ch);
                } else if c != CHAR_DELIMITER {
                    symbol_buffer.push(c);
                } else {
                    return Err(self.generate_error(ErrorKind::InvalidChar(c.to_string()), Some(span)));
                }

                if self.consume()? == CHAR_DELIMITER {
                    symbol_buffer.push(CHAR_DELIMITER);
                    Ok(Token::new(
                        symbol_buffer,
                        TokenKind::CharLiteral,
                        span.set_end_from_values(self.index, self.line, self.column),
                    ))
                } else {
                    return Err(self.generate_error(ErrorKind::UnterminatedChar, Some(span)));
                }
            }
            _ => {
                return Err(self.generate_error(ErrorKind::UnrecognizedSymbol(symbol.to_string()), Some(span)))
            }
        }
    }
}

impl Lexer {
    pub fn new(program: String) -> Lexer {
        Lexer {
            lines: program.split("\n").map(|x| x.to_string()).collect(),
            source: program.chars().collect(),
            line: 1,
            column: 1,
            index: 0,
            tokens: vec![],
        }
    }

    pub fn tokenize(&mut self) -> Result<(), BoxedError> {
        while let Some(&char) = self.source.get(self.index) {
            if char.is_whitespace() {}
            else if char == '/' && matches!(self.peek(), Ok('/' | '*')) {
                match self.peek() {
                    Ok('/') => {
                        while matches!(self.peek(), Ok(c) if c != '\n') {
                            self.next_index();
                        }
                    },
                    Ok('*') => {
                        self.next_index();

                        'comment_loop: loop {
                            match self.peek() {
                                Ok('*') => {
                                    self.next_index();
                                    if self.peek() == Ok('/') {
                                        self.next_index();
                                        break 'comment_loop;
                                    }
                                }
                                Ok(_) => {
                                    self.next_index();
                                }
                                Err(_) => {
                                    break 'comment_loop;
                                }
                            }
                        }
                    },
                    _ => unreachable!(),
                }
            } else if char.is_operation() {
                let token = self.parse_operator()?;
                self.tokens.push(token);
            } else if char.is_alphabetic() {
                let token = self.parse_word()?;
                self.tokens.push(token);
            } else if char.is_numeric() {
                let token = self.parse_number()?;
                self.tokens.push(token);
            } else {
                let token = self.parse_symbol()?;
                self.tokens.push(token);
            }

            self.next_index();
        }

        self.tokens.push(Token::new(
            "".to_string(),
            TokenKind::EndOfFile,
            Span {
                start: self.index - 1,
                end: self.index - 1,
                start_pos: Position {
                    line: self.line,
                    column: if self.column == 1 { 1 } else { self.column - 1 },
                },
                end_pos: Position {
                    line: self.line,
                    column: if self.column == 1 { 1 } else { self.column - 1 },
                },
            },
        ));

        Ok(())
    }

    pub fn get_tokens(&self) -> &Vec<Token> {
        &self.tokens
    }

    pub fn extract(self) -> (Vec<String>, Vec<Token>) {
        (self.lines, self.tokens)
    }
}


// frontend/syntax/parser.rs
use indexmap::IndexMap;

use crate::{
    boxed,
    frontend::syntax::ast::BoxedAstNode,
    utils::{error::*, kind::*},
};

use super::ast::{AstNode, AstNodeKind};

pub struct Parser {
    lines: Vec<String>,
    tokens: Vec<Token>,
    current: usize,
    errors: Vec<Error>,
}

impl Parser {
    fn is_at_end(&self) -> bool {
        self.peek().get_token_kind() == TokenKind::EndOfFile
    }

    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    fn previous(&self) -> &Token {
        &self.tokens[self.current - 1]
    }

    fn advance(&mut self) -> &Token {
        if !self.is_at_end() {
            self.current += 1;
        }

        self.previous()
    }

    fn back(&mut self) {
        if self.current > 0 {
            self.current -= 1;
        }
    }

    fn match_token(&mut self, token_type: TokenKind) -> bool {
        if self.peek().get_token_kind() == token_type {
            self.advance();
            true
        } else {
            false
        }
    }

    /// Generates an Error struct based on the position of the parser.
    fn generate_error(&self, kind: ErrorKind, span: Span) -> BoxedError {
        let span = span.set_end_from_span(self.peek().get_span());
        Error::from_one_error(
            kind,
            span,
            (self.lines[span.end_pos.line - 1].clone(), span.start_pos.line),
        )
    }

    fn consume(&mut self, token_type: TokenKind) -> Result<&Token, BoxedError> {
        let peeked = self.peek();

        if peeked.get_token_kind() == token_type {
            Ok(self.advance())
        } else {
            let span = self.previous().get_span();
            return Err(self.generate_error(
                ErrorKind::UnexpectedToken(
                    peeked.get_value().to_string(),
                    format!("{}", peeked.get_token_kind()),
                    format!("a token of type {}", token_type),
                ),
                span,
            ));
        }
    }

    fn synchronize(&mut self) {
        self.advance();

        while !self.is_at_end() {
            if self.previous().get_token_kind() == TokenKind::Semicolon {
                return;
            }

            if SYNC_TOKENS.contains(&self.peek().get_token_kind()) {
                return;
            }

            self.advance();
        }
    }

    fn create_span_from_current_token(&self) -> Span {
        let previous_span = self.peek().get_span();

        Span {
            start: previous_span.start,
            start_pos: previous_span.start_pos,
            end: 0,
            end_pos: Position::default(),
        }
    }

    fn spanned_node<F>(&mut self, builder: F) -> Result<AstNode, BoxedError>
    where
        F: FnOnce(&mut Self) -> Result<AstNodeKind, BoxedError>,
    {
        let start_span = self.peek().get_span();
        let initial = Span {
            start: start_span.start,
            start_pos: start_span.start_pos,
            end: 0,
            end_pos: Position::default(),
        };

        let kind = builder(self)?;
        let finished = initial.set_end_from_span(self.previous().get_span());

        Ok(AstNode {
            kind,
            span: finished,
            type_id: None,
            value_id: None,
            scope_id: None,
        })
    }
}

impl Parser {
    fn parse_expression(&mut self) -> Result<AstNode, BoxedError> {
        self.parse_binding_power(Operation::Assign.binding_power().0)
    }

    fn parse_binding_power(&mut self, min_bp: u8) -> Result<AstNode, BoxedError> {
        let mut lhs = self.parse_prefix()?;

        loop {
            let operator = match self.peek().get_token_kind() {
                TokenKind::Operator(op) => op,
                TokenKind::OpenParenthesis => Operation::FunctionCall,
                _ => break,
            };

            let (left_bp, right_bp) = operator.binding_power();

            if left_bp < min_bp {
                break;
            }

            self.advance();

            if operator == Operation::As {
                let target_type = self.parse_type()?;
                
                lhs = AstNode {
                    span: lhs.span.set_end_from_span(target_type.span),
                    kind: AstNodeKind::TypeCast {
                        expr: boxed!(lhs),
                        target_type: boxed!(target_type),
                    },
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                };
            } else if operator == Operation::FunctionCall {
                let mut arguments = vec![];
                if self.peek().get_token_kind() != TokenKind::CloseParenthesis {
                    loop {
                        arguments.push(self.parse_expression()?);
                        if self.peek().get_token_kind() == TokenKind::CloseParenthesis {
                            break;
                        }
                        self.consume(TokenKind::Comma)?;
                    }
                }
                self.consume(TokenKind::CloseParenthesis)?;

                lhs = AstNode {
                    span: lhs.span.set_end_from_span(self.previous().get_span()),
                    kind: AstNodeKind::FunctionCall {
                        function: boxed!(lhs),
                        arguments,
                    },
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                };
            } else {
                let rhs = self.parse_binding_power(right_bp)?;

                lhs = AstNode {
                    span: lhs.span.set_end_from_span(rhs.span),
                    kind: if operator.is_conditional() {
                        AstNodeKind::ConditionalOperation {
                            operator,
                            left: boxed!(lhs),
                            right: boxed!(rhs),
                        }
                    } else if operator == Operation::FieldAccess {
                        AstNodeKind::FieldAccess {
                            left: boxed!(lhs),
                            right: boxed!(rhs),
                        }
                    } else {
                        AstNodeKind::BinaryOperation {
                            operator,
                            left: boxed!(lhs),
                            right: boxed!(rhs),
                        }
                    },
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                };
            }
        }

        Ok(lhs)
    }

    fn parse_prefix(&mut self) -> Result<AstNode, BoxedError> {
        let token = self.peek();
        let span = self.create_span_from_current_token();

        match token.get_token_kind() {
            TokenKind::OpenBracket => {
                return self.spanned_node(|parser| {
                    parser.consume(TokenKind::OpenBracket)?;

                    let ty = boxed!(parser.parse_type()?);
                    let tr = if parser.match_token(TokenKind::Operator(Operation::As)) {
                        Some(boxed!(parser.parse_type()?))
                    } else {
                        None
                    };
                    parser.consume(TokenKind::CloseBracket)?;

                    Ok(AstNodeKind::PathQualifier { ty, tr })
                })
            },
            TokenKind::Operator(operator) => {
                if !operator.is_unary() {
                    return Err(self.generate_error(
                        ErrorKind::UnexpectedToken(
                            token.get_value().to_string(),
                            format!("{}", token.get_token_kind()),
                            "a unary operator".to_string(),
                        ),
                        span,
                    ));
                }

                let _ = self.advance();
                let mut operator = match operator {
                    Operation::Mul => Operation::Dereference,
                    Operation::BitwiseAnd => Operation::ImmutableAddressOf,
                    Operation::Minus => Operation::Neg,
                    _ => operator,
                };

                if operator == Operation::ImmutableAddressOf
                    && self.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::Mut)
                {
                    self.advance();
                    operator = Operation::MutableAddressOf;
                }

                let operand = boxed!(self.parse_binding_power(Operation::Not.binding_power().0)?);

                Ok(AstNode {
                    span: span.set_end_from_span(operand.span),
                    kind: AstNodeKind::UnaryOperation { operator, operand },
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::NumberLiteral(_) => {
                let token = self.advance();
                let numeric_literal: String = token.get_value().to_string();

                let (is_integer, value): (bool, f64) = {
                    if numeric_literal.starts_with("0b") || numeric_literal.starts_with("0B") {
                        let without_prefix = &numeric_literal[2..];
                        let int_value = u64::from_str_radix(without_prefix, 2).unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    } else if numeric_literal.starts_with("0o") || numeric_literal.starts_with("0O") {
                        let without_prefix = &numeric_literal[2..];
                        let int_value = u64::from_str_radix(without_prefix, 8).unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    } else if numeric_literal.starts_with("0x") || numeric_literal.starts_with("0X") {
                        let without_prefix = &numeric_literal[2..];
                        let int_value = u64::from_str_radix(without_prefix, 16).unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    } else if numeric_literal.contains('.')
                        || numeric_literal.contains('e')
                        || numeric_literal.contains('E')
                    {
                        let float_value = numeric_literal.parse::<f64>().unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (false, float_value)
                    } else {
                        let int_value = numeric_literal.parse::<u64>().unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    }
                };

                Ok(AstNode {
                    kind: if is_integer {
                        AstNodeKind::IntegerLiteral(value as i64)
                    } else {
                        AstNodeKind::FloatLiteral(value)
                    },
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::BooleanLiteral => {
                let token = self.advance();
                let value = token.get_value().parse::<bool>().unwrap();

                Ok(AstNode {
                    kind: AstNodeKind::BooleanLiteral(value),
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::StringLiteral => {
                let token = self.advance();

                let raw_value = token.get_value();
                let value = raw_value[1..raw_value.len() - 1].to_string();

                Ok(AstNode {
                    kind: AstNodeKind::StringLiteral(value),
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::CharLiteral => {
                let token = self.advance();

                let raw_value = token.get_value();
                let value = raw_value[1..raw_value.len() - 1].chars().next().unwrap();

                Ok(AstNode {
                    kind: AstNodeKind::CharLiteral(value),
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::Identifier => {
                let token = self.advance();
                let name = token.get_value().to_string();
                let span = token.get_span();

                if self.peek().get_token_kind() == TokenKind::OpenBrace {
                    let mut fields = IndexMap::new();

                    self.advance();
                    while self.peek().get_token_kind() != TokenKind::CloseBrace {
                        let name_token = self.consume(TokenKind::Identifier)?.clone();
                        let name = name_token.get_value().to_string();

                        let value = if self.peek().get_token_kind() == TokenKind::Colon {
                            self.consume(TokenKind::Colon)?;
                            self.parse_expression()?
                        } else {
                            AstNode {
                                kind: AstNodeKind::Identifier(name.clone()),
                                span: name_token.get_span(),
                                type_id: None,
                                value_id: None,
                                scope_id: None,
                            }
                        };

                        fields.insert(name, value);

                        if self.peek().get_token_kind() == TokenKind::CloseBrace {
                            break;
                        } else {
                            self.consume(TokenKind::Comma)?;
                        }
                    }
                    self.advance();

                    Ok(AstNode {
                        kind: AstNodeKind::StructLiteral { name, fields },
                        span: span.set_end_from_span(self.previous().get_span()),
                        type_id: None,
                        value_id: None,
                        scope_id: None,
                    })
                } else {
                    Ok(AstNode {
                        kind: AstNodeKind::Identifier(name),
                        span,
                        type_id: None,
                        value_id: None,
                        scope_id: None,
                    })
                }
            }
            TokenKind::OpenParenthesis => {
                self.advance();
                let expr = self.parse_expression()?;
                self.consume(TokenKind::CloseParenthesis)?;
                Ok(expr)
            },
            TokenKind::OpenBrace => self.parse_block(),
            TokenKind::Keyword(KeywordKind::This) => {
                self.advance();
                Ok(AstNode {
                    kind: AstNodeKind::SelfValue,
                    span: span.set_end_from_span(self.previous().get_span()),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::Keyword(KeywordKind::Fn) => self.parse_function_expression(),
            TokenKind::Keyword(KeywordKind::If) => self.parse_if_expression(),
            _ => {
                return Err(self.generate_error(
                    ErrorKind::UnexpectedToken(
                        token.get_value().to_string(),
                        format!("{}", token.get_token_kind()),
                        "a unary operator, a literal, an identifier, open parentheses, a function expression, or an if expression".to_string()
                    ),
                    span
                ));
            }
        }
    }

    fn parse_expression_statement(&mut self) -> Result<AstNode, BoxedError> {
        let node = self.parse_expression()?;
        self.consume(TokenKind::Semicolon)?;
        Ok(node)
    }
}

impl Parser {
    pub fn new(lined_source: Vec<String>, tokens: Vec<Token>) -> Parser {
        Parser {
            lines: lined_source,
            tokens,
            current: 0,
            errors: vec![],
        }
    }

    pub fn parse(&mut self) -> Result<AstNode, Vec<Error>> {
        let program = self.parse_program();
        if self.errors.is_empty() {
            Ok(program)
        } else {
            Err(self.errors.clone())
        }
    }

    fn parse_program(&mut self) -> AstNode {
        let mut statements = vec![];

        while !self.is_at_end() {
            match self.parse_statement() {
                Ok(stmt) => statements.push(stmt),
                Err(err) => {
                    self.errors.push(*err);
                    self.synchronize();
                }
            }
        }

        AstNode {
            kind: AstNodeKind::Program(statements),
            span: Span {
                start: 0,
                end: self.tokens.last().unwrap().get_span().end,
                start_pos: Position::default(),
                end_pos: Position {
                    line: self.tokens.last().unwrap().get_span().end_pos.line,
                    column: self.tokens.last().unwrap().get_span().end_pos.column,
                },
            },
            type_id: None,
            value_id: None,
            scope_id: None,
        }
    }

    fn parse_statement(&mut self) -> Result<AstNode, BoxedError> {
        let token = self.peek();
        match token.get_token_kind() {
            TokenKind::Keyword(kind) => self.parse_keyword(kind),
            TokenKind::OpenBrace => self.parse_block(),
            _ => self.parse_expression_statement(),
        }
    }

    fn parse_keyword(&mut self, kind: KeywordKind) -> Result<AstNode, BoxedError> {
        match kind {
            KeywordKind::Let => self.parse_variable_declaration(true),
            KeywordKind::Const => self.parse_variable_declaration(false),
            KeywordKind::Fn => self.parse_function_declaration(),
            KeywordKind::While => self.parse_while_loop(),
            KeywordKind::For => self.parse_for_loop(),
            KeywordKind::Struct => self.parse_struct_declaration(),
            KeywordKind::Return => self.parse_return_statement(),
            KeywordKind::Break => self.parse_break_statement(),
            KeywordKind::Continue => self.parse_continue_statement(),
            KeywordKind::Impl => self.parse_impl_statement(),
            KeywordKind::Enum => self.parse_enum_statement(),
            KeywordKind::Trait => self.parse_trait_declaration(),
            KeywordKind::Type => self.parse_type_declaration(),
            _ => self.parse_expression_statement(),
        }
    }

    fn parse_block(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.consume(TokenKind::OpenBrace)?;

            let mut statements = vec![];
            while !parser.is_at_end() && parser.peek().get_token_kind() != TokenKind::CloseBrace {
                let checkpoint = parser.current;
                
                if let Ok(expr) = parser.parse_expression() {
                    if parser.peek().get_token_kind() == TokenKind::CloseBrace {
                        statements.push(expr);
                        break; 
                    }
                }
                
                parser.current = checkpoint;
                statements.push(parser.parse_statement()?);
            }

            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::Block(statements))
        })
    }

    fn parse_variable_declaration(&mut self, mutable: bool) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let var_name = parser.consume(TokenKind::Identifier)?.get_value().to_string();

            let mut type_annotation = None;
            if parser.match_token(TokenKind::Colon) {
                type_annotation = Some(boxed!(parser.parse_type()?));
            }

            let mut initializer = None;
            if parser.match_token(TokenKind::Operator(Operation::Assign)) {
                initializer = Some(boxed!(parser.parse_expression()?));
            }

            if !mutable && initializer.is_none() {
                return Err(
                    parser.generate_error(ErrorKind::UninitializedConstant, parser.previous().get_span())
                );
            }

            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::VariableDeclaration {
                mutable,
                name: var_name,
                type_annotation,
                initializer,
            })
        })
    }

    fn parse_type(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let mut reference_kind = ReferenceKind::Value;

            if parser.peek().get_token_kind() == TokenKind::Operator(Operation::BitwiseAnd) {
                parser.advance();

                if parser.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::Mut) {
                    parser.advance();
                    reference_kind = ReferenceKind::MutableReference;
                } else {
                    reference_kind = ReferenceKind::Reference;
                }
            }

            let type_reference = parser.advance().clone();

            match type_reference.get_token_kind() {
                TokenKind::Identifier => {
                    if parser.peek().get_token_kind() == TokenKind::Operator(Operation::FieldAccess) {
                        parser.advance();
                        let next = parser.consume(TokenKind::Identifier)?;

                        Ok(AstNodeKind::FieldAccess {
                            left: boxed!(AstNode {
                                kind: AstNodeKind::Identifier(type_reference.get_value().to_string()),
                                span: type_reference.get_span(),
                                value_id: None,
                                scope_id: None,
                                type_id: None
                            }),
                            right: boxed!(AstNode {
                                kind: AstNodeKind::Identifier(next.get_value().to_string()),
                                span: next.get_span(),
                                value_id: None,
                                scope_id: None,
                                type_id: None
                            }),
                        })
                    } else {
                        let generic_types = parser.parse_generic_types_list()?;

                        Ok(AstNodeKind::TypeReference {
                            type_name: type_reference.get_value().to_string(),
                            generic_types,
                            reference_kind,
                        })
                    }
                },

                TokenKind::Keyword(KeywordKind::Int)
                | TokenKind::Keyword(KeywordKind::Float)
                | TokenKind::Keyword(KeywordKind::String)
                | TokenKind::Keyword(KeywordKind::Bool)
                | TokenKind::Keyword(KeywordKind::Char) => {
                    let generic_types = parser.parse_generic_types_list()?;

                    Ok(AstNodeKind::TypeReference {
                        type_name: type_reference.get_value().to_string(),
                        generic_types,
                        reference_kind,
                    })
                },
                TokenKind::Keyword(KeywordKind::Fn) => {
                    let mut params = vec![];

                    parser.consume(TokenKind::OpenParenthesis)?;
                    loop {
                        params.push(parser.parse_type()?);
                        if parser.peek().get_token_kind() == TokenKind::Comma {
                            parser.advance();
                        } else {
                            break;
                        }
                    }
                    parser.consume(TokenKind::CloseParenthesis)?;

                    let mut return_type = None;

                    if parser.peek().get_token_kind() == TokenKind::Colon {
                        parser.advance();
                        return_type = Some(boxed!(parser.parse_type()?));
                    }

                    Ok(AstNodeKind::FunctionPointer { params, return_type })
                },
                TokenKind::OpenBracket => {
                    let ty = boxed!(parser.parse_type()?);

                    let tr = if parser.match_token(TokenKind::Operator(Operation::As)) {
                        Some(boxed!(parser.parse_type()?))
                    } else {
                        None
                    };

                    parser.consume(TokenKind::CloseBracket)?;

                    let kind = AstNodeKind::PathQualifier { ty, tr };

                    if parser.peek().get_token_kind() == TokenKind::Operator(Operation::FieldAccess) {
                        parser.advance();
                        let next = parser.consume(TokenKind::Identifier)?;

                        Ok(AstNodeKind::FieldAccess {
                            left: boxed!(AstNode {
                                kind,
                                span: type_reference.get_span(),
                                value_id: None,
                                scope_id: None,
                                type_id: None
                            }),
                            right: boxed!(AstNode {
                                kind: AstNodeKind::Identifier(next.get_value().to_string()),
                                span: next.get_span(),
                                value_id: None,
                                scope_id: None,
                                type_id: None
                            }),
                        })
                    } else {
                        Ok(kind)
                    }
                },
                _ => {
                    let span = type_reference.get_span();
                    Err(parser.generate_error(
                        ErrorKind::UnexpectedToken(
                            type_reference.get_value().to_string(),
                            format!("{}", type_reference.get_token_kind()),
                            "a type reference".to_string(),
                        ),
                        span,
                    ))
                }
            }
        })
    }

    fn parse_function_signature(
        &mut self,
        is_expression: bool,
        is_associated: bool,
        allow_generics: bool,
    ) -> Result<
        (
            String,
            Vec<AstNode>,
            Vec<AstNode>,
            Option<BoxedAstNode>,
            Option<ReferenceKind>,
        ),
        BoxedError,
    > {
        self.consume(TokenKind::Keyword(KeywordKind::Fn))?;

        let name = if !is_expression {
            self.consume(TokenKind::Identifier)?.get_value().to_string()
        } else {
            String::new()
        };

        let generic_parameters = if allow_generics {
            self.parse_generic_parameter_list()?
        } else {
            vec![]
        };

        let (parameters, instance) = if is_associated {
            self.parse_associated_function_parameter_list()?
        } else {
            (self.parse_function_parameter_list()?, None)
        };

        let mut return_type = None;
        if self.match_token(TokenKind::Colon) {
            return_type = Some(boxed!(self.parse_type()?));
        }

        Ok((name, generic_parameters, parameters, return_type, instance))
    }

    fn parse_function_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(false, false, true)?;
            let body = Some(boxed!(parser.parse_block()?));

            Ok(AstNodeKind::Function {
                qualifier: None,
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body,
            })
        })
    }

    fn parse_function_expression(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(true, false, false)?;
            let body = Some(boxed!(parser.parse_block()?));

            Ok(AstNodeKind::Function {
                qualifier: None,
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body,
            })
        })
    }

    fn parse_parameter(
        &mut self,
        allow_this: bool,
        is_first: bool,
    ) -> Result<(AstNode, Option<ReferenceKind>), BoxedError> {
        let mut self_kind: Option<ReferenceKind> = None;

        let node = self.spanned_node(|parser| {
            if allow_this && is_first {
                let current_token_kind = parser.peek().get_token_kind();
                if current_token_kind == TokenKind::Operator(Operation::BitwiseAnd) {
                    let next_token_is_mut = parser.tokens.get(parser.current + 1).map_or(false, |t| {
                        t.get_token_kind() == TokenKind::Keyword(KeywordKind::Mut)
                    });
                    let next_token_is_this = parser.tokens.get(parser.current + 1).map_or(false, |t| {
                        t.get_token_kind() == TokenKind::Keyword(KeywordKind::This)
                    });
                    let third_token_is_this = next_token_is_mut
                        && parser.tokens.get(parser.current + 2).map_or(false, |t| {
                            t.get_token_kind() == TokenKind::Keyword(KeywordKind::This)
                        });

                    if next_token_is_this || third_token_is_this {
                        parser.advance();

                        let (_, kind) = if parser.match_token(TokenKind::Keyword(KeywordKind::Mut)) {
                            (Operation::MutableAddressOf, ReferenceKind::MutableReference)
                        } else {
                            (Operation::ImmutableAddressOf, ReferenceKind::Reference)
                        };

                        parser.consume(TokenKind::Keyword(KeywordKind::This))?;
                        self_kind = Some(kind);

                        let type_annotation =
                            boxed!(parser.spanned_node(|_| Ok(AstNodeKind::SelfType(kind)))?);
                        return Ok(AstNodeKind::FunctionParameter {
                            name: "this".to_string(),
                            type_annotation,
                            mutable: false,
                        });
                    }
                } else if current_token_kind == TokenKind::Keyword(KeywordKind::This) {
                    parser.advance();
                    self_kind = Some(ReferenceKind::Value);

                    let type_annotation =
                        boxed!(parser.spanned_node(|_| Ok(AstNodeKind::SelfType(ReferenceKind::Value)))?);
                    return Ok(AstNodeKind::FunctionParameter {
                        name: "this".to_string(),
                        type_annotation,
                        mutable: false,
                    });
                }
            }

            let mutable = parser.match_token(TokenKind::Keyword(KeywordKind::Mut));
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Colon)?;
            let type_annotation = boxed!(parser.parse_type()?);

            Ok(AstNodeKind::FunctionParameter {
                name,
                type_annotation,
                mutable,
            })
        })?;

        Ok((node, self_kind))
    }

    fn parse_function_parameter_list(&mut self) -> Result<Vec<AstNode>, BoxedError> {
        let mut parameters = vec![];

        self.consume(TokenKind::OpenParenthesis)?;
        if self.peek().get_token_kind() == TokenKind::CloseParenthesis {
            self.consume(TokenKind::CloseParenthesis)?;
            return Ok(parameters);
        }

        let mut first = true;
        loop {
            let (param, _) = self.parse_parameter(false, first)?;
            parameters.push(param);
            first = false;

            if self.peek().get_token_kind() == TokenKind::CloseParenthesis {
                break;
            } else {
                self.consume(TokenKind::Comma)?;
            }
        }

        self.consume(TokenKind::CloseParenthesis)?;
        Ok(parameters)
    }

    fn parse_associated_function_parameter_list(
        &mut self,
    ) -> Result<(Vec<AstNode>, Option<ReferenceKind>), BoxedError> {
        let mut parameters = vec![];
        let mut instance_kind: Option<ReferenceKind> = None;

        self.consume(TokenKind::OpenParenthesis)?;

        let mut first = true;
        while self.peek().get_token_kind() != TokenKind::CloseParenthesis {
            let (param, self_kind) = self.parse_parameter(true, first)?;
            if self_kind.is_some() {
                instance_kind = self_kind;
            }
            parameters.push(param);
            first = false;

            if self.peek().get_token_kind() == TokenKind::Comma {
                self.consume(TokenKind::Comma)?;
            } else {
                break;
            }
        }

        self.consume(TokenKind::CloseParenthesis)?;
        Ok((parameters, instance_kind))
    }

    fn parse_generic_parameter_list(&mut self) -> Result<Vec<AstNode>, BoxedError> {
        let mut parameters = vec![];

        if self.peek().get_token_kind() != TokenKind::Operator(Operation::LessThan) {
            return Ok(parameters);
        }

        self.consume(TokenKind::Operator(Operation::LessThan))?;
        loop {
            let node = self.spanned_node(|parser| {
                let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
                let mut constraints = vec![];

                if parser.peek().get_token_kind() == TokenKind::Colon {
                    parser.advance();

                    loop {
                        constraints.push(parser.consume(TokenKind::Identifier)?.get_value().to_string());
                        if parser.peek().get_token_kind() != TokenKind::Operator(Operation::Plus) {
                            break;
                        }

                        parser.advance();
                    }
                }

                Ok(AstNodeKind::GenericParameter { name, constraints })
            })?;

            parameters.push(node);

            if self.peek().get_token_kind() == TokenKind::Comma {
                self.consume(TokenKind::Comma)?;
            } else {
                break;
            }
        }

        self.consume(TokenKind::Operator(Operation::GreaterThan))?;

        Ok(parameters)
    }

    fn parse_generic_types_list(&mut self) -> Result<Vec<AstNode>, BoxedError> {
        let mut types = vec![];

        if self.peek().get_token_kind() != TokenKind::Operator(Operation::LessThan) {
            return Ok(types);
        }

        self.consume(TokenKind::Operator(Operation::LessThan))?;
        loop {
            let node = self.parse_type()?;
            types.push(node);

            if self.peek().get_token_kind() == TokenKind::Comma {
                self.consume(TokenKind::Comma)?;
            } else {
                break;
            }
        }

        self.consume(TokenKind::Operator(Operation::GreaterThan))?;

        Ok(types)
    }

    fn parse_if_expression(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.consume(TokenKind::Keyword(KeywordKind::If))?;
            let condition = boxed!(parser.parse_expression()?);
            let then_branch = boxed!(parser.parse_block()?);
            let mut else_if_branches = vec![];
            let mut else_branch = None;

            while parser.match_token(TokenKind::Keyword(KeywordKind::Else)) {
                if parser.match_token(TokenKind::Keyword(KeywordKind::If)) {
                    let else_if_condition = boxed!(parser.parse_expression()?);
                    let else_if_branch = boxed!(parser.parse_block()?);
                    else_if_branches.push((else_if_condition, else_if_branch));
                } else {
                    else_branch = Some(boxed!(parser.parse_block()?));
                    break;
                }
            }

            Ok(AstNodeKind::IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            })
        })
    }

    fn parse_while_loop(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let condition = boxed!(parser.parse_expression()?);
            let body = boxed!(parser.parse_block()?);

            Ok(AstNodeKind::WhileLoop { body, condition })
        })
    }

    fn parse_for_loop(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            parser.consume(TokenKind::OpenParenthesis)?;

            let initializer = if parser.peek().get_token_kind() == TokenKind::Semicolon {
                parser.consume(TokenKind::Semicolon)?;
                None
            } else {
                let init = match parser.peek().get_token_kind() {
                    TokenKind::Keyword(KeywordKind::Let) => parser.parse_variable_declaration(true),
                    TokenKind::Keyword(KeywordKind::Const) => parser.parse_variable_declaration(false),
                    _ => parser.parse_expression_statement(),
                }?;
                Some(boxed!(init))
            };

            let condition = if parser.peek().get_token_kind() == TokenKind::Semicolon {
                parser.consume(TokenKind::Semicolon)?;
                None
            } else {
                let cond = parser.parse_expression()?;
                parser.consume(TokenKind::Semicolon)?;
                Some(boxed!(cond))
            };

            let increment = if parser.peek().get_token_kind() == TokenKind::CloseParenthesis {
                None
            } else {
                Some(boxed!(parser.parse_expression()?))
            };

            parser.consume(TokenKind::CloseParenthesis)?;
            let body = boxed!(parser.parse_block()?);

            Ok(AstNodeKind::ForLoop {
                initializer,
                condition,
                increment,
                body,
            })
        })
    }

    fn parse_return_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let expression = if parser.peek().get_token_kind() != TokenKind::Semicolon {
                let expr = boxed!(parser.parse_expression()?);
                parser.consume(TokenKind::Semicolon)?;
                Some(expr)
            } else {
                parser.advance();
                None
            };

            Ok(AstNodeKind::Return(expression))
        })
    }

    fn parse_continue_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::Continue)
        })
    }

    fn parse_break_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::Break)
        })
    }

    fn parse_struct_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let generic_parameters = parser.parse_generic_parameter_list()?;
            let mut fields = vec![];

            parser.consume(TokenKind::OpenBrace)?;
            while parser.peek().get_token_kind() != TokenKind::CloseBrace {
                fields.push(parser.parse_struct_field()?);
            }
            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::StructDeclaration {
                name,
                generic_parameters,
                fields,
            })
        })
    }

    fn parse_struct_field(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let qualifier_token = parser.advance().clone();
            let qualifier = match qualifier_token.get_token_kind() {
                TokenKind::Keyword(KeywordKind::Public) => QualifierKind::Public,
                TokenKind::Keyword(KeywordKind::Private) => QualifierKind::Private,
                _ => {
                    parser.back();
                    QualifierKind::Public
                }
            };

            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Colon)?;
            let type_annotation = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::StructField {
                qualifier,
                name,
                type_annotation,
            })
        })
    }

    fn parse_impl_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let generic_parameters = parser.parse_generic_parameter_list()?;

            let (type_node, trait_node) = {
                let first = parser.parse_type()?;
                if parser.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::For) {
                    parser.advance();
                    let second = parser.parse_type()?;

                    (boxed!(second), Some(boxed!(first)))
                } else {
                    (boxed!(first), None)
                }
            };

            parser.consume(TokenKind::OpenBrace)?;

            let mut associated_constants = vec![];
            let mut associated_functions = vec![];
            let mut associated_types = vec![];

            while parser.peek().get_token_kind() != TokenKind::CloseBrace {
                let qualifier = if trait_node.is_some() {
                    QualifierKind::Public
                } else {
                    match parser.peek().get_token_kind() {
                        TokenKind::Keyword(KeywordKind::Public) => {
                            parser.advance();
                            QualifierKind::Public
                        }
                        TokenKind::Keyword(KeywordKind::Private) => {
                            parser.advance();
                            QualifierKind::Private
                        }
                        _ => QualifierKind::Public,
                    }
                };

                match parser.peek().get_token_kind() {
                    TokenKind::Keyword(KeywordKind::Const) => {
                        associated_constants.push(parser.parse_associated_constant_declaration(qualifier)?)
                    }
                    TokenKind::Keyword(KeywordKind::Fn) => {
                        associated_functions.push(parser.parse_associated_function(qualifier)?)
                    }
                    TokenKind::Keyword(KeywordKind::Type) => {
                        associated_types.push(parser.parse_associated_type_declaration(qualifier)?)
                    }
                    kind => {
                        let span = parser.previous().get_span();
                        return Err(parser.generate_error(
                            ErrorKind::UnexpectedToken(
                                parser.peek().get_value().to_string(),
                                format!("{}", kind),
                                "an associated function, type, or constant".to_string(),
                            ),
                            span,
                        ));
                    }
                }
            }

            parser.advance();

            Ok(AstNodeKind::ImplDeclaration {
                generic_parameters,
                type_reference: type_node,
                trait_node,
                associated_constants,
                associated_functions,
                associated_types,
            })
        })
    }

    fn parse_associated_constant_declaration(
        &mut self,
        qualifier: QualifierKind,
    ) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let variable_declaration = parser.parse_variable_declaration(false)?;

            let (name, type_annotation, initializer) = match variable_declaration.kind {
                AstNodeKind::VariableDeclaration {
                    name,
                    type_annotation,
                    initializer,
                    ..
                } => (name, type_annotation, initializer),
                _ => unreachable!(),
            };

            let initializer = initializer.ok_or(
                parser.generate_error(ErrorKind::UninitializedConstant, parser.previous().get_span()),
            )?;

            Ok(AstNodeKind::AssociatedConstant {
                qualifier,
                name,
                type_annotation,
                initializer,
            })
        })
    }

    fn parse_associated_function(&mut self, qualifier: QualifierKind) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(false, true, true)?;
            let body = Some(boxed!(parser.parse_block()?));

            Ok(AstNodeKind::Function {
                qualifier: Some(qualifier),
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body,
            })
        })
    }

    fn parse_associated_type_declaration(&mut self, qualifier: QualifierKind) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Operator(Operation::Assign))?;
            let value = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::AssociatedType {
                name,
                value,
                qualifier,
            })
        })
    }

    fn parse_enum_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let mut variants = IndexMap::new();

            parser.consume(TokenKind::OpenBrace)?;
            loop {
                let variant = parser.parse_enum_variant()?;
                let AstNodeKind::EnumVariant(name) = &variant.kind else {
                    unreachable!();
                };

                if parser.peek().get_token_kind() == TokenKind::Operator(Operation::Assign) {
                    parser.advance();
                    variants.insert(name.clone(), (variant, Some(parser.parse_expression()?)));
                } else {
                    variants.insert(name.clone(), (variant, None));
                }

                if parser.peek().get_token_kind() == TokenKind::CloseBrace {
                    break;
                } else {
                    parser.consume(TokenKind::Comma)?;
                }
            }
            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::EnumDeclaration { name, variants })
        })
    }

    fn parse_enum_variant(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let variant_name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            Ok(AstNodeKind::EnumVariant(variant_name))
        })
    }

    fn parse_trait_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let generic_parameters = parser.parse_generic_parameter_list()?;

            let mut signatures = vec![];
            let mut constants = vec![];
            let mut types = vec![];

            parser.consume(TokenKind::OpenBrace)?;
            while parser.peek().get_token_kind() != TokenKind::CloseBrace {
                match parser.peek().get_token_kind() {
                    TokenKind::Keyword(KeywordKind::Const) => constants.push(parser.parse_trait_constant()?),
                    TokenKind::Keyword(KeywordKind::Fn) => {
                        signatures.push(parser.parse_trait_method_signature()?)
                    }
                    TokenKind::Keyword(KeywordKind::Type) => types.push(parser.parse_trait_type()?),
                    kind => {
                        let span = parser.previous().get_span();
                        return Err(parser.generate_error(
                            ErrorKind::UnexpectedToken(
                                parser.peek().get_value().to_string(),
                                format!("{}", kind),
                                "a function signature, type, or constant".to_string(),
                            ),
                            span,
                        ));
                    }
                }
            }

            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::TraitDeclaration {
                name,
                generic_parameters,
                signatures,
                constants,
                types,
            })
        })
    }

    fn parse_trait_constant(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.consume(TokenKind::Keyword(KeywordKind::Const))?;
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Colon)?;
            let type_annotation = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::TraitConstant {
                name,
                type_annotation,
            })
        })
    }

    fn parse_trait_method_signature(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(false, true, true)?;
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::Function {
                qualifier: None,
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body: None,
            })
        })
    }

    fn parse_trait_type(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.consume(TokenKind::Keyword(KeywordKind::Type))?;
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::TraitType(name))
        })
    }

    fn parse_type_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let generic_parameters = parser.parse_generic_parameter_list()?;
            parser.consume(TokenKind::Operator(Operation::Assign))?;
            let value = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::TypeDeclaration {
                name,
                generic_parameters,
                value,
            })
        })
    }
}


// frontend/semantics/analyzer.rs
use crate::{
    frontend::syntax::ast::AstNode,
    utils::{error::*, kind::*},
};
use colored::*;
use std::{
    collections::{HashMap, HashSet, VecDeque},
    rc::Rc,
};
use strum::IntoEnumIterator;
use rustc_hash::FxHashMap;

pub type ScopeId = usize;
pub type ValueNameId = usize;
pub type TypeNameId = usize;
pub type ValueSymbolId = usize;
pub type TypeSymbolId = usize;

/// A lookup table that maps Strings to numbers.
#[derive(Default, Debug)]
pub struct NameInterner {
    map: FxHashMap<Rc<str>, usize>,
    vec: Vec<Rc<str>>,
}

impl NameInterner {
    pub fn new() -> Self {
        Self::default()
    }

    /// Generates a unique ID for a string.
    pub fn intern(&mut self, s: &str) -> usize {
        if let Some(&id) = self.map.get(s) {
            return id;
        }

        let id = self.vec.len();
        let rc: Rc<str> = Rc::from(s);
        self.vec.push(rc.clone());
        self.map.insert(rc, id);

        id
    }

    /// Finds a string given an id.
    pub fn lookup(&self, id: usize) -> &str {
        &self.vec[id]
    }

    pub fn get_id(&self, s: &str) -> Option<usize> {
        self.map.get(s).copied()
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ValueSymbolKind {
    Variable,
    Function(ScopeId),
    StructField,
    EnumVariant,
}

#[derive(Debug, Clone, Copy, PartialEq, strum_macros::EnumIter, strum_macros::Display)]
pub enum PrimitiveKind {
    Int,
    Float,
    Bool,
    String,
    Char,
    Void,
    Never
}

impl PrimitiveKind {
    pub fn to_symbol_str(&self) -> &'static str {
        match self {
            PrimitiveKind::Int => INT_TYPE,
            PrimitiveKind::Float => FLOAT_TYPE,
            PrimitiveKind::Bool => BOOL_TYPE,
            PrimitiveKind::String => STRING_TYPE,
            PrimitiveKind::Char => CHAR_TYPE,
            PrimitiveKind::Void => VOID_TYPE,
            PrimitiveKind::Never => NEVER_TYPE
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct InherentImpl {
    pub scope_id: ScopeId,
    pub specialization: Vec<TypeSymbolId>,
    pub generic_params: Vec<TypeSymbolId>,
    pub span: Span,
}

#[derive(Debug, Clone)]
pub struct TraitImpl {
    pub impl_scope_id: ScopeId,
    pub impl_generic_params: Vec<TypeSymbolId>,
    pub trait_generic_specialization: Vec<TypeSymbolId>,
    pub type_specialization: Vec<TypeSymbolId>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum TypeSymbolKind {
    Primitive(PrimitiveKind),
    Enum((ScopeId, Vec<InherentImpl>)),
    Struct((ScopeId, Vec<InherentImpl>)),
    Trait(ScopeId),
    TraitSelf,
    TypeAlias((Option<ScopeId>, Option<Type>)),
    FunctionSignature {
        params: Vec<Type>,
        return_type: Type,
        instance: Option<ReferenceKind>,
    },
    Generic(Vec<TypeSymbolId>),
    UnificationVariable(TypeSymbolId),
    OpaqueTypeProjection {
        ty: Type,
        tr: Type,
        member: String
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum ScopeKind {
    Root,
    Function,
    Block,
    Enum,
    Struct,
    Impl,
    Trait,
    Type,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    Base { symbol: TypeSymbolId, args: Vec<Type> },
    Reference(Box<Type>),
    MutableReference(Box<Type>),
}

impl Type {
    pub fn new_base(symbol: TypeSymbolId) -> Self {
        Type::Base { symbol, args: vec![] }
    }

    pub fn is_base(&self) -> bool {
        matches!(self, Type::Base { .. })
    }

    pub fn get_base_symbol(&self) -> TypeSymbolId {
        match self {
            Type::Base { symbol, .. } => *symbol,
            Type::Reference(inner) | Type::MutableReference(inner) => inner.get_base_symbol(),
        }
    }

    /// Recursively traverses a type to check if it contains any generic type variables from a given set.
    pub fn contains_generics(&self, generics: &HashSet<TypeSymbolId>) -> bool {
        match self {
            Type::Base { symbol, args } => {
                if generics.contains(symbol) {
                    return true;
                }

                args.iter().any(|arg| arg.contains_generics(generics))
            },
            Type::Reference(inner) | Type::MutableReference(inner) => inner.contains_generics(generics)
        }
    }
}

#[derive(Debug, Clone)]
pub struct ValueSymbol {
    pub id: ValueSymbolId,
    pub name_id: ValueNameId,
    pub kind: ValueSymbolKind,
    pub mutable: bool,
    pub span: Option<Span>,
    pub qualifier: QualifierKind,
    pub scope_id: ScopeId,
    pub type_id: Option<Type>,
}

#[derive(Debug, Clone)]
pub struct TypeSymbol {
    pub id: TypeSymbolId,
    pub name_id: TypeNameId,
    pub kind: TypeSymbolKind,
    pub generic_parameters: Vec<TypeSymbolId>,
    pub qualifier: QualifierKind,
    pub scope_id: ScopeId,
    pub span: Option<Span>,
}

impl TypeSymbol {
    pub fn unify(&self, other: &TypeSymbol) -> Option<TypeSymbolId> {
        if self.id == other.id {
            return Some(self.id);
        }

        match (&self.kind, &other.kind) {
            (_, TypeSymbolKind::Primitive(PrimitiveKind::Never)) | (TypeSymbolKind::Primitive(PrimitiveKind::Never), _) => Some(self.id),
            (_, TypeSymbolKind::TraitSelf) | (TypeSymbolKind::TraitSelf, _) => Some(self.id),

            _ => None
        }
    }

    pub fn is_valid_cast(&self, other: &TypeSymbol) -> bool {
        matches!((&self.kind, &other.kind), 
            (TypeSymbolKind::Primitive(PrimitiveKind::Int), TypeSymbolKind::Primitive(PrimitiveKind::Float))
            | (TypeSymbolKind::Primitive(PrimitiveKind::Float), TypeSymbolKind::Primitive(PrimitiveKind::Int))
            | (TypeSymbolKind::Primitive(PrimitiveKind::Int), TypeSymbolKind::Primitive(PrimitiveKind::Int))
            | (TypeSymbolKind::Primitive(PrimitiveKind::Float), TypeSymbolKind::Primitive(PrimitiveKind::Float))
            | (TypeSymbolKind::Primitive(PrimitiveKind::Char), TypeSymbolKind::Primitive(PrimitiveKind::Int))
            | (TypeSymbolKind::Primitive(PrimitiveKind::Int), TypeSymbolKind::Primitive(PrimitiveKind::Char)) 
            | (TypeSymbolKind::Enum(_), TypeSymbolKind::Primitive(PrimitiveKind::Int))
        )
    }
}

#[derive(Debug)]
pub struct Scope {
    pub values: HashMap<ValueNameId, ValueSymbolId>,
    pub types: HashMap<TypeNameId, TypeSymbolId>,
    pub kind: ScopeKind,
    pub parent: Option<ScopeId>,
    pub id: ScopeId,
    pub receiver_kind: Option<ReferenceKind>,
    pub trait_id: Option<TypeSymbolId>,
}

pub struct SymbolTable {
    pub value_symbols: HashMap<ValueSymbolId, ValueSymbol>,
    pub type_symbols: HashMap<TypeSymbolId, TypeSymbol>,
    value_names: NameInterner,
    type_names: NameInterner,

    pub default_trait_impl_scopes: HashMap<(TypeSymbolId, TypeSymbolId), ScopeId>,

    pub scopes: HashMap<ScopeId, Scope>,

    lines: Rc<Vec<String>>,
    pub current_scope_id: ScopeId,
    next_scope_id: ScopeId,
    next_value_symbol_id: ValueSymbolId,
    next_type_symbol_id: TypeSymbolId,

    real_starting_scope: ScopeId,
}

impl SymbolTable {
    pub fn new(lines: Rc<Vec<String>>) -> Self {
        let mut table = SymbolTable {
            value_symbols: HashMap::new(),
            type_symbols: HashMap::new(),
            value_names: NameInterner::new(),
            type_names: NameInterner::new(),
            default_trait_impl_scopes: HashMap::new(),
            scopes: HashMap::new(),
            lines: lines.clone(),
            current_scope_id: 0,
            next_scope_id: 0,
            next_value_symbol_id: 0,
            next_type_symbol_id: 0,
            real_starting_scope: 0,
        };

        let root_scope_id = table.get_next_scope_id();
        let root_scope = Scope {
            values: HashMap::new(),
            types: HashMap::new(),
            parent: None,
            id: root_scope_id,
            kind: ScopeKind::Root,
            receiver_kind: None,
            trait_id: None,
        };
        table.scopes.insert(root_scope_id, root_scope);

        for ty in PrimitiveKind::iter() {
            table
                .add_type_symbol(
                    ty.to_symbol_str(),
                    TypeSymbolKind::Primitive(ty),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
        }

        let init_scope_id = table.get_next_scope_id();
        let init_scope = Scope {
            values: HashMap::new(),
            types: HashMap::new(),
            parent: Some(root_scope_id),
            id: init_scope_id,
            kind: ScopeKind::Block,
            receiver_kind: None,
            trait_id: None,
        };

        table.scopes.insert(init_scope_id, init_scope);

        table.current_scope_id = init_scope_id;
        table.real_starting_scope = init_scope_id;

        table
    }

    pub fn populate_with_defaults(&mut self, trait_registry: &mut TraitRegistry) {
        let old_scope = self.current_scope_id;
        self.current_scope_id = 0;

        // TRAITS //
        for op in Operation::iter() {
            let Some((trait_name, is_binary)) = op.to_trait_data() else {
                continue;
            };
            let is_unary = !is_binary;

            let fn_name = trait_name
                .chars()
                .enumerate()
                .map(|(i, c)| {
                    if i != 0 && c.is_uppercase() {
                        format!("_{}", c.to_lowercase())
                    } else {
                        c.to_lowercase().to_string()
                    }
                })
                .collect::<String>();

            let trait_scope_id = self.enter_scope(ScopeKind::Trait);

            let self_type_id = self
                .add_type_symbol(
                    "Self",
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
            let output_type_id = self
                .add_type_symbol(
                    "Output",
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();

            let trait_generics = if is_unary { vec![] } else { vec!["Rhs"] };
            let trait_generic_ids: Vec<TypeSymbolId> = trait_generics
                .iter()
                .map(|&name| {
                    self.add_type_symbol(
                        name,
                        TypeSymbolKind::Generic(vec![]),
                        vec![],
                        QualifierKind::Public,
                        None,
                    )
                    .unwrap()
                })
                .collect();

            let mut params = vec![Type::new_base(self_type_id)];
            if !is_unary {
                params.push(Type::new_base(trait_generic_ids[0]));
            }

            self.add_type_symbol(
                &fn_name,
                TypeSymbolKind::FunctionSignature {
                    params,
                    return_type: Type::new_base(output_type_id),
                    instance: Some(ReferenceKind::Value),
                },
                vec![],
                QualifierKind::Public,
                None,
            )
            .unwrap();

            self.exit_scope();

            let trait_id = self
                .add_type_symbol(
                    &trait_name,
                    TypeSymbolKind::Trait(trait_scope_id),
                    trait_generic_ids.clone(),
                    QualifierKind::Public,
                    None,
                )
                .unwrap();

            trait_registry.default_traits.insert(trait_name.clone(), trait_id);

            // DEFAULT IMPLS //
            for primitive in PrimitiveKind::iter() {
                let Some(return_type) = op.to_default_trait_return_type(primitive) else {
                    continue;
                };
                let output_id = self.find_type_symbol(return_type.to_symbol_str()).unwrap().id;
                let self_id = self.find_type_symbol(primitive.to_symbol_str()).unwrap().id;

                let impl_scope_id = self.enter_scope(ScopeKind::Impl);

                let trait_specialization = if is_unary { vec![] } else { vec![self_id] };
                trait_registry.register(
                    trait_id,
                    self_id,
                    TraitImpl {
                        impl_scope_id,
                        impl_generic_params: vec![],
                        trait_generic_specialization: trait_specialization,
                        type_specialization: vec![],
                    },
                );

                self.add_type_symbol(
                    "Self",
                    TypeSymbolKind::TypeAlias((None, Some(Type::new_base(self_id)))),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
                self.add_type_symbol(
                    "Output",
                    TypeSymbolKind::TypeAlias((None, Some(Type::new_base(output_id)))),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
                if !is_unary {
                    self.add_type_symbol(
                        trait_generics[0],
                        TypeSymbolKind::TypeAlias((None, Some(Type::new_base(self_id)))),
                        vec![],
                        QualifierKind::Public,
                        None,
                    )
                    .unwrap();
                }

                let func_scope_id = self.enter_scope(ScopeKind::Function);
                self.add_value_symbol(
                    "this",
                    ValueSymbolKind::Variable,
                    false,
                    QualifierKind::Public,
                    Some(Type::new_base(self_id)),
                    None,
                )
                .unwrap();
                if !is_unary {
                    self.add_value_symbol(
                        "other",
                        ValueSymbolKind::Variable,
                        false,
                        QualifierKind::Public,
                        Some(Type::new_base(self_id)),
                        None,
                    )
                    .unwrap();
                }

                let concrete_sig_params = if is_unary {
                    vec![Type::new_base(self_id)]
                } else {
                    vec![Type::new_base(self_id), Type::new_base(self_id)]
                };
                let concrete_sig_id = self
                    .add_type_symbol(
                        &fn_name,
                        TypeSymbolKind::FunctionSignature {
                            params: concrete_sig_params,
                            return_type: Type::new_base(output_id),
                            instance: Some(ReferenceKind::Value),
                        },
                        vec![],
                        QualifierKind::Public,
                        None,
                    )
                    .unwrap();

                self.add_value_symbol(
                    &fn_name,
                    ValueSymbolKind::Function(func_scope_id),
                    false,
                    QualifierKind::Public,
                    Some(Type::new_base(concrete_sig_id)),
                    None,
                )
                .unwrap();

                self.exit_scope(); // function scope
                self.exit_scope(); // impl scope
            }
        }

        self.current_scope_id = old_scope;
    }

    pub fn add_value_symbol(
        &mut self,
        name: &str,
        kind: ValueSymbolKind,
        mutable: bool,
        qualifier: QualifierKind,
        type_id: Option<Type>,
        span: Option<Span>,
    ) -> Result<ValueSymbolId, BoxedError> {
        let name_id = self.value_names.intern(name);
        let scope_id = self.current_scope_id;

        if let Some(existing_id) = self.scopes[&scope_id].values.get(&name_id) {
            let existing_symbol = &self.value_symbols[existing_id];
            let err = self.create_redeclaration_error(name.to_string(), existing_symbol.span, span);
            return Err(err);
        }

        let id = self.next_value_symbol_id;
        self.next_value_symbol_id += 1;
        let symbol = ValueSymbol {
            id,
            name_id,
            kind,
            mutable,
            qualifier,
            type_id,
            span,
            scope_id,
        };
        self.value_symbols.insert(id, symbol);
        self.scopes.get_mut(&scope_id).unwrap().values.insert(name_id, id);

        Ok(id)
    }

    pub fn add_type_symbol(
        &mut self,
        name: &str,
        kind: TypeSymbolKind,
        generic_parameters: Vec<TypeSymbolId>,
        qualifier: QualifierKind,
        span: Option<Span>,
    ) -> Result<TypeSymbolId, BoxedError> {
        let name_id = self.type_names.intern(name);
        let scope_id = self.current_scope_id;

        if let Some(existing_id) = self.scopes[&scope_id].types.get(&name_id) {
            let existing_symbol = &self.type_symbols[existing_id];
            let err = self.create_redeclaration_error(name.to_string(), existing_symbol.span, span);
            return Err(err);
        }

        let id = self.next_type_symbol_id;
        self.next_type_symbol_id += 1;
        let symbol = TypeSymbol {
            id,
            name_id,
            kind,
            generic_parameters,
            qualifier,
            span,
            scope_id,
        };
        self.type_symbols.insert(id, symbol);
        self.scopes.get_mut(&scope_id).unwrap().types.insert(name_id, id);

        Ok(id)
    }

    pub fn find_value_symbol(&self, name: &str) -> Option<&ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_mut(&mut self, name: &str) -> Option<&mut ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol(&self, name: &str) -> Option<&TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol_mut(&mut self, name: &str) -> Option<&mut TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_from_scope(&self, scope_id: ScopeId, name: &str) -> Option<&ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_from_scope_mut(
        &mut self,
        scope_id: ScopeId,
        name: &str,
    ) -> Option<&mut ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol_from_scope(&self, scope_id: ScopeId, name: &str) -> Option<&TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol_from_scope_mut(
        &mut self,
        scope_id: ScopeId,
        name: &str,
    ) -> Option<&mut TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_in_scope(&self, name: &str, scope_id: ScopeId) -> Option<&ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.values.get(&name_id)?;

        self.value_symbols.get(symbol_id)
    }

    pub fn find_type_symbol_in_scope(&self, name: &str, scope_id: ScopeId) -> Option<&TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.types.get(&name_id)?;

        self.type_symbols.get(symbol_id)
    }

    pub fn find_value_symbol_in_scope_mut(
        &mut self,
        name: &str,
        scope_id: ScopeId,
    ) -> Option<&mut ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.values.get(&name_id)?;
        self.value_symbols.get_mut(symbol_id)
    }

    pub fn find_type_symbol_in_scope_mut(
        &mut self,
        name: &str,
        scope_id: ScopeId,
    ) -> Option<&mut TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.types.get(&name_id)?;
        self.type_symbols.get_mut(symbol_id)
    }

    pub fn get_value_symbol(&self, id: ValueSymbolId) -> Option<&ValueSymbol> {
        self.value_symbols.get(&id)
    }
    pub fn get_value_symbol_mut(&mut self, id: ValueSymbolId) -> Option<&mut ValueSymbol> {
        self.value_symbols.get_mut(&id)
    }
    pub fn get_type_symbol(&self, id: TypeSymbolId) -> Option<&TypeSymbol> {
        self.type_symbols.get(&id)
    }
    pub fn get_type_symbol_mut(&mut self, id: TypeSymbolId) -> Option<&mut TypeSymbol> {
        self.type_symbols.get_mut(&id)
    }
    pub fn get_value_name(&self, id: ValueNameId) -> &str {
        self.value_names.lookup(id)
    }
    pub fn get_type_name(&self, id: TypeNameId) -> &str {
        self.type_names.lookup(id)
    }

    pub fn get_current_scope_id(&self) -> ScopeId {
        self.current_scope_id
    }

    pub fn get_next_scope_id(&mut self) -> ScopeId {
        let new_id = self.next_scope_id;
        self.next_scope_id += 1;
        new_id
    }

    pub fn enter_scope(&mut self, kind: ScopeKind) -> ScopeId {
        let parent_id = self.current_scope_id;
        let new_id = self.get_next_scope_id();

        let new_scope = Scope {
            values: HashMap::new(),
            types: HashMap::new(),
            parent: Some(parent_id),
            id: new_id,
            kind,
            receiver_kind: None,
            trait_id: None,
        };

        self.scopes.insert(new_id, new_scope);
        self.current_scope_id = new_id;
        new_id
    }

    pub fn exit_scope(&mut self) {
        if let Some(parent_id) = self.current_scope().parent {
            self.current_scope_id = parent_id;
        } else {
            panic!("Tried to exit global scope");
        }
    }

    pub fn current_scope_mut(&mut self) -> &mut Scope {
        self.scopes
            .get_mut(&self.current_scope_id)
            .expect("Scope should exist")
    }
    pub fn current_scope(&self) -> &Scope {
        self.scopes
            .get(&self.current_scope_id)
            .expect("Scope should exist")
    }
    pub fn get_scope_mut(&mut self, scope_id: ScopeId) -> Option<&mut Scope> {
        self.scopes.get_mut(&scope_id)
    }
    pub fn get_scope(&self, scope_id: ScopeId) -> Option<&Scope> {
        self.scopes.get(&scope_id)
    }

    fn create_redeclaration_error(
        &self,
        name: String,
        span1: Option<Span>,
        span2: Option<Span>,
    ) -> BoxedError {
        match (span1, span2) {
            (Some(s1), Some(s2)) => Error::from_multiple_errors(
                ErrorKind::AlreadyDeclared(name),
                s2,
                Span::get_all_lines(self.lines.clone(), &[s1, s2]),
            ),
            (Some(s), None) | (None, Some(s)) => Error::from_one_error(
                ErrorKind::AlreadyDeclared(name),
                s,
                (self.lines[s.start_pos.line - 1].clone(), s.start_pos.line),
            ),
            (None, None) => Error::new(ErrorKind::AlreadyDeclared(name)),
        }
    }
}

#[derive(Default)]
pub struct TraitRegistry {
    pub register: HashMap<TypeSymbolId, HashMap<TypeSymbolId, Vec<TraitImpl>>>,
    pub default_traits: HashMap<String, TypeSymbolId>,
}

impl TraitRegistry {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn register(&mut self, trait_id: TypeSymbolId, type_id: TypeSymbolId, implementation: TraitImpl) {
        self.register
            .entry(trait_id)
            .or_default()
            .entry(type_id)
            .or_default()
            .push(implementation);
    }

    pub fn get_default_trait(&self, name: &String) -> TypeSymbolId {
        *self.default_traits.get(name).unwrap()
    }
}

/// A constraint imposed onto a metavariable.
#[derive(Debug, Clone)]
pub enum Constraint {
    /// Two types are equal.
    Equality(Type, Type),
    /// A type denotes a function call on an instance.
    MethodCall(Type, Type, Vec<Type>, Type),
    /// A type denotes a function pointer.
    FunctionSignature(Type, Vec<Type>, Type),
    /// A type denotes the result of an operation that
    /// is trait overloadable.
    Operation(Type, Type, Type, Option<Type>, Operation),
    /// A type denotes the value of a member on an instance variable.
    InstanceMemberAccess(Type, Type, String),
    /// A type denotes a static member of a type, like an enum variant.
    StaticMemberAccess(Type, Type, String),
    /// A type denotes a fully qualified path access.
    FullyQualifiedAccess(Type, Type, Option<Type>, String),
    /// The initial type must be validly castable to the other.
    Cast(Type, Type)
}

/// Additional information about a constraint.
#[derive(Debug, Clone, Copy)]
pub struct ConstraintInfo {
    pub span: Span,
    pub scope_id: ScopeId,
}

#[derive(Default)]
pub struct UnificationContext {
    next_id: TypeSymbolId,
    pub substitutions: HashMap<TypeSymbolId, Type>,
    pub constraints: VecDeque<(Constraint, ConstraintInfo)>,
}

impl UnificationContext {
    fn get_next_uv_id(&mut self) -> TypeSymbolId {
        let old = self.next_id;
        self.next_id += 1;
        old
    }

    pub fn generate_uv_type(&mut self, symbol_table: &mut SymbolTable, span: Span) -> Type {
        let id = self.get_next_uv_id();

        let symbol = symbol_table
            .add_type_symbol(
                &format!("#uv_{}", id),
                TypeSymbolKind::UnificationVariable(id),
                vec![],
                QualifierKind::Private,
                Some(span),
            )
            .unwrap();

        Type::Base { symbol, args: vec![] }
    }

    pub fn register_constraint(&mut self, constraint: Constraint, info: ConstraintInfo) {
        self.constraints.push_back((constraint, info));
    }
}

pub struct UVCollectionContext {
    pub current_return_type: Option<Type>,
    pub in_loop: bool
}

pub struct SemanticAnalyzer {
    pub symbol_table: SymbolTable,
    pub builtin_types: Vec<TypeSymbolId>,
    pub trait_registry: TraitRegistry,
    pub unification_context: UnificationContext,
    // TODO: Find better place to put this.
    pub uv_collection_ctx: UVCollectionContext,
    errors: Vec<Error>,
    lines: Rc<Vec<String>>,
}

impl SemanticAnalyzer {
    pub fn new(lines: Rc<Vec<String>>) -> SemanticAnalyzer {
        let mut symbol_table = SymbolTable::new(lines.clone());
        let mut trait_registry = TraitRegistry::new();

        symbol_table.populate_with_defaults(&mut trait_registry);

        let builtin_types: Vec<TypeSymbolId> = PrimitiveKind::iter()
            .map(|k| symbol_table.find_type_symbol(k.to_symbol_str()).unwrap().id)
            .collect();

        SemanticAnalyzer {
            trait_registry,
            symbol_table,
            builtin_types,
            unification_context: UnificationContext::default(),
            uv_collection_ctx: UVCollectionContext { current_return_type: None, in_loop: false },
            errors: vec![],
            lines,
        }
    }

    pub fn delete_uvs(&mut self) {
        let uvs_to_remove = self.symbol_table.type_symbols
            .values()
            .filter_map(|symbol| {
                if let TypeSymbolKind::UnificationVariable(_) = symbol.kind {
                    Some((symbol.id, symbol.name_id))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();
    
        if uvs_to_remove.is_empty() {
            return;
        }

        let uv_symbol_ids_set: HashSet<TypeSymbolId> = uvs_to_remove.iter().map(|(id, _)| *id).collect();

        self.symbol_table.type_symbols.retain(|id, _| !uv_symbol_ids_set.contains(id));
        for scope in self.symbol_table.scopes.values_mut() {
            scope.types.retain(|_name_id, symbol_id| !uv_symbol_ids_set.contains(symbol_id));
        }

        let type_names_interner = &mut self.symbol_table.type_names;
        for (_, name_id) in uvs_to_remove {
            let name_to_remove = type_names_interner.vec[name_id].clone();
            type_names_interner.map.remove(name_to_remove.as_ref());
            type_names_interner.vec[name_id] = Rc::from("[deleted_uv]");
        }
    }

    pub fn create_error(&self, kind: ErrorKind, primary_span: Span, spans: &[Span]) -> BoxedError {
        let lines = Span::get_all_lines(self.lines.clone(), spans);
        Error::from_multiple_errors(kind, primary_span, lines)
    }

    pub fn analyze(&mut self, mut program: AstNode) -> Result<AstNode, Vec<Error>> {
        macro_rules! pass {
            ($self:ident, $method:ident, $program:expr) => {{
                let errors = $self.$method(&mut $program);
                if !errors.is_empty() {
                    return Err(errors);
                }
            }};
        }

        pass!(self, symbol_collector_pass, &mut program);
        pass!(self, generic_constraints_pass, &mut program);
        pass!(self, struct_field_type_collector_pass, &mut program);
        pass!(self, impl_collector_pass, &mut program);
        pass!(self, uv_collector_pass, &mut program);
        pass!(self, inherent_impl_deduplication_pass, &mut program);
        pass!(self, unification_pass, &mut program);
        pass!(self, substitution_pass, &mut program);
        pass!(self, mutability_check_pass, &mut program);
        pass!(self, trait_conformance_pass, &mut program);

        Ok(program)
    }
}

impl std::fmt::Display for InherentImpl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InherentImpl(scope_id: {}, specialization: {:?}, generic_params: {:?}, span: {:?})",
            self.scope_id, self.specialization, self.generic_params, self.span
        )
    }
}

impl std::fmt::Display for TraitImpl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TraitImpl(impl_scope_id: {:?}, impl_generic_params: {:?}, trait_generic_specialization: {:?}, type_specialization: {:?})", 
            self.impl_scope_id, self.impl_generic_params, self.trait_generic_specialization, self.type_specialization)
    }
}

impl std::fmt::Display for ValueSymbolKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let colored = match self {
            ValueSymbolKind::Variable => "Variable".green(),
            ValueSymbolKind::Function(scope_id) => format!("Function({})", scope_id).blue(),
            ValueSymbolKind::StructField => "StructField".yellow(),
            ValueSymbolKind::EnumVariant => "EnumVariant".yellow(),
        };
        write!(f, "{}", colored)
    }
}

impl SymbolTable {
    pub fn display_value_symbol<'a>(&'a self, symbol: &'a ValueSymbol) -> impl std::fmt::Display + 'a {
        struct Displayer<'a> {
            symbol: &'a ValueSymbol,
            table: &'a SymbolTable,
        }
        impl std::fmt::Display for Displayer<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let name = self.table.get_value_name(self.symbol.name_id);
                write!(f, "{}", name.cyan().bold())?;
                write!(f, " ({})", self.symbol.kind)?;
                if self.symbol.mutable {
                    write!(f, " {}", "mut".red())?;
                }
                write!(f, " {}", self.symbol.qualifier)?;
                Ok(())
            }
        }
        Displayer { symbol, table: self }
    }

    // TODO: Make display_type_symbol more robust.
    pub fn display_type_symbol<'a>(&'a self, symbol: &'a TypeSymbol) -> impl std::fmt::Display + 'a {
        struct Displayer<'a> {
            symbol: &'a TypeSymbol,
            table: &'a SymbolTable,
        }
        impl std::fmt::Display for Displayer<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let name = self.table.get_type_name(self.symbol.name_id);
                let type_variant = match &self.symbol.kind {
                    TypeSymbolKind::Struct((id, scopes)) => format!("Struct({}, {:?})", id, scopes).blue(),
                    TypeSymbolKind::Trait(id) => format!("Trait({})", id).cyan(),
                    TypeSymbolKind::Enum((id, scopes)) => format!("Enum({}, {:?})", id, scopes).blue(),
                    TypeSymbolKind::TypeAlias(id) => format!("TypeAlias({:?})", id).white(),
                    TypeSymbolKind::TraitSelf => "TraitSelf".green(),
                    TypeSymbolKind::Primitive(k) => format!("Builtin({})", k).green(),
                    TypeSymbolKind::FunctionSignature {
                        params, return_type, ..
                    } => {
                        let params_str = params
                            .iter()
                            .map(|p_ty| self.table.display_type(p_ty))
                            .collect::<Vec<_>>()
                            .join(", ");
                        format!("fn({}): {}", params_str, self.table.display_type(return_type)).blue()
                    }
                    TypeSymbolKind::Generic(constraints) => format!("Generic({:?})", constraints).white(),
                    TypeSymbolKind::UnificationVariable(id) => format!("UnificationVariable({})", id).red(),
                    TypeSymbolKind::OpaqueTypeProjection { ty, tr, member } =>
                        format!("[{:?} as {:?}]::{:?}", ty, tr, member).white()
                };
                write!(f, "[{}] {}", type_variant, name.cyan().bold())?;
                if !self.symbol.generic_parameters.is_empty() {
                    let params = self
                        .symbol
                        .generic_parameters
                        .iter()
                        .map(|id| self.table.get_type_name(self.table.type_symbols[id].name_id))
                        .collect::<Vec<_>>()
                        .join(", ");
                    write!(f, "<{}>", params)?;
                }
                Ok(())
            }
        }

        Displayer { symbol, table: self }
    }

    pub fn display_type<'a>(&'a self, ty: &'a Type) -> String {
        match ty {
            Type::Base { symbol, args } => {
                let type_symbol = &self.type_symbols[symbol];
                match &type_symbol.kind {
                    TypeSymbolKind::FunctionSignature {
                        params,
                        return_type,
                        ..
                    } => {
                        let generic_params_str = if !type_symbol.generic_parameters.is_empty() {
                            let params_list = type_symbol
                                .generic_parameters
                                .iter()
                                .map(|p_id| {
                                    self.get_type_name(self.get_type_symbol(*p_id).unwrap().name_id)
                                })
                                .collect::<Vec<_>>()
                                .join(", ");
                            format!("<{}>", params_list)
                        } else {
                            "".to_string()
                        };

                        let params_str = params
                            .iter()
                            .map(|p_ty| self.display_type(p_ty))
                            .collect::<Vec<_>>()
                            .join(", ");

                        let is_null_return = if let Type::Base {
                            symbol: ret_symbol, ..
                        } = &return_type
                        {
                            if let Some(symbol) = self.get_type_symbol(*ret_symbol) {
                                matches!(symbol.kind, TypeSymbolKind::Primitive(PrimitiveKind::Void))
                            } else {
                                false
                            }
                        } else {
                            false
                        };

                        if is_null_return {
                            format!("fn{}({})", generic_params_str, params_str)
                        } else {
                            format!(
                                "fn{}({}) -> {}",
                                generic_params_str,
                                params_str,
                                self.display_type(return_type)
                            )
                        }
                    }
                    _ => {
                        let base_name = self.get_type_name(type_symbol.name_id);
                        if args.is_empty() {
                            base_name.to_string()
                        } else {
                            let arg_str = args
                                .iter()
                                .map(|arg| self.display_type(arg))
                                .collect::<Vec<_>>()
                                .join(", ");
                            format!("{}<{}>", base_name, arg_str)
                        }
                    }
                }
            }
            Type::Reference(inner) => format!("&{}", self.display_type(inner)),
            Type::MutableReference(inner) => format!("&mut {}", self.display_type(inner)),
        }
    }

    fn display_scope(
        &self,
        scope_id: ScopeId,
        indent: usize,
        f: &mut std::fmt::Formatter,
    ) -> std::fmt::Result {
        let scope = self.scopes.get(&scope_id).unwrap();
        for symbol_id in scope.values.values() {
            let symbol = &self.value_symbols[symbol_id];
            writeln!(
                f,
                "{:indent$}[Value({})] {}",
                "",
                symbol_id,
                self.display_value_symbol(symbol),
                indent = indent
            )?;
        }
        for symbol_id in scope.types.values() {
            let symbol = &self.type_symbols[symbol_id];
            writeln!(
                f,
                "{:indent$}[Type({})] {}",
                "",
                symbol_id,
                self.display_type_symbol(symbol),
                indent = indent
            )?;
        }
        let mut child_scope_ids: Vec<ScopeId> = self
            .scopes
            .values()
            .filter(|s| s.parent == Some(scope_id))
            .map(|s| s.id)
            .collect();
        child_scope_ids.sort();
        for child_id in child_scope_ids {
            writeln!(f, "{:indent$}{{ (Scope({}))", "", child_id, indent = indent)?;
            self.display_scope(child_id, indent + 4, f)?;
            writeln!(f, "{:indent$}}}", "", indent = indent)?;
        }
        Ok(())
    }
}

impl std::fmt::Display for SymbolTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "--- User Scope ({}) ---", self.real_starting_scope)?;
        self.display_scope(self.real_starting_scope, 0, f)
    }
}

impl TraitRegistry {
    pub fn display<'a>(&'a self, symbol_table: &'a SymbolTable) -> impl std::fmt::Display + 'a {
        struct Displayer<'a> {
            registry: &'a TraitRegistry,
            table: &'a SymbolTable,
        }
        impl std::fmt::Display for Displayer<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                for (trait_id, impls) in &self.registry.register {
                    let trait_symbol = &self.table.type_symbols[trait_id];
                    let trait_name = self.table.get_type_name(trait_symbol.name_id);

                    if self.registry.default_traits.contains_key(trait_name) {
                        continue;
                    }

                    writeln!(
                        f,
                        "{}",
                        format!("[Trait({})] {}", trait_id, trait_name).underline()
                    )?;
                    for (type_id, impl_details) in impls {
                        let type_symbol = &self.table.type_symbols[type_id];
                        let type_name = self.table.get_type_name(type_symbol.name_id);
                        write!(f, "  for [Type({})] {}: ", type_id, type_name)?;
                        for (i, impl_detail) in impl_details.iter().enumerate() {
                            if i > 0 {
                                write!(f, ", ")?;
                            }
                            write!(f, "{:?}", impl_detail)?;
                        }
                        writeln!(f)?;
                    }
                }
                Ok(())
            }
        }
        Displayer {
            registry: self,
            table: symbol_table,
        }
    }
}

impl Constraint {
    fn fmt<'a>(&'a self, table: &'a SymbolTable) -> impl std::fmt::Display + 'a {
        struct C<'a> {
            c: &'a Constraint,
            t: &'a SymbolTable,
        }
        impl std::fmt::Display for C<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                use Constraint::*;
                match self.c {
                    Equality(lhs, rhs) => write!(
                        f,
                        "{} {} {}",
                        self.t.display_type(lhs).yellow(),
                        "=".blue(),
                        self.t.display_type(rhs).yellow()
                    ),
                    MethodCall(instance, callee, ps, r) => {
                        let ps_str = ps
                            .iter()
                            .map(|p| self.t.display_type(p))
                            .collect::<Vec<_>>()
                            .join(", ");
                        write!(
                            f,
                            "({}).call({}) -> {} where callee is {}",
                            self.t.display_type(instance).yellow(),
                            ps_str,
                            self.t.display_type(r),
                            self.t.display_type(callee).cyan()
                        )
                    },
                    FunctionSignature(callee, ps, r) => {
                        let ps_str = ps
                            .iter()
                            .map(|p| self.t.display_type(p))
                            .collect::<Vec<_>>()
                            .join(", ");
                        write!(
                            f,
                            "{} {} fn({}) -> {}",
                            self.t.display_type(callee).yellow(),
                            "=".blue(),
                            ps_str,
                            self.t.display_type(r)
                        )
                    }
                    Operation(result, trait_ty, lhs, rhs, operation) => {
                        let op_str = if let Some(r) = rhs {
                            format!("{}({}, {})", operation, self.t.display_type(lhs), self.t.display_type(r))
                        } else {
                            format!("{}({})", operation, self.t.display_type(lhs))
                        };

                        write!(
                            f,
                            "{} = {} where {}: {}<{}>",
                            self.t.display_type(result).yellow(),
                            op_str,
                            self.t.display_type(lhs),
                            self.t.display_type(trait_ty).cyan(),
                            if let Some(rhs) = rhs {
                                self.t.display_type(rhs)
                            } else {
                                "Self".to_string()
                            }
                        )
                    }
                    InstanceMemberAccess(result, base, m) => write!(
                        f,
                        "{} = {}.{}",
                        self.t.display_type(result).yellow(),
                        self.t.display_type(base),
                        m.green()
                    ),
                    StaticMemberAccess(result, base, m) => write!(
                        f,
                        "{} = {}::{}",
                        self.t.display_type(result).yellow(),
                        self.t.display_type(base).bright_blue(),
                        m.green()
                    ),
                    FullyQualifiedAccess(result, ty, tr, m) => {
                        write!(f, "{} = <{}", self.t.display_type(result).yellow(), self.t.display_type(ty))?;
                        if let Some(tr) = tr {
                            write!(f, " as {}", self.t.display_type(tr))?;
                        }
                        write!(f, ">.{}", m.green())
                    },
                    Cast(initial, r#final) => write!(
                        f,
                        "{} -> {}",
                        self.t.display_type(initial).yellow(),
                        self.t.display_type(r#final).yellow()
                    )
                }
            }
        }
        C { c: self, t: table }
    }
}

impl UnificationContext {
    pub fn display<'a>(&'a self, table: &'a SymbolTable) -> impl std::fmt::Display + 'a {
        use colored::*;

        struct D<'a> {
            ctx: &'a UnificationContext,
            tbl: &'a SymbolTable,
        }
        
        impl std::fmt::Display for D<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                if self.ctx.substitutions.is_empty() {
                    writeln!(f, "{}", "* Substitutions: (none)".dimmed())?;
                } else {
                    writeln!(f, "* {}", "Substitutions:".bold())?;
                    let mut subs: Vec<_> = self.ctx.substitutions.iter().collect();
                    subs.sort_by_key(|(uv, _)| *uv);
                    for (uv_symbol_id, sym) in subs {
                        let uv_name = self.tbl.get_type_name(self.tbl.get_type_symbol(*uv_symbol_id).unwrap().name_id);
                        let lhs = uv_name.red().bold();
                        let rhs = self.tbl.display_type(sym).green();
                        writeln!(f, "    {} {} [{}]({})", lhs, "->".blue(), rhs, sym.get_base_symbol())?;
                    }
                }

               let unresolved_uvs: Vec<&TypeSymbol> = self.tbl.type_symbols
                    .values()
                    .filter(|symbol| {
                        if let TypeSymbolKind::UnificationVariable(_) = symbol.kind {
                            !self.ctx.substitutions.contains_key(&symbol.id)
                        } else {
                            false
                        }
                    })
                    .collect();

                if unresolved_uvs.is_empty() {
                    writeln!(f, "{}", "* Unresolved UVs: (none)".dimmed())?;
                } else {
                    let mut uv_names: Vec<String> = unresolved_uvs
                        .iter()
                        .map(|s| self.tbl.get_type_name(s.name_id).red().to_string())
                        .collect();
                    uv_names.sort();
                    let list = uv_names.join(", ");
                    writeln!(f, "* {} {}", "Unresolved UVs:".bold(), list)?;
                }

                // --- constraints ------------------------------------------------------------
                if self.ctx.constraints.is_empty() {
                    writeln!(f, "{}", "* Constraints: (none)".dimmed())
                } else {
                    writeln!(f, "* {}", "Constraints:".bold())?;
                    for (i, c) in self.ctx.constraints.iter().enumerate() {
                        writeln!(f, "    {}) {}", i + 1, c.0.fmt(self.tbl))?;
                    }
                    Ok(())
                }
            }
        }

        D {
            ctx: self,
            tbl: table,
        }
    }
}

impl std::fmt::Display for SemanticAnalyzer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "{}", "Symbol Table:".bold().underline())?;
        writeln!(f, "{}", self.symbol_table)?;
        writeln!(f, "\n{}", "Trait Registry:".bold().underline())?;
        writeln!(f, "{}", self.trait_registry.display(&self.symbol_table))?;
        writeln!(f, "\n{}", "Unification Context:".bold().underline())?;
        writeln!(f, "{}", self.unification_context.display(&self.symbol_table))?;

        Ok(())
    }
}

impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Type::Base { symbol, args } => {
                let base_name = format!("TypeSymbol({})", symbol);
                if args.is_empty() {
                    write!(f, "{}", base_name)
                } else {
                    let arg_str = args
                        .iter()
                        .map(|arg| format!("{}", arg))
                        .collect::<Vec<_>>()
                        .join(", ");
                    write!(f, "{}<{}>", base_name, arg_str)
                }
            }
            Type::Reference(inner) => write!(f, "&{}", inner),
            Type::MutableReference(inner) => write!(f, "&mut {}", inner),
        }
    }
}

// frontend/semantics/symbols.rs
use super::analyzer::{ScopeKind, SemanticAnalyzer, ValueSymbolKind};
use crate::{
    frontend::syntax::ast::{AstNode, AstNodeKind, BoxedAstNode},
    frontend::semantics::analyzer::{
        InherentImpl, PrimitiveKind, TraitImpl, Type, TypeSymbolId, TypeSymbolKind, ValueSymbolId,
    },
    utils::{
        error::*,
        kind::{QualifierKind, ReferenceKind, Span},
    },
};
use indexmap::IndexMap;

impl SemanticAnalyzer {
    pub fn symbol_collector_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        program.scope_id = Some(self.symbol_table.get_current_scope_id());

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.symbol_collector_check_node(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn symbol_collector_check_node(
        &mut self,
        node: &mut AstNode,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        node.scope_id = Some(self.symbol_table.get_current_scope_id());

        use AstNodeKind::*;

        let declared_symbol_opt = match &mut node.kind {
            VariableDeclaration {
                name,
                mutable,
                type_annotation,
                initializer,
            } => self.collect_variable_symbol(name, *mutable, type_annotation, initializer, node.span),
            Function { .. } => self.collect_function_item_symbols(node),
            StructDeclaration {
                name,
                fields,
                generic_parameters,
            } => self.collect_struct_symbols(name, fields, generic_parameters, node.span),
            ImplDeclaration { .. } => Ok((None, None)),
            PathQualifier { ty, tr } => {
                self.symbol_collector_check_node(ty)?;
                self.collect_optional_node(tr)?;
                Ok((None, None))
            },
            EnumDeclaration { name, variants } => self.collect_enum_symbols(name, variants, node.span),
            TraitDeclaration {
                name,
                generic_parameters,
                constants,
                types,
                signatures,
            } => {
                self.collect_trait_symbols(name, generic_parameters, constants, types, signatures, node.span)
            }
            TypeDeclaration {
                name,
                generic_parameters,
                value
            } => self.collect_type_symbols(name, generic_parameters, value, node.span),
            Block(_) => self.collect_block_symbols(node),
            _ => {
                for child in node.children_mut() {
                    self.symbol_collector_check_node(child)?;
                }

                Ok((None, None))
            }
        };

        if let Ok((value_id_opt, ref type_id_opt)) = declared_symbol_opt {
            node.value_id = value_id_opt;
            node.type_id = type_id_opt.clone();
        }

        declared_symbol_opt
    }

    fn collect_variable_symbol(
        &mut self,
        name: &str,
        mutable: bool,
        type_annotation: &mut Option<BoxedAstNode>,
        initializer: &mut Option<BoxedAstNode>,
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        self.collect_optional_node(type_annotation)?;
        self.collect_optional_node(initializer)?;

        let value_id = self.symbol_table.add_value_symbol(
            name,
            ValueSymbolKind::Variable,
            mutable,
            QualifierKind::Public,
            None,
            Some(span),
        )?;

        Ok((Some(value_id), None))
    }

    fn collect_function_item_symbols(
        &mut self,
        node: &mut AstNode,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let (is_declaration, qualifier, name, generic_parameters, parameters, return_type, body, instance) =
            if let AstNodeKind::Function {
                qualifier,
                name,
                generic_parameters,
                parameters,
                return_type,
                body,
                instance,
            } = &mut node.kind
            {
                (
                    !name.is_empty(),
                    *qualifier,
                    name.clone(),
                    generic_parameters,
                    parameters,
                    return_type,
                    body,
                    instance,
                )
            } else {
                unreachable!();
            };

        let scope_id = self.symbol_table.enter_scope(ScopeKind::Function);
        node.scope_id = Some(scope_id);

        let scope = self.symbol_table.get_scope_mut(scope_id).unwrap();
        scope.receiver_kind = *instance;

        self.collect_generic_parameters(generic_parameters)?;
        self.collect_function_parameters(parameters)?;
        self.collect_optional_node(return_type)?;

        if let Some(b) = body {
            self.symbol_collector_check_node(b)?;
        }

        self.symbol_table.exit_scope();

        if is_declaration {
            let value_id = self.symbol_table.add_value_symbol(
                &name,
                ValueSymbolKind::Function(scope_id),
                false,
                qualifier.unwrap_or(QualifierKind::Public),
                None,
                Some(node.span),
            )?;
            Ok((Some(value_id), None))
        } else {
            Ok((None, None))
        }
    }

    fn collect_struct_symbols(
        &mut self,
        name: &str,
        fields: &mut [AstNode],
        generic_parameters: &mut [AstNode],
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let scope_id = self.symbol_table.enter_scope(ScopeKind::Struct);

        let generic_param_ids = self.collect_generic_parameters(generic_parameters)?;
        for field in fields {
            self.symbol_collector_check_node(field)?;
            if let AstNodeKind::StructField { qualifier, name, .. } = &field.kind {
                let field_id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::StructField,
                    false,
                    *qualifier,
                    None,
                    Some(field.span),
                )?;
                field.value_id = Some(field_id);
            }
        }

        self.symbol_table.exit_scope();

        let type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::Struct((scope_id, vec![])),
            generic_param_ids,
            QualifierKind::Public,
            Some(span),
        )?;

        Ok((None, Some(Type::new_base(type_id))))
    }

    fn collect_enum_symbols(
        &mut self,
        name: &str,
        variants: &mut IndexMap<String, (AstNode, Option<AstNode>)>,
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let scope_id = self.symbol_table.enter_scope(ScopeKind::Enum);

        for (variant_name, (variant_node, _)) in variants {
            self.symbol_collector_check_node(variant_node)?;
            let variant_id = self.symbol_table.add_value_symbol(
                variant_name,
                ValueSymbolKind::EnumVariant,
                false,
                QualifierKind::Public,
                None,
                Some(variant_node.span),
            )?;
            variant_node.value_id = Some(variant_id);
        }

        self.symbol_table.exit_scope();
        let type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::Enum((scope_id, vec![])),
            vec![],
            QualifierKind::Public,
            Some(span),
        )?;

        Ok((None, Some(Type::new_base(type_id))))
    }

    fn collect_trait_symbols(
        &mut self,
        name: &mut str,
        generic_parameters: &mut [AstNode],
        constants: &mut [AstNode],
        types: &mut [AstNode],
        signatures: &mut [AstNode],
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let trait_scope_id = self.symbol_table.enter_scope(ScopeKind::Trait);

        let generic_param_ids = self.collect_generic_parameters(generic_parameters)?;
        self.symbol_table.add_type_symbol(
            "Self",
            TypeSymbolKind::TraitSelf,
            vec![],
            QualifierKind::Public,
            None,
        )?;

        for const_node in constants {
            self.symbol_collector_check_node(const_node)?;
            if let AstNodeKind::TraitConstant { name, .. } = &const_node.kind {
                let const_id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Variable,
                    false,
                    QualifierKind::Public,
                    None,
                    Some(const_node.span),
                )?;
                const_node.value_id = Some(const_id);
            }
        }

        for type_node in types {
            self.symbol_collector_check_node(type_node)?;
            if let AstNodeKind::TraitType(name) = &type_node.kind {
                let type_id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    QualifierKind::Public,
                    Some(type_node.span),
                )?;
                type_node.type_id = Some(Type::new_base(type_id));
            }
        }

        for signature in signatures.iter_mut() {
            self.symbol_collector_check_node(signature)?;
            if let AstNodeKind::Function {
                name,
                generic_parameters,
                instance,
                ..
            } = &mut signature.kind
            {
                let sig_generic_param_ids = self.collect_generic_parameters(generic_parameters)?;

                let sig_type_id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::FunctionSignature {
                        params: vec![],
                        return_type: Type::new_base(self.builtin_types[PrimitiveKind::Void as usize]),
                        instance: *instance,
                    },
                    sig_generic_param_ids,
                    QualifierKind::Public,
                    Some(signature.span),
                )?;

                signature.type_id = Some(Type::new_base(sig_type_id));
            }
        }

        self.symbol_table.exit_scope();

        let trait_type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::Trait(trait_scope_id),
            generic_param_ids,
            QualifierKind::Public,
            Some(span),
        )?;
        Ok((None, Some(Type::new_base(trait_type_id))))
    }

    fn collect_generic_parameters(
        &mut self,
        params: &mut [AstNode],
    ) -> Result<Vec<TypeSymbolId>, BoxedError> {
        let mut ids = vec![];
        for param in params {
            self.symbol_collector_check_node(param)?;
            if let AstNodeKind::GenericParameter { name, .. } = &param.kind {
                let id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::Generic(vec![]),
                    vec![],
                    QualifierKind::Public,
                    Some(param.span),
                )?;
                param.type_id = Some(Type::new_base(id));
                ids.push(id);
            }
        }
        Ok(ids)
    }

    fn collect_function_parameters(
        &mut self,
        params: &mut [AstNode],
    ) -> Result<Vec<ValueSymbolId>, BoxedError> {
        let mut ids = vec![];
        for param in params {
            self.symbol_collector_check_node(param)?;
            if let AstNodeKind::FunctionParameter { name, mutable, .. } = &param.kind {
                let id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Variable,
                    *mutable,
                    QualifierKind::Public,
                    None,
                    Some(param.span),
                )?;
                param.value_id = Some(id);
                ids.push(id);
            }
        }
        Ok(ids)
    }

    fn collect_block_symbols(
        &mut self,
        node: &mut AstNode,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let scope_id = self.symbol_table.enter_scope(ScopeKind::Block);
        node.scope_id = Some(scope_id);

        if let AstNodeKind::Block(statements) = &mut node.kind {
            for statement in statements {
                self.symbol_collector_check_node(statement)?;
            }
        }

        self.symbol_table.exit_scope();
        Ok((None, None))
    }

    fn collect_type_symbols(
        &mut self,
        name: &str,
        generic_parameters: &mut [AstNode],
        value: &mut BoxedAstNode,
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let (scope_id, generics) = if !generic_parameters.is_empty() {
            let scope_id = self.symbol_table.enter_scope(ScopeKind::Type);
            let generics = self.collect_generic_parameters(generic_parameters)?;
            self.symbol_table.exit_scope();

            (Some(scope_id), generics)
        } else {
            (None, vec![])
        };

        self.symbol_collector_check_node(value)?;

        let type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::TypeAlias((scope_id, None)),
            generics,
            QualifierKind::Public,
            Some(span),
        )?;
        Ok((None, Some(Type::new_base(type_id))))
    }

    fn collect_optional_node(&mut self, node: &mut Option<BoxedAstNode>) -> Result<(), BoxedError> {
        if let Some(n) = node {
            self.symbol_collector_check_node(n)?;
        }
        Ok(())
    }
}

impl SemanticAnalyzer {
    pub fn generic_constraints_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.generic_constraints_check_node(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn generic_constraints_check_node(&mut self, statement: &mut AstNode) -> Result<(), BoxedError> {
        match &statement.kind {
            AstNodeKind::GenericParameter { .. } => self.collect_generic_constraint(statement),
            _ => {
                for node in statement.children_mut() {
                    self.generic_constraints_check_node(node)?;
                }

                Ok(())
            }
        }
    }

    fn collect_generic_constraint(&mut self, node: &mut AstNode) -> Result<(), BoxedError> {
        node.scope_id = Some(self.symbol_table.get_current_scope_id());

        if node.type_id.is_none() {
            return Ok(());
        }

        let AstNodeKind::GenericParameter { constraints, .. } = &mut node.kind else {
            unreachable!();
        };
        let mut trait_ids = vec![];

        for constraint in constraints.iter() {
            let type_symbol = self.symbol_table.find_type_symbol(constraint).ok_or_else(|| {
                self.create_error(
                    ErrorKind::UnknownIdentifier(constraint.clone()),
                    node.span,
                    &[node.span],
                )
            })?;

            if !matches!(type_symbol.kind, TypeSymbolKind::Trait(_)) {
                return Err(self.create_error(
                    ErrorKind::InvalidConstraint(constraint.clone()),
                    node.span,
                    &[node.span],
                ));
            }

            trait_ids.push(type_symbol.id);
        }

        let type_symbol = self
            .symbol_table
            .get_type_symbol_mut(node.type_id.as_ref().unwrap().get_base_symbol())
            .unwrap();
        if let TypeSymbolKind::Generic(constraints) = &mut type_symbol.kind {
            *constraints = trait_ids;
        }

        Ok(())
    }
}

impl SemanticAnalyzer {
    pub fn struct_field_type_collector_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.struct_field_type_collector_check_node(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn struct_field_type_collector_check_node(&mut self, statement: &mut AstNode) -> Result<(), BoxedError> {
        match &mut statement.kind {
            AstNodeKind::StructDeclaration { fields, .. } => self.struct_field_type_collector_handle_fields(fields),
            _ => {
                for node in statement.children_mut() {
                    self.struct_field_type_collector_check_node(node)?;
                }

                Ok(())
            }
        }
    }

    fn struct_field_type_collector_handle_fields(&mut self, fields: &mut [AstNode]) -> Result<(), BoxedError> {
        for field_node in fields.iter_mut() {
            let AstNodeKind::StructField { type_annotation, .. } = &mut field_node.kind else {
                continue;
            };

            let resolved_type = self.get_type_from_ast(type_annotation)?;

            let field_symbol = self
                .symbol_table
                .get_value_symbol_mut(field_node.value_id.unwrap())
                .unwrap();

            field_symbol.type_id = Some(resolved_type.clone());
            field_node.type_id = Some(resolved_type);
        }

        Ok(())
    }

    fn get_type_from_ast(&mut self, node: &mut AstNode) -> Result<Type, BoxedError> {
        match &mut node.kind {
            AstNodeKind::TypeReference {
                type_name,
                generic_types,
                reference_kind,
            } => {
                let args = generic_types
                    .iter_mut()
                    .map(|arg_node| self.get_type_from_ast(arg_node))
                    .collect::<Result<Vec<_>, _>>()?;

                let base_symbol = self
                    .symbol_table
                    .find_type_symbol_from_scope(node.scope_id.unwrap(), type_name)
                    .ok_or_else(|| {
                        self.create_error(
                            ErrorKind::UnknownIdentifier(type_name.clone()),
                            node.span,
                            &[node.span],
                        )
                    })?;

                let base_type = Type::Base {
                    symbol: base_symbol.id,
                    args,
                };

                Ok(match reference_kind {
                    ReferenceKind::Value => base_type,
                    ReferenceKind::Reference => Type::Reference(Box::new(base_type)),
                    ReferenceKind::MutableReference => Type::MutableReference(Box::new(base_type)),
                })
            },
            AstNodeKind::FunctionPointer { params, return_type } => {
                let param_types = params
                    .iter_mut()
                    .map(|p| self.get_type_from_ast(p))
                    .collect::<Result<Vec<_>, _>>()?;

                let return_type_val = if let Some(rt_node) = return_type {
                    self.get_type_from_ast(rt_node)?
                } else {
                    Type::new_base(self.builtin_types[PrimitiveKind::Void as usize])
                };

                let fn_ptr_id = self.symbol_table.add_type_symbol(
                    &format!("#fn_ptr_{:?}", node.span.start),
                    TypeSymbolKind::FunctionSignature {
                        params: param_types,
                        return_type: return_type_val,
                        instance: None,
                    },
                    vec![],
                    QualifierKind::Private,
                    Some(node.span),
                )?;

                Ok(Type::new_base(fn_ptr_id))
            },
            _ => Err(self.create_error(ErrorKind::ExpectedType, node.span, &[node.span])),
        }
    }
}

impl SemanticAnalyzer {
    pub fn impl_collector_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.impl_collector_check_node(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn impl_collector_check_node(&mut self, statement: &mut AstNode) -> Result<(), BoxedError> {
        match &statement.kind {
            AstNodeKind::ImplDeclaration { .. } => self.collect_and_register_impl_block(statement),
            _ => {
                for node in statement.children_mut() {
                    self.impl_collector_check_node(node)?;
                }

                Ok(())
            }
        }
    }

    fn collect_and_register_impl_block(&mut self, node: &mut AstNode) -> Result<(), BoxedError> {
        let (
            associated_constants,
            associated_types,
            associated_functions,
            impl_generics,
            type_reference,
            trait_node,
        ) = match &mut node.kind {
            AstNodeKind::ImplDeclaration {
                associated_constants,
                associated_types,
                associated_functions,
                generic_parameters,
                type_reference,
                trait_node,
            } => (
                associated_constants,
                associated_types,
                associated_functions,
                generic_parameters,
                type_reference,
                trait_node,
            ),
            _ => return Ok(()),
        };

        let impl_scope_id = self.symbol_table.enter_scope(ScopeKind::Impl);
        let impl_generic_param_ids = self.collect_generic_parameters(impl_generics)?;
        for generic in impl_generics.iter_mut() {
            self.collect_generic_constraint(generic)?;
        }

        node.scope_id = Some(impl_scope_id);
        type_reference.scope_id = Some(impl_scope_id);

        if let Some(trait_node) = trait_node {
            trait_node.scope_id = Some(impl_scope_id);

            let (trait_id, trait_generic_specialization) = self.resolve_type_ref_from_ast(trait_node)?;
            self.symbol_table.get_scope_mut(impl_scope_id).unwrap().trait_id = Some(trait_id);

            let (implementing_type_id, type_specialization) = self.resolve_type_ref_from_ast(type_reference)?;
            let self_type = Type::Base {
                symbol: implementing_type_id,
                args: type_specialization.iter().map(|id| Type::new_base(*id)).collect()
            };

            self.symbol_table.add_type_symbol(
                "Self",
                TypeSymbolKind::TypeAlias((None, Some(self_type))),
                vec![],
                QualifierKind::Public,
                None,
            )?;

            self.collect_impl_body_symbols(associated_constants, associated_types, associated_functions)?;

            let trait_impl = TraitImpl {
                impl_scope_id,
                impl_generic_params: impl_generic_param_ids,
                trait_generic_specialization,
                type_specialization,
            };

            self.trait_registry
                .register(trait_id, implementing_type_id, trait_impl);
        } else {
            let (base_type_id, specialization) = self.resolve_type_ref_from_ast(type_reference)?;

            let base_type_symbol = self.symbol_table.get_type_symbol(base_type_id).unwrap();
            let self_type = Type::Base {
                symbol: base_type_symbol.id,
                args: specialization.iter().map(|id| Type::new_base(*id)).collect()
            };

            self.symbol_table.add_type_symbol(
                "Self",
                TypeSymbolKind::TypeAlias((None, Some(self_type))),
                vec![],
                QualifierKind::Public,
                None,
            )?;

            self.collect_impl_body_symbols(associated_constants, associated_types, associated_functions)?;

            let impl_block = InherentImpl {
                scope_id: impl_scope_id,
                specialization,
                generic_params: impl_generic_param_ids,
                span: node.span,
            };

            let invalid_impl_error = self.create_error(
                ErrorKind::InvalidImpl(Some(
                    self.symbol_table
                        .get_type_name(self.symbol_table.get_type_symbol(base_type_id).unwrap().name_id)
                        .to_string(),
                )),
                type_reference.span,
                &[type_reference.span],
            );
            let base_type_symbol_mut = self.symbol_table.get_type_symbol_mut(base_type_id).unwrap();

            match &mut base_type_symbol_mut.kind {
                TypeSymbolKind::Struct((_, impls)) | TypeSymbolKind::Enum((_, impls)) => {
                    impls.push(impl_block);
                }
                _ => return Err(invalid_impl_error),
            }
        }

        self.symbol_table.exit_scope();
        Ok(())
    }

    fn collect_impl_body_symbols(
        &mut self,
        associated_constants: &mut [AstNode],
        associated_types: &mut [AstNode],
        associated_functions: &mut [AstNode],
    ) -> Result<(), BoxedError> {
        for func_node in associated_functions {
            if let AstNodeKind::Function {
                qualifier,
                name,
                generic_parameters,
                parameters,
                body,
                instance,
                return_type
            } = &mut func_node.kind
            {
                let func_scope_id = self.symbol_table.enter_scope(ScopeKind::Function);
                func_node.scope_id = Some(func_scope_id);

                let scope = self.symbol_table.get_scope_mut(func_scope_id).unwrap();
                scope.receiver_kind = *instance;

                self.collect_generic_parameters(generic_parameters)?;
                for generic in generic_parameters.iter_mut() {
                    self.collect_generic_constraint(generic)?;
                }

                self.collect_function_parameters(parameters)?;
                self.symbol_collector_check_node(body.as_mut().unwrap())?;
                self.collect_optional_node(return_type)?;
                self.symbol_table.exit_scope();

                func_node.value_id = Some(self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Function(func_scope_id),
                    false,
                    qualifier.unwrap(),
                    None,
                    Some(func_node.span),
                )?);
            }
        }

        for const_node in associated_constants {
            const_node.scope_id = Some(self.symbol_table.get_current_scope_id());

            if let AstNodeKind::AssociatedConstant { qualifier, name, type_annotation, initializer } = &mut const_node.kind {
                let const_id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Variable,
                    false,
                    *qualifier,
                    None,
                    Some(const_node.span),
                )?;
                const_node.value_id = Some(const_id);

                self.collect_optional_node(type_annotation)?;
                self.symbol_collector_check_node(initializer)?;
            }
        }

        for type_node in associated_types {
            type_node.scope_id = Some(self.symbol_table.get_current_scope_id());

            if let AstNodeKind::AssociatedType { name, qualifier, value } = &mut type_node.kind {
                let type_id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    *qualifier,
                    Some(type_node.span),
                )?;
                type_node.type_id = Some(Type::new_base(type_id));

                self.symbol_collector_check_node(value)?;
            }
        }

        Ok(())
    }

    fn find_type_by_name(&self, node: &AstNode) -> Result<TypeSymbolId, BoxedError> {
        let name = node
            .get_name()
            .ok_or_else(|| self.create_error(ErrorKind::ExpectedType, node.span, &[node.span]))?;

        let type_symbol = self.symbol_table.find_type_symbol(&name).ok_or_else(|| {
            self.create_error(
                ErrorKind::UnknownIdentifier(name.clone()),
                node.span,
                &[node.span],
            )
        })?;

        Ok(type_symbol.id)
    }

    fn resolve_type_ref_from_ast(
        &self,
        node: &mut AstNode,
    ) -> Result<(TypeSymbolId, Vec<TypeSymbolId>), BoxedError> {
        node.scope_id = Some(self.symbol_table.get_current_scope_id());

        let (name, arg_nodes) = match &mut node.kind {
            AstNodeKind::TypeReference {
                type_name,
                generic_types,
                ..
            } => (type_name, generic_types),
            _ => return Err(self.create_error(ErrorKind::ExpectedType, node.span, &[node.span])),
        };

        let base_type_id = self
            .symbol_table
            .find_type_symbol(name)
            .ok_or_else(|| {
                self.create_error(
                    ErrorKind::UnknownIdentifier(name.clone()),
                    node.span,
                    &[node.span],
                )
            })?
            .id;

        let mut arg_ids = vec![];
        for arg_node in arg_nodes {
            let arg_id = self.resolve_type_ref_from_ast(arg_node)?.0;
            arg_ids.push(arg_id);
        }

        Ok((base_type_id, arg_ids))
    }
}


// frontend/semantics/uv_collector.rs
use std::collections::HashSet;

use indexmap::IndexMap;

use crate::{
    boxed,
    frontend::syntax::ast::{AstNode, AstNodeKind, BoxedAstNode},
    frontend::semantics::analyzer::{
        Constraint, ConstraintInfo, PrimitiveKind, ScopeId, ScopeKind, SemanticAnalyzer, Type, TypeSymbolId,
        TypeSymbolKind, ValueSymbolKind,
    },
    utils::{
        error::{BoxedError, Error, ErrorKind},
        kind::{Operation, QualifierKind, ReferenceKind, Span},
    },
};

impl SemanticAnalyzer {
    fn get_primitive_type(&self, primitive: PrimitiveKind) -> TypeSymbolId {
        self.builtin_types[primitive as usize]
    }

    fn get_type_of_identifier(&self, scope_id: ScopeId, name: &str, span: Span) -> Result<Type, BoxedError> {
        match self.symbol_table.find_value_symbol_from_scope(scope_id, name) {
            Some(value_symbol) => match value_symbol.type_id.clone() {
                Some(type_id) => Ok(type_id),
                None => Err(self.create_error(ErrorKind::UnresolvedType(name.to_string()), span, &[span])),
            },
            None => Err(self.create_error(ErrorKind::UnknownIdentifier(name.to_string()), span, &[span])),
        }
    }

    fn get_type_from_type_name(&self, scope_id: ScopeId, name: &str, span: Span) -> Result<Type, BoxedError> {
        let type_symbol = self
            .symbol_table
            .find_type_symbol_from_scope(scope_id, name)
            .ok_or_else(|| self.create_error(ErrorKind::UnknownIdentifier(name.to_string()), span, &[span]))?;

        if let TypeSymbolKind::TypeAlias((_, Some(ty))) = &type_symbol.kind {
            return Ok(ty.clone());
        }

        Ok(Type::new_base(type_symbol.id))
    }

    fn collect_uv_unary_operation(
        &mut self,
        uv_id: TypeSymbolId,
        operator: &mut Operation,
        operand: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let uv_type = self.collect_uvs(operand)?;
        let result_uv = Type::new_base(uv_id);

        match operator.to_trait_data() {
            Some((trait_name, _)) => {
                self.unification_context.register_constraint(
                    Constraint::Operation(
                        result_uv,
                        Type::new_base(self.trait_registry.get_default_trait(&trait_name)),
                        uv_type,
                        None,
                        *operator
                    ),
                    info,
                );
            }
            None => match operator {
                Operation::Dereference => self.unification_context.register_constraint(
                    Constraint::Equality(uv_type, Type::Reference(Box::new(result_uv))),
                    info,
                ),
                Operation::ImmutableAddressOf => self.unification_context.register_constraint(
                    Constraint::Equality(result_uv, Type::Reference(boxed!(uv_type))),
                    info,
                ),
                Operation::MutableAddressOf => self.unification_context.register_constraint(
                    Constraint::Equality(result_uv, Type::MutableReference(boxed!(uv_type))),
                    info,
                ),
                _ => unreachable!(),
            },
        }

        Ok(())
    }

    fn collect_uv_binary_operation(
        &mut self,
        uv_id: TypeSymbolId,
        left: &mut BoxedAstNode,
        right: &mut BoxedAstNode,
        operator: &mut Operation,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let left_type = self.collect_uvs(left)?;
        let right_type = self.collect_uvs(right)?;
        let result_uv = Type::new_base(uv_id);

        match operator.to_trait_data() {
            Some((trait_name, _)) => {
                self.unification_context.register_constraint(
                    Constraint::Operation(
                        result_uv,
                        Type::Base {
                            symbol: self.trait_registry.get_default_trait(&trait_name),
                            args: vec![right_type.clone()],
                        },
                        left_type,
                        Some(right_type),
                        *operator
                    ),
                    info,
                );
            }
            None => match operator {
                Operation::Assign => {
                    self.unification_context.register_constraint(Constraint::Equality(left_type, right_type), info);
                    self.unification_context.register_constraint(
                        Constraint::Equality(
                            result_uv,
                            Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                        ),
                        info,
                    );
                }
                _ => unreachable!(),
            },
        }

        Ok(())
    }

    fn collect_uv_type_cast(
        &mut self,
        uv_id: TypeSymbolId,
        expression: &mut BoxedAstNode,
        target_type_node: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let source_type = self.collect_uvs(expression)?;
        let target_type = self.collect_uvs(target_type_node)?;

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), target_type.clone()),
            info,
        );

        self.unification_context.register_constraint(
            Constraint::Cast(source_type, target_type),
            info,
        );

        Ok(())
    }

    fn collect_uv_conditional_operation(
        &mut self,
        uv_id: TypeSymbolId,
        left: &mut BoxedAstNode,
        right: &mut BoxedAstNode,
        operator: &mut Operation,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let left_type = self.collect_uvs(left)?;
        let right_type = self.collect_uvs(right)?;
        let result_uv = Type::new_base(uv_id);

        match *operator {
            Operation::And | Operation::Or => {
                let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));

                self.unification_context.register_constraint(Constraint::Equality(left_type, bool_type.clone()), info);
                self.unification_context.register_constraint(Constraint::Equality(right_type, bool_type.clone()), info);

                self.unification_context.register_constraint(Constraint::Equality(result_uv, bool_type), info);
            }
            _ => {
                let (trait_name, _) = operator.to_trait_data().unwrap();

                self.unification_context.register_constraint(
                    Constraint::Operation(
                        result_uv,
                        Type::Base {
                            symbol: self.trait_registry.get_default_trait(&trait_name),
                            args: vec![right_type.clone()],
                        },
                        left_type,
                        Some(right_type),
                        *operator,
                    ),
                    info,
                );
            }
        }

        Ok(())
    }

    fn collect_uv_variable_declaration(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let AstNodeKind::VariableDeclaration {
            type_annotation,
            initializer,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let init_type = if let Some(init) = initializer {
            Some(self.collect_uvs(init)?)
        } else {
            None
        };

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        if let Some(annot) = type_annotation {
            let annot_type = self.collect_uvs(annot)?;

            if let Some(init_type) = init_type {
                self.unification_context
                    .register_constraint(Constraint::Equality(annot_type.clone(), init_type), info);
            }

            self.unification_context
                .register_constraint(Constraint::Equality(symbol_uv.clone(), annot_type), info);
        } else if let Some(init_type) = init_type {
            self.unification_context
                .register_constraint(Constraint::Equality(symbol_uv.clone(), init_type), info);
        } else {
            return Err(self.create_error(ErrorKind::BadVariableDeclaration, span, &[span]));
        }

        self.symbol_table
            .get_value_symbol_mut(node.value_id.unwrap())
            .unwrap()
            .type_id = Some(symbol_uv.clone());

        Ok(())
    }

    fn collect_uv_block(
        &mut self,
        uv_id: TypeSymbolId,
        statements: &mut [AstNode],
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let mut last_type = None;

        for stmt in statements.iter_mut() {
            last_type = Some(self.collect_uvs(stmt)?);
        }

        if let Some(last_type) = last_type {
            self.unification_context.register_constraint(
                Constraint::Equality(Type::new_base(uv_id), last_type),
                info,
            );
        } else {
            self.unification_context.register_constraint(
                Constraint::Equality(
                    Type::new_base(uv_id),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                ),
                info,
            );
        }

        Ok(())
    }

    fn collect_uv_if_statement(
        &mut self,
        uv_id: TypeSymbolId,
        condition: &mut BoxedAstNode,
        then_branch: &mut BoxedAstNode,
        else_if_branches: &mut [(BoxedAstNode, BoxedAstNode)],
        else_branch: &mut Option<BoxedAstNode>,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let cond_type = self.collect_uvs(condition)?;
        let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));
        self.unification_context
            .register_constraint(Constraint::Equality(cond_type, bool_type.clone()), info);

        let result_uv = Type::new_base(uv_id);

        let then_type = self.collect_uvs(then_branch)?;

        for (elif_cond, elif_branch) in else_if_branches.iter_mut() {
            let elif_cond_type = self.collect_uvs(elif_cond)?;
            self.unification_context
                .register_constraint(Constraint::Equality(elif_cond_type, bool_type.clone()), info);

            let elif_type = self.collect_uvs(elif_branch)?;
            self.unification_context.register_constraint(
                Constraint::Equality(then_type.clone(), elif_type),
                info,
            );
        }

        if let Some(else_node) = else_branch {
            let else_type = self.collect_uvs(else_node)?;
            self.unification_context.register_constraint(
                Constraint::Equality(then_type.clone(), else_type),
                info,
            );

            self.unification_context.register_constraint(
                Constraint::Equality(result_uv, then_type),
                info,
            );
        } else {
            let void_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Void));
            self.unification_context.register_constraint(
                Constraint::Equality(result_uv, void_type),
                info,
            );
        }

        Ok(())
    }

    fn collect_uv_while_loop(
        &mut self,
        uv_id: TypeSymbolId,
        condition: &mut BoxedAstNode,
        body: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.uv_collection_ctx.in_loop = true;

        let cond_type = self.collect_uvs(condition)?;
        let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));
        self.unification_context
            .register_constraint(Constraint::Equality(cond_type, bool_type), info);

        self.collect_uvs(body)?;

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        self.uv_collection_ctx.in_loop = false;

        Ok(())
    }

    fn collect_uv_for_loop(
        &mut self,
        uv_id: TypeSymbolId,
        initializer: &mut Option<BoxedAstNode>,
        condition: &mut Option<BoxedAstNode>,
        increment: &mut Option<BoxedAstNode>,
        body: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.uv_collection_ctx.in_loop = true;

        if let Some(init) = initializer {
            self.collect_uvs(init)?;
        }

        if let Some(cond) = condition {
            let cond_type = self.collect_uvs(cond)?;
            let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));
            self.unification_context
                .register_constraint(Constraint::Equality(cond_type, bool_type), info);
        }

        if let Some(inc) = increment {
            self.collect_uvs(inc)?;
        }

        self.collect_uvs(body)?;

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        self.uv_collection_ctx.in_loop = false;

        Ok(())
    }

    fn collect_uv_return(
        &mut self,
        uv_id: TypeSymbolId,
        opt_expr: &mut Option<BoxedAstNode>,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Never)),
            ),
            info,
        );

        let Some(expected_return_type) = self.uv_collection_ctx.current_return_type.clone() else {
             return Err(self.create_error(ErrorKind::InvalidReturn, info.span, &[info.span]));
        };

        let value_type = if let Some(expr) = opt_expr {
            self.collect_uvs(expr)?
        } else {
            Type::new_base(self.get_primitive_type(PrimitiveKind::Void))
        };
        
        self.unification_context.register_constraint(
            Constraint::Equality(expected_return_type, value_type),
            info,
        );

        Ok(())
    }

    fn collect_uv_function(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let AstNodeKind::Function {
            name,
            generic_parameters,
            parameters,
            return_type,
            instance,
            body,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        let is_declaration = !name.is_empty();

        let symbol_uv_opt = if is_declaration {
            let uv = self
                .unification_context
                .generate_uv_type(&mut self.symbol_table, span);

            self.symbol_table
                .get_value_symbol_mut(node.value_id.unwrap())
                .unwrap()
                .type_id = Some(uv.clone());

            Some(uv)
        } else {
            None
        };

        let generic_types: Vec<TypeSymbolId> = generic_parameters
            .iter_mut()
            .map(|p| self.collect_uvs(p).map(|t| t.get_base_symbol()))
            .collect::<Result<_, _>>()?;

        for param_node in parameters.iter_mut() {
            self.collect_uvs(param_node)?;
        }

        let param_types: Vec<Type> = parameters
            .iter()
            .map(|p| {
                self.symbol_table
                    .get_value_symbol(p.value_id.unwrap())
                    .unwrap()
                    .type_id
                    .clone()
                    .unwrap()
            })
            .collect();

        let return_type_val = if let Some(rt_node) = return_type {
            self.collect_uvs(rt_node)?
        } else {
            Type::new_base(self.get_primitive_type(PrimitiveKind::Void))
        };

        let old_return_type = self.uv_collection_ctx.current_return_type.clone();
        self.uv_collection_ctx.current_return_type = Some(return_type_val.clone());

        if let Some(body_node) = body {
            let body_type = self.collect_uvs(body_node)?;

            let span = if let AstNodeKind::Block(stmts) = &body_node.kind {
                stmts.last().map_or(body_node.span, |s| s.span)
            } else {
                body_node.span
            };

            self.unification_context.register_constraint(
                Constraint::Equality(body_type, return_type_val.clone()),
                ConstraintInfo {
                    span,
                    scope_id: body_node.scope_id.unwrap(),
                },
            );
        }

        self.uv_collection_ctx.current_return_type = old_return_type;

        let fn_sig_type_id = self.symbol_table.add_type_symbol(
            &format!("#fn_sig_{}", uv_id),
            TypeSymbolKind::FunctionSignature {
                params: param_types,
                return_type: return_type_val,
                instance: *instance,
            },
            generic_types,
            QualifierKind::Private,
            Some(span),
        )?;

        let fn_sig_type = Type::new_base(fn_sig_type_id);

        if is_declaration {
            self.unification_context.register_constraint(
                Constraint::Equality(
                    Type::new_base(uv_id),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                ),
                info,
            );

            self.unification_context
                .register_constraint(Constraint::Equality(symbol_uv_opt.unwrap(), fn_sig_type), info);
        } else {
            self.unification_context
                .register_constraint(Constraint::Equality(Type::new_base(uv_id), fn_sig_type), info);
        }

        Ok(())
    }

    fn collect_uv_function_parameter(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let AstNodeKind::FunctionParameter {
            type_annotation,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let annotation_type = self.collect_uvs(type_annotation)?;

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        self.unification_context
            .register_constraint(Constraint::Equality(symbol_uv.clone(), annotation_type), info);

        self.symbol_table
            .get_value_symbol_mut(node.value_id.unwrap())
            .unwrap()
            .type_id = Some(symbol_uv);

        Ok(())
    }

    fn collect_uv_function_pointer(
        &mut self,
        uv_id: TypeSymbolId,
        params: &mut [AstNode],
        return_type_node: &mut Option<BoxedAstNode>,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let param_types: Vec<Type> = params
            .iter_mut()
            .map(|p| self.collect_uvs(p))
            .collect::<Result<_, _>>()?;

        let return_type = if let Some(rt_node) = return_type_node {
            self.collect_uvs(rt_node)?
        } else {
            Type::new_base(self.get_primitive_type(PrimitiveKind::Void))
        };

        let fn_ptr_sig_id = self.symbol_table.add_type_symbol(
            &format!("#fn_ptr_sig_{}", uv_id),
            TypeSymbolKind::FunctionSignature {
                params: param_types,
                return_type,
                instance: None,
            },
            vec![],
            QualifierKind::Private,
            Some(span),
        )?;

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), Type::new_base(fn_ptr_sig_id)),
            info,
        );

        Ok(())
    }

    fn collect_uv_struct_literal(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        name: &str,
        fields: &mut IndexMap<String, AstNode>,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let Some(symbol) = self.symbol_table.find_type_symbol_from_scope(scope_id, name) else {
            return Err(self.create_error(ErrorKind::UnknownIdentifier(name.to_owned()), span, &[span]));
        };

        let struct_scope_id = {
            if let TypeSymbolKind::Struct((struct_scope_id, _)) = &symbol.kind { *struct_scope_id } else { unreachable!() }
        };

        let literal_field_names: HashSet<String> = fields.keys().cloned().collect();
        let declared_field_names: HashSet<String> = self.symbol_table.get_scope(struct_scope_id).unwrap()
            .values.values()
            .map(|id| self.symbol_table.get_value_name(self.symbol_table.get_value_symbol(*id).unwrap().name_id).to_string())
            .collect();
        
        let missing_fields: Vec<String> = declared_field_names
            .difference(&literal_field_names)
            .cloned().collect();

        let extra_fields: Vec<String> = literal_field_names
            .difference(&declared_field_names)
            .cloned().collect();

        if !missing_fields.is_empty() || !extra_fields.is_empty() {
            return Err(self.create_error(
                ErrorKind::MismatchedStructFields {
                    struct_name: name.to_string(),
                    missing_fields,
                    extra_fields,
                },
                span,
                &[span],
            ));
        }

        let symbol_id = symbol.id;
        let generic_params = symbol.generic_parameters.clone();

        let generic_uvs: IndexMap<TypeSymbolId, Type> = generic_params
            .iter()
            .map(|&param_id| {
                let uv_type = self.unification_context.generate_uv_type(&mut self.symbol_table, span);
                (param_id, uv_type)
            })
            .collect();

        let struct_type = Type::Base {
            symbol: symbol_id,
            args: generic_uvs.values().cloned().collect()
        };

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), struct_type),
            info,
        );

        for (field_name, field_expr) in fields.iter_mut() {
            let expr_uv = self.collect_uvs(field_expr)?;

            let field_type = self.symbol_table
                .find_value_symbol_in_scope(field_name, struct_scope_id)
                .ok_or_else(|| self.create_error(
                    ErrorKind::InvalidField(name.to_string(), field_name.to_string()), 
                    field_expr.span,
                    &[field_expr.span, span]
                ))?
                .type_id.clone().unwrap();
            
            if let Some(ty) = generic_uvs.get(&field_type.get_base_symbol()) {
                self.unification_context.register_constraint(
                    Constraint::Equality(expr_uv, ty.clone()),
                    info
                );
            } else {
                self.unification_context.register_constraint(
                    Constraint::Equality(expr_uv, field_type),
                    info
                );
            }
        }

        Ok(())
    }

    fn collect_uv_associated_const(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let AstNodeKind::AssociatedConstant {
            type_annotation,
            initializer,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        let init_type = self.collect_uvs(initializer)?;

        if let Some(annot) = type_annotation {
            let annot_type = self.collect_uvs(annot)?;

            self.unification_context
                .register_constraint(Constraint::Equality(annot_type, init_type.clone()), info);
        }

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        self.unification_context
            .register_constraint(Constraint::Equality(symbol_uv.clone(), init_type), info);

        self.symbol_table
            .get_value_symbol_mut(node.value_id.unwrap())
            .unwrap()
            .type_id = Some(symbol_uv.clone());

        Ok(())
    }

    fn collect_uv_trait_const(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );
        
        let AstNodeKind::TraitConstant {
            type_annotation,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        let annot_type = self.collect_uvs(type_annotation)?;

        let symbol_uv = self.unification_context.generate_uv_type(&mut self.symbol_table, span);
        self.unification_context.register_constraint(Constraint::Equality(symbol_uv.clone(), annot_type), info);
        self.symbol_table.get_value_symbol_mut(node.value_id.unwrap()).unwrap().type_id = Some(symbol_uv.clone());

        Ok(())
    }

    fn collect_uv_type_reference(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        type_name: &str,
        generic_types: &mut [AstNode],
        reference_kind: &mut ReferenceKind,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let symbol = self.symbol_table.find_type_symbol_from_scope(scope_id, type_name)
            .ok_or_else(|| {
                self.create_error(ErrorKind::UnknownIdentifier(type_name.to_owned()), span, &[span])
            })?.id;

        let symbol_params = &self.symbol_table.get_type_symbol(symbol).unwrap().generic_parameters;
        
        if symbol_params.len() != generic_types.len() {
            return Err(self.create_error(
                ErrorKind::InvalidTypeReference(type_name.to_string(), generic_types.len(), symbol_params.len()),
                span,
                &[span]
            ))
        }

        let args: Vec<Type> = generic_types
            .iter_mut()
            .map(|generic_type| self.collect_uvs(generic_type))
            .collect::<Result<Vec<_>, _>>()?;

        let base_symbol = Type::Base { symbol, args };

        let constraint = match reference_kind {
            ReferenceKind::Value => base_symbol,
            ReferenceKind::Reference => Type::Reference(boxed!(base_symbol)),
            ReferenceKind::MutableReference => Type::MutableReference(boxed!(base_symbol)),
        };

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), constraint),
            info,
        );

        Ok(())
    }

    fn collect_uv_type_declaration(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let value_node = if let AstNodeKind::AssociatedType { value, .. } = &mut node.kind {
            value
        } else if let AstNodeKind::TypeDeclaration { value, .. } = &mut node.kind {
            value
        } else {
            unreachable!();
        };
 
        // Ensure RHS is not an enum variant.
        if let AstNodeKind::FieldAccess { left, right } = &value_node.kind
            && let Some(left_name) = left.get_name()
            && let Some(symbol) = self.symbol_table.find_type_symbol_from_scope(node.scope_id.unwrap(), &left_name)
            && let TypeSymbolKind::Enum((scope_id, _)) = symbol.kind
            && let Some(right_name) = right.get_name()
            && let Some(variant_symbol) = self.symbol_table.find_value_symbol_in_scope(&right_name, scope_id)
            && matches!(variant_symbol.kind, ValueSymbolKind::EnumVariant)
        {
            return Err(self.create_error(ErrorKind::ExpectedType, value_node.span, &[value_node.span]));
        }
         
        let initializer_type = self.collect_uvs(value_node)?;

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        self.unification_context
            .register_constraint(Constraint::Equality(symbol_uv.clone(), initializer_type), info);

        let type_symbol = self
            .symbol_table
            .get_type_symbol_mut(node.type_id.as_mut().unwrap().get_base_symbol())
            .unwrap();

        let TypeSymbolKind::TypeAlias((_, alias)) = &mut type_symbol.kind else {
            unreachable!();
        };
        *alias = Some(symbol_uv);

        Ok(())
    }

    fn collect_uv_self_value(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let mut function_scope = self.symbol_table.get_scope(scope_id).unwrap();
        while function_scope.kind != ScopeKind::Function {
            match function_scope.parent {
                Some(parent_id) => function_scope = self.symbol_table.get_scope(parent_id).unwrap(),
                None => {
                    return Err(self.create_error(
                        ErrorKind::InvalidThis("outside of a function"),
                        span,
                        &[span],
                    ))
                }
            }
        }

        let receiver_kind = match function_scope.receiver_kind {
            Some(kind) => kind,
            None => {
                return Err(self.create_error(
                    ErrorKind::InvalidThis("in a static method without a 'this' parameter"),
                    span,
                    &[span],
                ))
            }
        };

        let impl_scope = match function_scope.parent {
            Some(parent_id) => self.symbol_table.get_scope(parent_id).unwrap(),
            None => {
                return Err(self.create_error(
                    ErrorKind::InvalidThis("outside of an impl block"),
                    span,
                    &[span],
                ))
            }
        };

        if impl_scope.kind != ScopeKind::Impl {
            return Err(self.create_error(ErrorKind::InvalidThis("outside of an impl block"), span, &[span]));
        }

        let TypeSymbolKind::TypeAlias((_, Some(self_type))) = &self
            .symbol_table
            .find_type_symbol_in_scope("Self", impl_scope.id)
            .ok_or_else(|| self.create_error(ErrorKind::SelfOutsideImpl, span, &[span]))?
            .kind
        else {
            unreachable!();
        };

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                match receiver_kind {
                    ReferenceKind::Value => self_type.clone(),
                    ReferenceKind::Reference => Type::Reference(Box::new(self_type.clone())),
                    ReferenceKind::MutableReference => Type::MutableReference(Box::new(self_type.clone())),
                },
            ),
            info,
        );

        Ok(())
    }

    fn collect_uv_self_type(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        reference_kind: ReferenceKind,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let self_symbol = self
            .symbol_table
            .find_type_symbol_from_scope(scope_id, "Self")
            .ok_or_else(|| self.create_error(ErrorKind::SelfOutsideImpl, span, &[span]))?;

        let base_type = Type::new_base(self_symbol.id);

        let final_type = match reference_kind {
            ReferenceKind::Value => base_type,
            ReferenceKind::Reference => Type::Reference(Box::new(base_type)),
            ReferenceKind::MutableReference => Type::MutableReference(Box::new(base_type)),
        };

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), final_type),
            info,
        );

        Ok(())
    }

    fn collect_uv_field_access(
        &mut self,
        uv_id: TypeSymbolId,
        left: &mut BoxedAstNode,
        right: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let right_name = right
            .get_name()
            .ok_or_else(|| self.create_error(ErrorKind::ExpectedIdentifier, right.span, &[right.span]))?;

        match &mut left.kind {
            AstNodeKind::PathQualifier { ty, tr } => {
                let type_val = self.collect_uvs(ty)?;
                let trait_val = if let Some(trait_node) = tr {
                    Some(self.collect_uvs(trait_node)?)
                } else {
                    None
                };
                
                self.unification_context.register_constraint(Constraint::FullyQualifiedAccess(
                    Type::new_base(uv_id),
                    type_val,
                    trait_val,
                    right_name,
                ), info);
                
                return Ok(());
            },
            AstNodeKind::Identifier(left_name) => {
                if left_name == "Self" {
                    let mut scope_id = Some(info.scope_id);

                    while let Some(id) = scope_id {
                        let scope = self.symbol_table.get_scope(id).unwrap();
                        if scope.kind == ScopeKind::Impl {
                            if let Some(trait_id) = scope.trait_id {
                                let self_type = self.get_type_from_type_name(info.scope_id, "Self", left.span)?;
                                let trait_type = Type::new_base(trait_id);

                                self.unification_context.register_constraint(
                                    Constraint::FullyQualifiedAccess(
                                        Type::new_base(uv_id),
                                        self_type,
                                        Some(trait_type),
                                        right_name,
                                    ),
                                    info,
                                );

                                return Ok(());
                            }

                            break;
                        }

                        scope_id = scope.parent;
                    }
                }

                if self.symbol_table.find_value_symbol_from_scope(left.scope_id.unwrap(), left_name).is_some() {
                    let left_type = self.collect_uvs(left)?;
                    
                    self.unification_context.register_constraint(
                        Constraint::InstanceMemberAccess(Type::new_base(uv_id), left_type, right_name),
                        info,
                    );

                    return Ok(());
                }

                if let Some(type_symbol) = self.symbol_table.find_type_symbol_from_scope(left.scope_id.unwrap(), left_name) {
                    let static_type = Type::new_base(type_symbol.id);
                    left.type_id = Some(static_type.clone());

                    self.unification_context.register_constraint(
                        Constraint::StaticMemberAccess(Type::new_base(uv_id), static_type, right_name),
                        info,
                    );

                    return Ok(());
                }
            },
            _ => {}
        }

        let left_type = self.collect_uvs(left)?;

        self.unification_context.register_constraint(
            Constraint::InstanceMemberAccess(Type::new_base(uv_id), left_type, right_name),
            info,
        );

        Ok(())
    }

    fn collect_uv_function_call(
        &mut self,
        uv_id: TypeSymbolId,
        function_node: &mut BoxedAstNode,
        arguments: &mut [AstNode],
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let function_type = self.collect_uvs(function_node)?;

        let argument_types: Vec<Type> = arguments
            .iter_mut()
            .map(|arg| self.collect_uvs(arg))
            .collect::<Result<_, _>>()?;

        let return_uv_type = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        let mut is_method_call = false;
        if let AstNodeKind::FieldAccess { left, .. } = &mut function_node.kind {
            if let AstNodeKind::Identifier(left_name) = &left.kind {
                if self
                    .symbol_table
                    .find_type_symbol_from_scope(left.scope_id.unwrap(), left_name)
                    .is_none()
                {
                    is_method_call = true;

                    let instance_type = left
                        .type_id
                        .clone()
                        .expect("instance in method call should have a type");

                    self.unification_context.register_constraint(
                        Constraint::MethodCall(
                            instance_type,
                            function_type.clone(),
                            argument_types.clone(),
                            return_uv_type.clone(),
                        ),
                        info,
                    );
                }
            }
        }

        if !is_method_call {
            self.unification_context.register_constraint(
                Constraint::FunctionSignature(function_type, argument_types, return_uv_type.clone()),
                info,
            );
        }

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), return_uv_type),
            info,
        );

        Ok(())
    }

    fn collect_uv_struct_field(
        &mut self,
        uv_id: TypeSymbolId,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        Ok(())
    }

    fn collect_uv_enum_variant(
        &mut self,
        uv_id: TypeSymbolId,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let enum_scope = self.symbol_table.get_scope(info.scope_id).unwrap();
        let enum_parent_scope = self
            .symbol_table
            .get_scope(enum_scope.parent.unwrap())
            .unwrap();

        let enum_type_symbol = enum_parent_scope
            .types
            .values()
            .find_map(|type_id| {
                let symbol = self.symbol_table.get_type_symbol(*type_id).unwrap();
                if let TypeSymbolKind::Enum((scope, _)) = symbol.kind {
                    if scope == info.scope_id {
                        return Some(symbol);
                    }
                }
                None
            })
            .unwrap();

        let enum_type = Type::new_base(enum_type_symbol.id);

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), enum_type.clone()),
            info,
        );

        Ok(())
    }
}

impl SemanticAnalyzer {
    pub fn uv_collector_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.collect_uvs(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn collect_uvs(&mut self, expr: &mut AstNode) -> Result<Type, BoxedError> {
        use AstNodeKind::*;

        let uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, expr.span);
        let uv_id = uv.get_base_symbol();

        let info = ConstraintInfo {
            span: expr.span,
            scope_id: expr.scope_id.unwrap_or_else(|| panic!("scope_id should exist on node, especially this one: {} \n{:?}", expr, expr)),
        };

        match &mut expr.kind {
            IntegerLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Int)),
                ),
                info,
            ),
            FloatLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Float)),
                ),
                info,
            ),
            BooleanLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Bool)),
                ),
                info,
            ),
            StringLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::String)),
                ),
                info,
            ),
            CharLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Char)),
                ),
                info,
            ),
            Identifier(string) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    self.get_type_of_identifier(expr.scope_id.unwrap(), string, expr.span)?,
                ),
                info,
            ),

            UnaryOperation { operator, operand } => {
                self.collect_uv_unary_operation(uv_id, operator, operand, info)?
            }
            BinaryOperation {
                left,
                right,
                operator,
            } => self.collect_uv_binary_operation(uv_id, left, right, operator, info)?,
            TypeCast {
                expr,
                target_type,
            } => self.collect_uv_type_cast(uv_id, expr, target_type, info)?,
            ConditionalOperation { left, right, operator, .. } => {
                self.collect_uv_conditional_operation(uv_id, left, right, operator, info)?
            }
            VariableDeclaration { .. } => {
                self.collect_uv_variable_declaration(uv_id, expr, expr.span, info)?
            }
            Block(statements) => self.collect_uv_block(uv_id, statements, info)?,
            IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => self.collect_uv_if_statement(
                uv_id,
                condition,
                then_branch,
                else_if_branches,
                else_branch,
                info,
            )?,
            WhileLoop { condition, body } => self.collect_uv_while_loop(uv_id, condition, body, info)?,
            ForLoop {
                initializer,
                condition,
                increment,
                body,
            } => self.collect_uv_for_loop(uv_id, initializer, condition, increment, body, info)?,
            Return(opt_expr) => self.collect_uv_return(uv_id, opt_expr, info)?,
            Function { .. } => self.collect_uv_function(uv_id, expr, expr.span, info)?,
            FunctionPointer { params, return_type } => {
                self.collect_uv_function_pointer(uv_id, params, return_type, expr.span, info)?
            }
            FunctionParameter { .. } => self.collect_uv_function_parameter(uv_id, expr, expr.span, info)?,
            StructLiteral { name, fields } => {
                self.collect_uv_struct_literal(uv_id, expr.scope_id.unwrap(), name, fields, expr.span, info)?
            }
            AssociatedConstant { .. } => self.collect_uv_associated_const(uv_id, expr, expr.span, info)?,
            TraitConstant { .. } => self.collect_uv_trait_const(uv_id, expr, expr.span, info)?,
            SelfValue => self.collect_uv_self_value(uv_id, expr.scope_id.unwrap(), expr.span, info)?,
            SelfType(reference_kind) => {
                self.collect_uv_self_type(uv_id, expr.scope_id.unwrap(), *reference_kind, expr.span, info)?
            }
            FieldAccess { left, right } => self.collect_uv_field_access(uv_id, left, right, info)?,
            FunctionCall { function, arguments } => {
                self.collect_uv_function_call(uv_id, function, arguments, expr.span, info)?
            },
            PathQualifier { .. } => {
                return Err(self.create_error(ErrorKind::InvalidPathQualifier, expr.span, &[expr.span]))
            },
            TypeReference {
                type_name,
                generic_types,
                reference_kind,
            } => self.collect_uv_type_reference(
                uv_id,
                expr.scope_id.unwrap(),
                type_name,
                generic_types,
                reference_kind,
                expr.span,
                info,
            )?,
            AssociatedType { .. } | TypeDeclaration { .. } => self.collect_uv_type_declaration(uv_id, expr, expr.span, info)?,
            StructField { .. } => {
                self.collect_uv_struct_field(uv_id, info)?
            }
            EnumVariant(_) => self.collect_uv_enum_variant(uv_id, info)?,
            Break | Continue => {
                if self.uv_collection_ctx.in_loop {
                    self.unification_context.register_constraint(
                        Constraint::Equality(
                            uv.clone(), 
                            Type::new_base(self.get_primitive_type(PrimitiveKind::Never))
                        ),
                        info
                    )
                } else {
                    return Err(self.create_error(ErrorKind::OutsideOfLoop, expr.span, &[expr.span]));
                }
            },
            StructDeclaration { .. }
            | EnumDeclaration { .. }
            | TraitDeclaration { .. }
            | ImplDeclaration { .. }
            | TraitType(_)
            | GenericParameter { .. } => {
                self.unification_context.register_constraint(
                    Constraint::Equality(
                        uv.clone(),
                        Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                    ),
                    info,
                );

                for child in expr.children_mut() {
                    self.collect_uvs(child)?;
                }
            },
            ExpressionStatement(inner_expr) => {
                self.collect_uvs(inner_expr)?;

                self.unification_context.register_constraint(
                    Constraint::Equality(
                        uv.clone(),
                        Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                    ),
                    info,
                );
            },
            Program(_) => unreachable!()
        }

        expr.type_id = Some(uv.clone());

        Ok(uv)
    }
}

// frontend/semantics/unification.rs
use std::collections::{HashMap, HashSet};

use crate::{
    frontend::syntax::ast::{AstNode, AstNodeKind},
    frontend::semantics::analyzer::{
        Constraint, ConstraintInfo, InherentImpl, PrimitiveKind, Scope, ScopeId, ScopeKind, SemanticAnalyzer, SymbolTable, TraitImpl, Type, TypeSymbolId, TypeSymbolKind, ValueSymbolKind
    },
    utils::{error::{BoxedError, Error, ErrorKind}, kind::{Operation, QualifierKind, Span}},
};

// https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html
#[derive(PartialEq, Eq, Hash, Clone, Debug)]
enum CanonicalType {
    Concrete(TypeSymbolId),
    Generic(usize),
}

impl SemanticAnalyzer {
    pub fn inherent_impl_deduplication_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                errors.append(&mut self.inherent_impl_deduplication_check_node(statement));
            }
        } else {
            unreachable!();
        }

        errors
    }
    
    fn inherent_impl_deduplication_check_node(&mut self, statement: &mut AstNode) -> Vec<Error> {
        match &statement.kind {
            AstNodeKind::StructDeclaration { name, .. } 
                => self.inherent_impl_deduplication_handle_struct(name, statement.scope_id.unwrap()),
            AstNodeKind::EnumDeclaration { name, .. } 
                => self.inherent_impl_deduplication_handle_enum(name, statement.scope_id.unwrap()),
            _ => {
                let mut errors = vec![];

                for node in statement.children_mut() {
                    errors.append(&mut self.inherent_impl_deduplication_check_node(node));
                }

                errors
            }
        }
    }

    fn inherent_impl_deduplication_handle_struct(&mut self, name: &str, scope_id: ScopeId) -> Vec<Error> {
        let symbol = self.symbol_table.find_type_symbol_in_scope(name, scope_id).unwrap();
        let name = self.symbol_table.get_type_name(symbol.name_id).to_string();
        let TypeSymbolKind::Struct((_, inherent_impls)) = &symbol.kind else { unreachable!(); };

        self.inherent_impl_deduplication_find_duplicates(&name, inherent_impls)
    }

    fn inherent_impl_deduplication_handle_enum(&mut self, name: &str, scope_id: ScopeId) -> Vec<Error> {
        let symbol = self.symbol_table.find_type_symbol_in_scope(name, scope_id).unwrap();
        let name = self.symbol_table.get_type_name(symbol.name_id).to_string();
        let TypeSymbolKind::Enum((_, inherent_impls)) = &symbol.kind else { unreachable!(); };

        self.inherent_impl_deduplication_find_duplicates(&name, inherent_impls)
    }

    fn inherent_impl_deduplication_find_duplicates(&self, namespace: &str, inherent_impls: &[InherentImpl]) -> Vec<Error> {
        let mut errors = vec![];
        let mut impls_by_canonical_spec: HashMap<Vec<CanonicalType>, Vec<&InherentImpl>> = HashMap::new();

        for inherent_impl in inherent_impls.iter() {
            let generic_map: HashMap<TypeSymbolId, usize> = inherent_impl.generic_params
                .iter()
                .enumerate()
                .map(|(i, &id)| (id, i))
                .collect();
            
            let canonical_spec: Vec<CanonicalType> = inherent_impl.specialization
                .iter()
                .map(|&spec_id| {
                    if let Some(&generic_index) = generic_map.get(&spec_id) {
                        CanonicalType::Generic(generic_index + 1)
                    } else {
                        CanonicalType::Concrete(spec_id)
                    }
                })
                .collect();
            
            impls_by_canonical_spec.entry(canonical_spec)
                .or_default()
                .push(inherent_impl);
        }

        for (canonical_spec, impls) in impls_by_canonical_spec.iter() {
            let mut symbols: HashMap<String, Vec<Span>> = HashMap::new();

            for inherent_impl in impls.iter() {
                let scope = self.symbol_table.get_scope(inherent_impl.scope_id).unwrap();

                for (&value_name_id, &value_symbol_id) in scope.values.iter() {
                    let value_name = self.symbol_table.get_value_name(value_name_id);
                    let value_span = self.symbol_table.get_value_symbol(value_symbol_id).unwrap().span.unwrap();

                    symbols.entry(value_name.to_string()).or_default().push(value_span);
                }

                for (&type_name_id, &type_symbol_id) in scope.types.iter() {
                    let type_name = self.symbol_table.get_type_name(type_name_id);
                    let type_span = self.symbol_table.get_type_symbol(type_symbol_id).unwrap().span;
                    
                    if let Some(type_span) = type_span {
                        symbols.entry(type_name.to_string()).or_default().push(type_span);
                    }
                }
            }

            let spec_str = canonical_spec.iter().map(|ct| {
                match ct {
                    CanonicalType::Concrete(id) => {
                        let symbol = self.symbol_table.get_type_symbol(*id).unwrap();
                        self.symbol_table.get_type_name(symbol.name_id).to_string()
                    },
                    CanonicalType::Generic(i) => {
                        format!("T{}", i)
                    },
                }
            }).collect::<Vec<_>>().join(", ");
            
            let full_type_name = if spec_str.is_empty() {
                namespace.to_string()
            } else {
                format!("{}<{}>", namespace, spec_str)
            };

            for (name, spans) in symbols.iter() {
                if spans.len() > 1 {
                     errors.push(*self.create_error(
                        ErrorKind::DuplicateSymbolsInInherentImpl(name.to_string(), full_type_name.clone()),
                        spans[0], 
                        &spans[0..spans.len()]
                    ))
                }
            }
        }
        
        errors
    }
}

impl SemanticAnalyzer {
    fn is_uv(&self, symbol_id: TypeSymbolId) -> bool {
        matches!(
            self.symbol_table.get_type_symbol(symbol_id).unwrap().kind,
            TypeSymbolKind::UnificationVariable(_)
        )
    }

    fn is_never(&self, symbol_id: TypeSymbolId) -> bool {
        matches!(
            self.symbol_table.get_type_symbol(symbol_id).unwrap().kind,
            TypeSymbolKind::Primitive(PrimitiveKind::Never)
        )
    }

    fn is_opaque_type_projection(&self, symbol_id: TypeSymbolId) -> bool {
        matches!(
            self.symbol_table.get_type_symbol(symbol_id).unwrap().kind,
            TypeSymbolKind::OpaqueTypeProjection { .. }
        )
    }

    /// Creates a substitution map from an impl's generic parameters to a concrete type's arguments.
    ///
    /// `impl<T, U> for MyStruct<T, U>` on `MyStruct<i32, bool>`
    /// returns a map `{ T -> i32, U -> bool }`.
    fn create_generic_substitution_map(
        &self,
        impl_generic_params: &[TypeSymbolId],
        concrete_args: &[Type],
    ) -> HashMap<TypeSymbolId, Type> {
        impl_generic_params
            .iter()
            .zip(concrete_args.iter())
            .map(|(param_id, concrete_type)| (*param_id, concrete_type.clone()))
            .collect()
    }

    /// Applies a substitution map to a type.
    fn apply_substitution(
        &mut self,
        ty: &Type,
        substitutions: &HashMap<TypeSymbolId, Type>
    ) -> Type {
        match ty {
            Type::Base { symbol: base_symbol_id, args } => {
                if let Some(substituted_type) = substitutions.get(base_symbol_id) {
                    return substituted_type.clone();
                }

                let base_symbol = self.symbol_table.get_type_symbol(*base_symbol_id).unwrap().clone();

                match &base_symbol.kind {
                    TypeSymbolKind::TypeAlias((_, Some(aliased_type))) => {
                        let alias_generic_params = &base_symbol.generic_parameters;
                        let concrete_alias_args = args;

                        let mut local_substitutions = self.create_generic_substitution_map(
                            alias_generic_params,
                            concrete_alias_args
                        );

                        for (key, value) in substitutions {
                            local_substitutions.entry(*key).or_insert_with(|| value.clone());
                        }

                        self.apply_substitution(aliased_type, &local_substitutions)
                    },
                    TypeSymbolKind::FunctionSignature { params, return_type, instance } => {
                        let substituted_params = params
                            .iter()
                            .map(|p| self.apply_substitution(p, substitutions))
                            .collect();

                        let substituted_return_type = self.apply_substitution(return_type, substitutions);

                        let relevant_substitutions: HashMap<_, _> = substitutions
                            .iter()
                            .filter(|(k, _)| base_symbol.generic_parameters.contains(k))
                            .collect();

                        let mut sorted_subs: Vec<_> = relevant_substitutions.iter().collect();
                        sorted_subs.sort_by_key(|(k, _)| **k);
                        
                        let specialization_key = sorted_subs
                            .iter()
                            .map(|(k, v)| format!("{}-{}", k, v))
                            .collect::<Vec<_>>()
                            .join("_");
                        
                        let signature_name = format!("#fn_sig_specialized_{}_{}", base_symbol.id, specialization_key);
                        
                        let specialized_sig_id = if let Some(symbol) =
                            self.symbol_table.find_type_symbol_in_scope(&signature_name, base_symbol.scope_id)
                        {
                            symbol.id
                        } else {
                            self.symbol_table.add_type_symbol(
                                &signature_name,
                                TypeSymbolKind::FunctionSignature {
                                    params: substituted_params,
                                    return_type: substituted_return_type,
                                    instance: *instance,
                                },
                                vec![],
                                QualifierKind::Private,
                                None
                            ).unwrap()
                        };
                        
                        Type::new_base(specialized_sig_id)
                    },
                    _ => {
                        let substituted_args = args
                            .iter()
                            .map(|arg| self.apply_substitution(arg, substitutions))
                            .collect();

                        Type::Base {
                            symbol: *base_symbol_id,
                            args: substituted_args,
                        }
                    }
                }
            },
            Type::Reference(inner) => {
                Type::Reference(Box::new(self.apply_substitution(inner, substitutions)))
            },
            Type::MutableReference(inner) => {
                Type::MutableReference(Box::new(self.apply_substitution(inner, substitutions)))
            }
        }
    }

    /// Recursively resolves a type by applying substitutions for unification variables
    /// and expanding type aliases until a concrete type or a unification variable is reached.
    fn resolve_type(&mut self, ty: &Type) -> Type {
        let uc_substitutions = self.unification_context.substitutions.clone();
        let mut current_ty = self.apply_substitution(ty, &uc_substitutions);

        loop {
            let Type::Base { symbol, args } = &current_ty else { break; };

            if self.is_uv(*symbol) {
                break;
            }

            let type_symbol = self.symbol_table.get_type_symbol(*symbol).unwrap().clone();

            if let TypeSymbolKind::TypeAlias((_, Some(aliased_type))) = &type_symbol.kind {
                let substitutions = self.create_generic_substitution_map(
                    &type_symbol.generic_parameters,
                    args
                );

                let substituted_alias = self.apply_substitution(aliased_type, &substitutions);
                current_ty = self.apply_substitution(&substituted_alias, &uc_substitutions);
            } else {
                break;
            }
        }

        current_ty
    }

    /// Checks if a unification variable `uv_id` occurs within a type `ty`.
    /// https://en.wikipedia.org/wiki/Occurs_check
    fn occurs_check(&mut self, uv_id: TypeSymbolId, ty: &Type) -> bool {
        let resolved_ty = self.resolve_type(ty);

        match &resolved_ty {
            Type::Base { symbol, args } => {
                if *symbol == uv_id {
                    return true;
                }
                // No need to check substitutions here because resolve_type already did it.
                args.iter().any(|arg| self.occurs_check(uv_id, arg))
            }
            Type::Reference(inner) | Type::MutableReference(inner) => self.occurs_check(uv_id, inner),
        }
    }

    /// Unifies a metavariable with a type.
    fn unify_variable(
        &mut self,
        uv_id: TypeSymbolId,
        ty: Type,
        info: ConstraintInfo,
    ) -> Result<Type, BoxedError> {
        if self.occurs_check(uv_id, &ty) {
            return Err(self.type_mismatch_error(
                &Type::new_base(uv_id),
                &ty,
                info,
                Some("infinite type detected: a metavariable occurs within its own definition".to_string()),
            ));
        }

        self.unification_context.substitutions.insert(uv_id, ty.clone());
        Ok(ty)
    }

    /// Generates a mismatch error between types `t1` and `t2`.
    fn type_mismatch_error(
        &self,
        t1: &Type,
        t2: &Type,
        info: ConstraintInfo,
        specifics: Option<String>,
    ) -> BoxedError {
        self.create_error(
            ErrorKind::TypeMismatch(
                self.symbol_table.display_type(t1),
                self.symbol_table.display_type(t2),
                specifics,
            ),
            info.span,
            &[info.span],
        )
    }

    /// Checks if an `impl` block is applicable to a given concrete instance type.
    ///
    /// If it is applicable, it returns a substitution map for the `impl`'s generic
    /// parameters. If not, it returns `None`.
    fn check_impl_applicability(
        &mut self,
        instance_type: &Type,
        imp: &InherentImpl,
    ) -> Option<HashMap<TypeSymbolId, Type>> {
        let instance_args = if let Type::Base { args, .. } = instance_type {
            args
        } else {
            return None; // instance type is not a base type
        };

        let impl_target_arg_ids = &imp.specialization;

        if instance_args.len() != impl_target_arg_ids.len() {
            return None; // arity mismatch
        }

        let mut substitutions = HashMap::new();

        for (instance_arg, &impl_target_arg_id) in instance_args.iter().zip(impl_target_arg_ids) {
            let target_symbol = self.symbol_table.get_type_symbol(impl_target_arg_id).unwrap();

            if imp.generic_params.contains(&target_symbol.id) {
                substitutions.insert(target_symbol.id, instance_arg.clone());
            } else {
                let resolved_instance_arg = self.resolve_type(instance_arg);
                let resolved_impl_arg = self.resolve_type(&Type::new_base(impl_target_arg_id));

                if resolved_instance_arg != resolved_impl_arg {
                    return None;
                }
            }
        }

        Some(substitutions)
    }

    fn check_trait_impl_applicability(
        &mut self,
        instance_type: &Type,
        imp: &TraitImpl,
    ) -> Option<HashMap<TypeSymbolId, Type>> {
        let instance_args = if let Type::Base { args, .. } = instance_type {
            args
        } else {
            return None; // instance type is not a base type
        };

        let impl_target_arg_ids = &imp.type_specialization;

        if instance_args.len() != impl_target_arg_ids.len() {
            return None; // arity mismatch
        }

        let mut substitutions = HashMap::new();

        for (instance_arg, &impl_target_arg_id) in instance_args.iter().zip(impl_target_arg_ids) {
            let target_symbol = self.symbol_table.get_type_symbol(impl_target_arg_id).unwrap();

            if imp.impl_generic_params.contains(&target_symbol.id) {
                substitutions.insert(target_symbol.id, instance_arg.clone());
            } else {
                let resolved_instance_arg = self.resolve_type(instance_arg);
                let resolved_impl_arg = self.resolve_type(&Type::new_base(impl_target_arg_id));

                if resolved_instance_arg != resolved_impl_arg {
                    return None;
                }
            }
        }
        
        Some(substitutions)
    }

    /// Checks if a type implements a trait.
    fn does_type_implement_trait(&mut self, ty: &Type, trait_id: TypeSymbolId) -> Result<bool, BoxedError> {
        let resolved_type = self.resolve_type(ty);
        if self.is_uv(resolved_type.get_base_symbol()) {
            return Ok(false);
        }
    
        let type_id = resolved_type.get_base_symbol();
        let mut impls = vec![];
        
        if let Some(impls_for_trait) = self.trait_registry.register.get(&trait_id) {
            if let Some(impls_for_type) = impls_for_trait.get(&type_id) {
                for imp in impls_for_type {
                    impls.push(imp.clone());
                }
            }
        }

        for imp in impls {
            if self.check_trait_impl_applicability(&resolved_type, &imp).is_some() {
                return Ok(true);
            }
        }
        
        let type_symbol = self.symbol_table.get_type_symbol(type_id).unwrap();
        if let TypeSymbolKind::Generic(constraints) = &type_symbol.kind {
            if constraints.contains(&trait_id) {
                return Ok(true);
            }
        }
        
        Ok(false)
    }

    /// Recursively traverses a type to find all of its constituent generic type variables.
    fn collect_signature_generics(&self, ty: &Type, generics: &mut HashSet<TypeSymbolId>) {
        match ty {
            Type::Base { symbol, args } => {
                let type_symbol = self.symbol_table.get_type_symbol(*symbol).unwrap();
                if let TypeSymbolKind::Generic(_) = type_symbol.kind {
                    generics.insert(*symbol);
                }

                for arg in args {
                    self.collect_signature_generics(arg, generics);
                }
            },
            Type::Reference(inner) | Type::MutableReference(inner) => {
                self.collect_signature_generics(inner, generics);
            }
        }
    }

    /// Recursively traverses a `call_site` type and a `signature` type to infer
    /// the concrete types for a function's generic parameters.
    fn collect_substitutions(
        &mut self,
        concrete_ty: &Type,
        template_ty: &Type,
        substitutions: &mut HashMap<TypeSymbolId, Type>,
        fn_generics: &HashSet<TypeSymbolId>,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let concrete_ty = self.resolve_type(concrete_ty);

        match (concrete_ty.clone(), template_ty.clone()) {
            (_, Type::Base { symbol: s, .. }) if fn_generics.contains(&s) => {
                if let Some(existing_sub) = substitutions.get(&s) {
                    self.unify(existing_sub.clone(), concrete_ty, info)?;
                } else {
                    substitutions.insert(s, concrete_ty);
                }

                Ok(())
            },
            (concrete_ty, Type::Base { symbol: ts, .. }) if self.is_opaque_type_projection(ts) => {
                let opaque_symbol = self.symbol_table.get_type_symbol(ts).unwrap().clone();
                if let TypeSymbolKind::OpaqueTypeProjection { ty: opaque_ty, tr: opaque_tr, member } = opaque_symbol.kind {
                    let substituted_opaque_ty = self.apply_substitution(&opaque_ty, substitutions);

                    if substituted_opaque_ty.contains_generics(fn_generics) {
                        return Ok(());
                    }

                    if let Some(resolved_member_type) = self.find_member_in_trait_impl(&substituted_opaque_ty, &opaque_tr, &member, info)? {
                        self.unify(concrete_ty, resolved_member_type, info)?;
                    } else {
                        return Err(self.create_error(
                            ErrorKind::UnimplementedTrait(
                                self.symbol_table.display_type(&opaque_tr),
                                self.symbol_table.display_type(&substituted_opaque_ty)
                            ),
                            info.span,
                            &[info.span]
                        ));
                    }
                }
                Ok(())
            },
            (Type::Base { symbol: cs, args: ca }, Type::Base { symbol: ts, args: ta}) => {
                if cs != ts || ca.len() != ta.len() {
                    return Ok(());
                }

                for (c_arg, t_arg) in ca.iter().zip(ta.iter()) {
                    self.collect_substitutions(c_arg, t_arg, substitutions, fn_generics, info)?;
                }

                Ok(())
            },
            (Type::Reference(ci), Type::Reference(ti)) => {
                self.collect_substitutions(&ci, &ti, substitutions, fn_generics, info)
            },
            (Type::MutableReference(ci), Type::MutableReference(ti)) => {
                self.collect_substitutions(&ci, &ti, substitutions, fn_generics, info)
            },
            _ => Ok(())
        }
    }
}

impl SemanticAnalyzer {
    fn is_access_in_impl_of(&self, mut access_scope_id: ScopeId, target_type_id: TypeSymbolId) -> bool {
        loop {
            let scope = self.symbol_table.get_scope(access_scope_id).unwrap();
            if scope.kind == ScopeKind::Impl
                && let Some(self_symbol) = self.symbol_table.find_type_symbol_in_scope("Self", access_scope_id)
                && let TypeSymbolKind::TypeAlias((_, Some(self_type))) = &self_symbol.kind
                && self_type.get_base_symbol() == target_type_id 
            {
                return true;
            }

            if let Some(parent_id) = scope.parent {
                access_scope_id = parent_id;
            } else {
                break;
            }
        }
        
        false
    }
    
    fn find_member_in_impl_scope(
        &mut self,
        scope_id: ScopeId,
        member_name: &str,
        is_static_access: bool,
        info: ConstraintInfo,
    ) -> Result<Option<Type>, BoxedError> {
        if let Some(value_symbol) = self.symbol_table.find_value_symbol_in_scope(member_name, scope_id).cloned() {
            if value_symbol.qualifier == QualifierKind::Private {
                let self_symbol = self.symbol_table.find_type_symbol_in_scope("Self", scope_id).unwrap();
                let TypeSymbolKind::TypeAlias((_, Some(self_type))) = &self_symbol.kind else { unreachable!(); };

                if !self.is_access_in_impl_of(info.scope_id, self_type.get_base_symbol()) {
                    return Err(self.create_error(
                        ErrorKind::PrivateMemberAccess(member_name.to_string(), self.symbol_table.display_type(self_type)),
                        info.span,
                        &[info.span, value_symbol.span.unwrap()]
                    ));
                }
            }
            
            let symbol_type = value_symbol.type_id.as_ref().unwrap().clone();
            
            let is_match = match value_symbol.kind {
                ValueSymbolKind::Function(_) => {
                    let resolved_type = self.resolve_type(&symbol_type);
                    if self.is_uv(resolved_type.get_base_symbol()) { 
                        return Ok(None); 
                    }
    
                    let fn_sig_symbol = self.symbol_table.get_type_symbol(resolved_type.get_base_symbol()).unwrap();
                    if let TypeSymbolKind::FunctionSignature { instance, .. } = fn_sig_symbol.kind {
                        is_static_access == instance.is_none()
                    } else { 
                        false 
                    }
                },
                ValueSymbolKind::Variable => is_static_access,
                _ => false
            };
            
            if is_match {
                return Ok(Some(symbol_type));
            }
        }
        
        if is_static_access {
            if let Some(type_symbol) = self.symbol_table.find_type_symbol_in_scope(member_name, scope_id).cloned() {
                if type_symbol.qualifier == QualifierKind::Private {
                    let self_symbol = self.symbol_table.find_type_symbol_in_scope("Self", scope_id).unwrap();
                    let TypeSymbolKind::TypeAlias((_, Some(self_type))) = &self_symbol.kind else { unreachable!(); };

                    if !self.is_access_in_impl_of(info.scope_id, self_type.get_base_symbol()) {
                       return Err(self.create_error(
                           ErrorKind::PrivateMemberAccess(member_name.to_string(), self.symbol_table.display_type(self_type)),
                           info.span,
                           &[info.span, type_symbol.span.unwrap()]
                       ));
                   }
                }

                return Ok(Some(Type::new_base(type_symbol.id)));
            }
        }
        
        Ok(None)
    }

    fn find_member_in_inherent_impls(
        &mut self,
        base_type: &Type,
        impls: &[InherentImpl],
        member_name: &str,
        is_static_access: bool,
        info: ConstraintInfo
    ) -> Result<Option<Type>, BoxedError> {
        for imp in impls {
            if let Some(substitutions) = self.check_impl_applicability(base_type, imp) {
                if let Some(member_type) = self.find_member_in_impl_scope(imp.scope_id, member_name, is_static_access, info)? {
                    let concrete_member_type = self.apply_substitution(&member_type, &substitutions);
                    return Ok(Some(concrete_member_type));
                }
            }
        }

        Ok(None)
    }

    fn find_member_in_trait_impls(
        &mut self,
        base_type: &Type,
        member_name: &str,
        is_static_access: bool,
        info: ConstraintInfo
    ) -> Result<Option<Type>, BoxedError> {
        let base_symbol_id = base_type.get_base_symbol();
        
        let all_trait_impls: Vec<_> = self.trait_registry.register.values()
            .filter_map(|impls_for_trait| impls_for_trait.get(&base_symbol_id))
            .flatten()
            .cloned().collect();
    
        for trait_impl in all_trait_impls {
            if let Some(substitutions) = self.check_trait_impl_applicability(base_type, &trait_impl) {
                if let Some(member_type) = self.find_member_in_impl_scope(trait_impl.impl_scope_id, member_name, is_static_access, info)? {
                    let concrete_member_type = self.apply_substitution(&member_type, &substitutions);
                    return Ok(Some(concrete_member_type));
                }
            }
        }

        Ok(None)
    }

    fn find_member(
        &mut self,
        base_type: &Type,
        member_name: &str,
        is_static_access: bool,
        info: ConstraintInfo,
    ) -> Result<Option<Type>, BoxedError> {
        let (base_symbol_id, concrete_args) = match base_type {
            Type::Base { symbol, args } => (*symbol, args.clone()),
            _ => return Err(self.create_error(ErrorKind::InvalidFieldAccess(self.symbol_table.display_type(base_type)), info.span, &[info.span])),
        };
    
        if self.is_uv(base_symbol_id) {
            return Ok(None);
        }
    
        let base_symbol = self.symbol_table.get_type_symbol(base_symbol_id).unwrap().clone();
        
        match &base_symbol.kind {
            TypeSymbolKind::Struct((scope_id, impls)) => {
                if !is_static_access {
                    if let Some(field_symbol) = self.symbol_table.find_value_symbol_in_scope(member_name, *scope_id).cloned() {
                        if field_symbol.qualifier == QualifierKind::Private 
                            && !self.is_access_in_impl_of(info.scope_id, base_symbol_id)
                        {
                            let type_name = self.symbol_table.display_type(base_type);
                            return Err(self.create_error(
                                ErrorKind::PrivateMemberAccess(member_name.to_string(), type_name),
                                info.span,
                                &[info.span, field_symbol.span.unwrap()]
                            ));
                        }

                        let substitutions = self.create_generic_substitution_map(&base_symbol.generic_parameters, &concrete_args);
                        let concrete_field_type = self.apply_substitution(field_symbol.type_id.as_ref().unwrap(), &substitutions);
                        return Ok(Some(concrete_field_type));
                    }
                }

                if let Some(ty) = self.find_member_in_inherent_impls(base_type, impls, member_name, is_static_access, info)? {
                    return Ok(Some(ty));
                }
            },
            TypeSymbolKind::Enum((scope_id, impls)) => {
                if is_static_access && self.symbol_table.find_value_symbol_in_scope(member_name, *scope_id).is_some() {
                    return Ok(Some(base_type.clone()));
                }

                if let Some(ty) = self.find_member_in_inherent_impls(base_type, impls, member_name, is_static_access, info)? {
                    return Ok(Some(ty));
                }
            },
            TypeSymbolKind::Generic(trait_constraints) => {
                for &trait_id in trait_constraints {
                    let trait_symbol = self.symbol_table.get_type_symbol(trait_id).unwrap();
                    let TypeSymbolKind::Trait(trait_scope_id) = trait_symbol.kind else { continue; };
        
                    if let Some(member_in_trait) = self.find_member_in_impl_scope(trait_scope_id, member_name, is_static_access, info)? {
                        let self_in_trait_id = self.symbol_table.find_type_symbol_in_scope("Self", trait_scope_id).unwrap().id;
                        let substitutions = HashMap::from([(self_in_trait_id, base_type.clone())]);
                        let concrete_member_type = self.apply_substitution(&member_in_trait, &substitutions);
                        
                        return Ok(Some(concrete_member_type));
                    }
                }
            },
            TypeSymbolKind::TraitSelf => {
                if is_static_access {
                    let trait_scope_id = base_symbol.scope_id;
                    if let Some(member_type) = self.find_member_in_impl_scope(trait_scope_id, member_name, true, info)? {
                        return Ok(Some(member_type));
                    }
                }
            }
            _ => {}
        }
    
        if let Some(ty) = self.find_member_in_trait_impls(base_type, member_name, is_static_access, info)? {
            return Ok(Some(ty));
        }
    
        Ok(None)
    }

    fn find_member_in_trait_impl(&mut self, ty: &Type, tr: &Type, member_name: &str, info: ConstraintInfo) -> Result<Option<Type>, BoxedError> {
        let type_id = ty.get_base_symbol();
        let trait_id = tr.get_base_symbol();

        if self.is_uv(type_id) || self.is_uv(trait_id) {
            return Ok(None);
        }

        let trait_symbol = self.symbol_table.get_type_symbol(trait_id).unwrap();
        if !matches!(trait_symbol.kind, TypeSymbolKind::Trait(_)) {
            return Err(self.create_error(
                ErrorKind::InvalidConstraint(self.symbol_table.display_type(tr)),
                info.span,
                &[info.span],
            ));
        }

        let all_trait_impls: Vec<_> = self.trait_registry.register.get(&trait_id)
            .and_then(|impls_for_trait| impls_for_trait.get(&type_id))
            .map_or(vec![], |v| v.clone());

        for trait_impl in all_trait_impls {
            if let Some(substitutions) = self.check_trait_impl_applicability(ty, &trait_impl) {
                // This call now includes the privacy check. Assuming `true` for `is_static_access` as this is for FQPs.
                if let Some(member_type) = self.find_member_in_impl_scope(trait_impl.impl_scope_id, member_name, true, info)? {
                    let concrete_member_type = self.apply_substitution(&member_type, &substitutions);
                    return Ok(Some(concrete_member_type));
                }
            }
        }
        
        Ok(None)
    }
}

impl SemanticAnalyzer {
    fn resolve_all_uvs_in_type(&mut self, ty: &Type, visited: &mut HashSet<TypeSymbolId>) -> Type {
        match ty {
            Type::Base { symbol, args } => {
                if self.is_uv(*symbol) {
                    if visited.contains(symbol) {
                        return ty.clone();
                    }

                    visited.insert(*symbol);

                    let result = if let Some(sub) = self.unification_context.substitutions.get(symbol).cloned() {
                        let resolved_sub = self.resolve_all_uvs_in_type(&sub, visited);
                        self.unification_context.substitutions.insert(*symbol, resolved_sub.clone());
                        resolved_sub
                    } else {
                        ty.clone()
                    };
                    
                    visited.remove(symbol);

                    return result;
                }

                let resolved_args: Vec<Type> = args.iter()
                    .map(|arg| self.resolve_all_uvs_in_type(arg, visited))
                    .collect();

                let symbol_data = self.symbol_table.get_type_symbol(*symbol).unwrap().clone();
                if let TypeSymbolKind::FunctionSignature { ref params, ref return_type, .. } = symbol_data.kind {
                    let resolved_params: Vec<Type> = params.iter().map(|p| self.resolve_all_uvs_in_type(p, visited)).collect();
                    let resolved_return = self.resolve_all_uvs_in_type(return_type, visited);

                    if resolved_params != *params || resolved_return != *return_type {
                        let fn_sig_symbol = self.symbol_table.get_type_symbol_mut(*symbol).unwrap();
                        
                        if let TypeSymbolKind::FunctionSignature { params, return_type, .. } = &mut fn_sig_symbol.kind {
                            *params = resolved_params;
                            *return_type = resolved_return;
                        } else {
                            unreachable!();
                        }
                    }
                }
                
                Type::Base { symbol: *symbol, args: resolved_args }
            },
            Type::Reference(inner) => Type::Reference(Box::new(self.resolve_all_uvs_in_type(inner, visited))),
            Type::MutableReference(inner) => Type::MutableReference(Box::new(self.resolve_all_uvs_in_type(inner, visited))),
        }
    }

    pub fn unification_pass(&mut self, _program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];
        let mut constraints = std::mem::take(&mut self.unification_context.constraints);

        let mut iterations = 0;
        let limit = constraints.len() * 4 + 100;

        while let Some((constraint, info)) = constraints.pop_front() {
            if iterations > limit {
                if !errors.is_empty() {
                    break;
                }

                panic!("incomplete inference: could not resolve constraints likely due to type inference loop");
            }

            iterations += 1;

            match self.process_constraint(constraint.clone(), info) {
                Ok(success) if !success => constraints.push_back((constraint, info)),
                Err(e) => errors.push(*e),
                _ => (),
            }
        }

        if errors.is_empty() {
            for symbol in self.symbol_table.type_symbols.values() {
                if let TypeSymbolKind::UnificationVariable(_) = symbol.kind {
                    if !self.unification_context.substitutions.contains_key(&symbol.id) {
                        let span = symbol.span.unwrap();
                        
                        errors.push(*self.create_error(
                            ErrorKind::TypeAnnotationNeeded,
                            span,
                            &[span],
                        ));
                    }
                }
            }
        }

        let keys: Vec<TypeSymbolId> = self.unification_context.substitutions.keys().cloned().collect();
        for uv_id in keys {
            if let Some(ty) = self.unification_context.substitutions.get(&uv_id).cloned() {
                let mut visited = HashSet::new();
                let fully_resolved_type = self.resolve_all_uvs_in_type(&ty, &mut visited);
                self.unification_context.substitutions.insert(uv_id, fully_resolved_type);
            }
        }

        errors
    }

    fn process_constraint(&mut self, constraint: Constraint, info: ConstraintInfo) -> Result<bool, BoxedError> {
        match constraint {
            Constraint::Equality(t1, t2) => {
                self.unify(t1, t2, info)?;
                Ok(true)
            },
            Constraint::FunctionSignature(callee_ty, params, return_ty) => {
                self.unify_function_signature(callee_ty, params, return_ty, info)
            },
            Constraint::MethodCall(instance_ty, callee_ty, params, return_ty) => {
                self.unify_method_call(instance_ty, callee_ty, params, return_ty, info)
            },
            Constraint::InstanceMemberAccess(result_ty, lhs_type, rhs_name) => {
                self.unify_member_access(result_ty, lhs_type, rhs_name, false, info)
            },
            Constraint::StaticMemberAccess(result_ty, lhs_type, rhs_name) => {
                self.unify_member_access(result_ty, lhs_type, rhs_name, true, info)
            },
            Constraint::FullyQualifiedAccess(result_ty, ty, tr_opt, member_name) => {
                self.unify_fully_qualified_access(result_ty, ty, tr_opt, member_name, info)
            },
            Constraint::Operation(uv_symbol_id, trait_type, lhs, rhs, operation) => {
                self.unify_operation(uv_symbol_id, trait_type, lhs, rhs, info, operation)
            },
            Constraint::Cast(source, target) => self.unify_cast(source, target, info)
        }
    }

    fn unify(&mut self, t1: Type, t2: Type, info: ConstraintInfo) -> Result<Type, BoxedError> {
        let t1 = self.resolve_type(&t1);
        let t2 = self.resolve_type(&t2);

        match (t1.clone(), t2.clone()) {
            (t1, t2) if t1 == t2 => Ok(t1),

            (Type::Base { symbol: s, .. }, other) | (other, Type::Base { symbol: s, .. }) 
                if self.is_uv(s) => self.unify_variable(s, other, info),
            
            (ref t @ Type::Base { symbol: s, .. }, _) | (_, ref t @ Type::Base { symbol: s, .. })
                if self.is_opaque_type_projection(s) => Ok(t.clone()),

            (Type::Base { symbol: s, .. }, other) | (other, Type::Base { symbol: s, .. })
                if self.is_never(s) => Ok(other.clone()),

            (ref t1 @ Type::Base { symbol: s1, args: ref a1 }, ref t2 @ Type::Base { symbol: s2, args: ref a2 }) => {
                let type_sym_s1 = self.symbol_table.get_type_symbol(s1).unwrap().clone();
                let type_sym_s2 = self.symbol_table.get_type_symbol(s2).unwrap().clone();
                
                if let Some(resultant_symbol) = type_sym_s1.unify(&type_sym_s2) {
                    if a1.len() != a2.len() {
                        return Err(self.type_mismatch_error(t1, t2, info, Some(format!("expected {} generic arguments, but found {}", a1.len(), a2.len()))));
                    }

                    let mut unified_args = vec![];
                    for (arg1, arg2) in a1.iter().zip(a2.iter()) {
                        unified_args.push(self.unify(arg1.clone(), arg2.clone(), info)?);
                    }

                    return Ok(Type::Base {
                        symbol: resultant_symbol,
                        args: unified_args,
                    });
                }

                Err(self.type_mismatch_error(t1, t2, info, None))
            },

            (Type::Reference(inner1), Type::Reference(inner2)) => {
                let unified = self.unify(*inner1, *inner2, info)?;
                Ok(Type::Reference(Box::new(unified)))
            },
            (Type::MutableReference(inner1), Type::MutableReference(inner2)) => {
                let unified = self.unify(*inner1, *inner2, info)?;
                Ok(Type::MutableReference(Box::new(unified)))
            },

            (t1, t2) => Err(self.type_mismatch_error(&t1, &t2, info, None)),
        }
    }

    fn unify_function_signature(
        &mut self,
        callee_ty: Type,
        params: Vec<Type>,
        return_ty: Type,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let callee_ty = self.resolve_type(&callee_ty);

        match callee_ty.clone() {
            Type::Base { symbol, .. } => {
                if self.is_uv(symbol) {
                    return Ok(false);
                }

                let callee_symbol = self.symbol_table.get_type_symbol(symbol).unwrap().clone();

                if let TypeSymbolKind::FunctionSignature {
                    params: sig_params,
                    return_type: sig_return,
                    ..
                } = &callee_symbol.kind
                {
                    if params.len() != sig_params.len() {
                        return Err(self.create_error(
                            ErrorKind::ArityMismatch(sig_params.len(), params.len()),
                            info.span,
                            &[info.span],
                        ));
                    }

                    let mut fn_generic_param_ids = HashSet::new();

                    self.collect_signature_generics(sig_return, &mut fn_generic_param_ids);
                    for p in sig_params {
                        self.collect_signature_generics(p, &mut fn_generic_param_ids);
                    }

                    let mut substitutions = HashMap::new();
                    for (call_arg, sig_param) in params.iter().zip(sig_params.iter()) {
                        self.collect_substitutions(
                            call_arg,
                            sig_param,
                            &mut substitutions,
                            &fn_generic_param_ids,
                            info,
                        )?;
                    }

                    let concrete_sig_params = sig_params.iter().map(|p| self.apply_substitution(p, &substitutions)).collect::<Vec<_>>();
                    let concrete_return = self.apply_substitution(sig_return, &substitutions);

                    for (arg, expected) in params.iter().zip(concrete_sig_params.iter()) {
                        self.unify(arg.clone(), expected.clone(), info)?;
                    }

                    self.unify(return_ty, concrete_return, info)?;

                    Ok(true)
                } else {
                    Err(self.create_error(
                        ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                        info.span,
                        &[info.span],
                    ))
                }
            }
            _ => Err(self.create_error(
                ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                info.span,
                &[info.span],
            )),
        }
    }

    fn unify_method_call(
        &mut self,
        instance_ty: Type,
        callee_ty: Type,
        params: Vec<Type>,
        return_ty: Type,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let callee_ty = self.resolve_type(&callee_ty);

        let callee_symbol_id = match callee_ty.clone() {
            Type::Base { symbol, .. } => {
                if self.is_uv(symbol) {
                    return Ok(false);
                }
                
                symbol
            }
            _ => {
                return Err(self.create_error(
                    ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                    info.span,
                    &[info.span],
                ))
            }
        };

        let callee_symbol = self.symbol_table.get_type_symbol(callee_symbol_id).unwrap().clone();

        if let TypeSymbolKind::FunctionSignature {
            params: expected_params_with_receiver,
            return_type: expected_return,
            instance: Some(_),
        } = callee_symbol.kind.clone()
        {
            if expected_params_with_receiver.is_empty() {
                panic!("This shouldn't happen. [1]");
            }

            let (expected_receiver_ty, expected_params) =
                expected_params_with_receiver.split_first().unwrap();

            if params.len() != expected_params.len() {
                return Err(self.create_error(
                    ErrorKind::ArityMismatch(expected_params.len(), params.len()),
                    info.span,
                    &[info.span],
                ));
            }

            let mut fn_generic_param_ids = HashSet::new();

            self.collect_signature_generics(&expected_return, &mut fn_generic_param_ids);
            for p in &expected_params_with_receiver {
                self.collect_signature_generics(p, &mut fn_generic_param_ids);
            }


            let mut substitutions = HashMap::new();

            self.collect_substitutions(
                &instance_ty,
                expected_receiver_ty,
                &mut substitutions,
                &fn_generic_param_ids,
                info,
            )?;

            for (call_arg, sig_param) in params.iter().zip(expected_params.iter()) {
                self.collect_substitutions(
                    call_arg,
                    sig_param,
                    &mut substitutions,
                    &fn_generic_param_ids,
                    info,
                )?;
            }

            let concrete_receiver = self.apply_substitution(expected_receiver_ty, &substitutions);
            let concrete_params = expected_params.iter().map(|p| self.apply_substitution(p, &substitutions)).collect::<Vec<_>>();
            let concrete_return = self.apply_substitution(&expected_return, &substitutions);

            for (arg, expected) in params.iter().zip(concrete_params.iter()) {
                self.unify(arg.clone(), expected.clone(), info)?;
            }

            if self.unify_receiver(instance_ty, concrete_receiver, info)?.is_none() {
                return Ok(false);
            }

            self.unify(return_ty, concrete_return, info)?;

            Ok(true)
        } else {
            Err(self.create_error(
                ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                info.span,
                &[info.span],
            ))
        }
    }

    fn unify_receiver(&mut self, passed: Type, expected: Type, info: ConstraintInfo) -> Result<Option<Type>, BoxedError> {
        let current_passed = self.resolve_type(&passed);
        let resolved_expected = self.resolve_type(&expected);

        if self.is_uv(current_passed.get_base_symbol()) || self.is_uv(resolved_expected.get_base_symbol()) {
            return Ok(None);
        }

        // Direct substitution.
        if let Ok(unified) = self.unify(current_passed.clone(), resolved_expected.clone(), info) {
            return Ok(Some(unified));
        }

        // `&mut T` -> `&T`
        if let (Type::MutableReference(p_inner), Type::Reference(e_inner)) = (current_passed.clone(), resolved_expected.clone()) {
            let unified_inner = self.unify(*p_inner, *e_inner, info)?;
            return Ok(Some(Type::Reference(Box::new(unified_inner))));
        }

        // `&^n T` | `&^n mut T` -> `T`
        let mut deref_passed = current_passed.clone();
        while let Type::Reference(inner) | Type::MutableReference(inner) = deref_passed {
            deref_passed = *inner;
            if let Ok(unified) = self.unify(deref_passed.clone(), resolved_expected.clone(), info) {
                return Ok(Some(unified));
            }
        }
        
        // `T` -> `&^n T` | `&^n mut T`
        if let p @ Type::Base { .. } = current_passed.clone() {
             match resolved_expected.clone() {
                e @ Type::Reference(_) => return self.unify(Type::Reference(Box::new(p)), e, info).map(Some),
                e @ Type::MutableReference(_) => return self.unify(Type::MutableReference(Box::new(p)), e, info).map(Some),
                _ => {}
            }
        }

        Err(self.type_mismatch_error(
            &current_passed,
            &resolved_expected,
            info,
            Some("receiver type mismatch".to_string()),
        ))
    }

    /// Unifies a member access operation (static or instance).
    fn unify_member_access(
        &mut self,
        result_ty: Type,
        lhs_type: Type,
        rhs_name: String,
        is_static: bool,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let resolved_lhs = self.resolve_type(&lhs_type);

        let base_lhs_type = if !is_static {
            match &resolved_lhs {
                Type::Reference(inner) | Type::MutableReference(inner) => (**inner).clone(),
                _ => resolved_lhs.clone(),
            }
        } else {
            resolved_lhs.clone()
        };

        if self.is_uv(base_lhs_type.get_base_symbol()) {
            return Ok(false);
        }

        let member_ty_opt = self.find_member(&base_lhs_type, &rhs_name, is_static, info)?;

        if let Some(member_ty) = member_ty_opt {
            self.unify(result_ty, member_ty, info)?;
            Ok(true)
        } else {
            Err(self.create_error(
                ErrorKind::MemberNotFound(rhs_name, self.symbol_table.display_type(&base_lhs_type)),
                info.span,
                &[info.span],
            ))
        }
    }

    fn unify_fully_qualified_access(
        &mut self,
        result_ty: Type,
        ty: Type,
        tr_opt: Option<Type>,
        member_name: String,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let resolved_ty = self.resolve_type(&ty);
        if self.is_uv(resolved_ty.get_base_symbol()) {
            return Ok(false);
        }

        let member_ty_opt = if let Some(tr) = tr_opt {
            let resolved_tr = self.resolve_type(&tr);
            if self.is_uv(resolved_tr.get_base_symbol()) {
                return Ok(false);
            }

            let ty_symbol = self.symbol_table.get_type_symbol(resolved_ty.get_base_symbol()).unwrap();
            if let TypeSymbolKind::Generic(_) = &ty_symbol.kind {
                let type_name = &format!(
                    "[{} as {}]::{}", 
                    self.symbol_table.display_type(&resolved_ty), 
                    self.symbol_table.display_type(&resolved_tr),
                    member_name
                );

                let symbol = if let Some(ty) = self.symbol_table.find_type_symbol_from_scope(self.symbol_table.get_current_scope_id(), type_name) {
                    ty.id
                } else {
                    self.symbol_table.add_type_symbol(
                        type_name, 
                        TypeSymbolKind::OpaqueTypeProjection {
                            ty: resolved_ty,
                            tr: resolved_tr,
                            member: member_name.clone()
                        }, 
                        vec![],
                        QualifierKind::Private, 
                        Some(info.span)
                    )?
                };

                self.unify(result_ty, Type::new_base(symbol), info)?;
                return Ok(true);
            }

            self.find_member_in_trait_impl(&resolved_ty, &resolved_tr, &member_name, info)?
        } else {
            self.find_member(&resolved_ty, &member_name, true, info)?
        };

        if let Some(member_ty) = member_ty_opt {
            self.unify(result_ty, member_ty, info)?;

            Ok(true)
        } else {
            let type_name = self.symbol_table.display_type(&resolved_ty);
            
            Err(self.create_error(
                ErrorKind::MemberNotFound(member_name, type_name),
                info.span,
                &[info.span],
            ))
        }
    }

    fn unify_operation(
        &mut self,
        result_ty: Type,
        trait_type: Type,
        lhs: Type,
        _rhs: Option<Type>,
        info: ConstraintInfo,
        _operation: Operation,
    ) -> Result<bool, BoxedError> {
        let resolved_lhs = self.resolve_type(&lhs);
        if self.is_uv(resolved_lhs.get_base_symbol()) {
            return Ok(false);
        }

        let (trait_id, trait_args) = match self.resolve_type(&trait_type) {
            Type::Base { symbol, args } => {
                if self.is_uv(symbol) { return Ok(false); }
                let resolved_args = args.iter().map(|a| self.resolve_type(a)).collect::<Vec<_>>();
                for arg in &resolved_args {
                    if self.is_uv(arg.get_base_symbol()) {
                        return Ok(false);
                    }
                }
                (symbol, resolved_args)
            },
            _ => unreachable!("trait type must be a base type for an operation"),
        };

        let lhs_type_id = resolved_lhs.get_base_symbol();
        let candidate_impls = self
            .trait_registry
            .register
            .get(&trait_id)
            .and_then(|impls_for_trait| impls_for_trait.get(&lhs_type_id))
            .cloned()
            .unwrap_or_default();

        let mut found_impl: Option<(TraitImpl, HashMap<TypeSymbolId, Type>)> = None;

        for imp in &candidate_impls {
            let Some(mut substitutions) = self.check_trait_impl_applicability(&resolved_lhs, imp) else {
                continue;
            };

            let impl_trait_template = Type::Base {
                symbol: trait_id,
                args: imp.trait_generic_specialization.iter().map(|id| Type::new_base(*id)).collect(),
            };
            let call_site_trait = Type::Base { symbol: trait_id, args: trait_args.clone() };
            let impl_generics_set: HashSet<TypeSymbolId> = imp.impl_generic_params.iter().cloned().collect();

            if self.collect_substitutions(&call_site_trait, &impl_trait_template, &mut substitutions, &impl_generics_set, info).is_err() {
                continue;
            }

            let substituted_impl_trait = self.apply_substitution(&impl_trait_template, &substitutions);
            if self.unify(call_site_trait.clone(), substituted_impl_trait, info).is_ok() {
                found_impl = Some((imp.clone(), substitutions));
                break;
            }
        }

        if let Some((imp, substitutions)) = found_impl {
            let output_type_symbol = self.symbol_table
                .find_type_symbol_in_scope("Output", imp.impl_scope_id)
                .ok_or_else(|| {
                    let trait_name = self.symbol_table.display_type(&Type::new_base(trait_id));
                    self.create_error(ErrorKind::UnknownIdentifier(format!("associated type 'Output' for trait '{}'", trait_name)), info.span, &[info.span])
                })?
                .clone();

            let TypeSymbolKind::TypeAlias((_, Some(output_type_template))) = &output_type_symbol.kind else {
                unreachable!("The 'Output' associated type in a trait impl must be a resolved alias");
            };

            let concrete_output_type = self.apply_substitution(output_type_template, &substitutions);
            
            self.unify(result_ty, concrete_output_type, info)?;
            
            Ok(true)
        } else {
            let trait_name = self.symbol_table.display_type(&Type::Base { symbol: trait_id, args: trait_args });
            let lhs_name = self.symbol_table.display_type(&resolved_lhs);
            Err(self.create_error(
                ErrorKind::UnimplementedTrait(trait_name, lhs_name),
                info.span,
                &[info.span],
            ))
        }
    }

    fn unify_cast(&mut self, source: Type, target: Type, info: ConstraintInfo) -> Result<bool, BoxedError> {
        let resolved_source = self.resolve_type(&source);
        let resolved_target = self.resolve_type(&target);

        if self.is_uv(resolved_source.get_base_symbol()) || self.is_uv(resolved_target.get_base_symbol()) {
            return Ok(false);
        }

        let source_sym = self.symbol_table.get_type_symbol(resolved_source.get_base_symbol()).unwrap();
        let target_sym = self.symbol_table.get_type_symbol(resolved_target.get_base_symbol()).unwrap();

        if source_sym.is_valid_cast(target_sym) {
            Ok(true)
        } else {
            Err(self.create_error(
                ErrorKind::InvalidCast(
                    self.symbol_table.display_type(&resolved_source),
                    self.symbol_table.display_type(&resolved_target),
                ),
                info.span,
                &[info.span],
            ))
        }
    }
}

impl SemanticAnalyzer {
    pub fn substitution_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(e) = self.substitution_pass_check_node(statement) {
                    errors.push(*e);
                }
            }
        } else {
            unreachable!();
        }

        self.traverse_symbol_table();

        errors
    }

    fn traverse_symbol_table(&mut self) {
        let keys: Vec<_> = self.symbol_table.value_symbols.keys().cloned().collect();

        for key in keys {
            let ty_opt = {
                let map = &mut self.symbol_table.value_symbols;

                if let Some(symbol) = map.get_mut(&key) {
                    symbol.type_id.take()
                } else {
                    None
                }
            };

            if let Some(ty) = ty_opt {
                let resolved = self.resolve_final_type(&ty);

                if let Some(symbol) = self.symbol_table.value_symbols.get_mut(&key) {
                    symbol.type_id = Some(resolved);
                }
            }
        }

        let type_symbol_ids: Vec<TypeSymbolId> = self.symbol_table.type_symbols.keys().cloned().collect();

        for id in type_symbol_ids {
            let mut kind_clone = self.symbol_table.type_symbols[&id].kind.clone();
            let mut was_changed = false;

            match &mut kind_clone {
                TypeSymbolKind::FunctionSignature { params, return_type, .. } => {
                    let new_params: Vec<Type> = params.iter().map(|p| self.resolve_final_type(p)).collect();
                    let new_return = self.resolve_final_type(return_type);
                    if *params != new_params || *return_type != new_return {
                        *params = new_params;
                        *return_type = new_return;
                        was_changed = true;
                    }
                },
                TypeSymbolKind::TypeAlias((_, Some(alias_ty))) => {
                    let new_alias = self.resolve_final_type(alias_ty);
                    if *alias_ty != new_alias {
                        *alias_ty = new_alias;
                        was_changed = true;
                    }
                },
                TypeSymbolKind::OpaqueTypeProjection { ty, tr, .. } => {
                    let new_ty = self.resolve_final_type(ty);
                    let new_tr = self.resolve_final_type(tr);
                    if *ty != new_ty || *tr != new_tr {
                        *ty = new_ty;
                        *tr = new_tr;
                        was_changed = true;
                    }
                },
                _ => {}
            }

            if was_changed {
                if let Some(symbol) = self.symbol_table.type_symbols.get_mut(&id) {
                    symbol.kind = kind_clone;
                }
            }
        }

        self.delete_uvs();
        self.unification_context.substitutions.clear();
    }

    fn resolve_final_type(&self, ty: &Type) -> Type {
        match ty {
            Type::Base { symbol, args } => {
                let resolved_args = args
                    .iter()
                    .map(|arg| self.resolve_final_type(arg))
                    .collect::<Vec<_>>();

                if self.is_uv(*symbol) {
                    return self.unification_context.substitutions[symbol].clone();
                }
                
                Type::Base {
                    symbol: *symbol,
                    args: resolved_args,
                }
            },
            Type::Reference(inner) => Type::Reference(Box::new(self.resolve_final_type(inner))),
            Type::MutableReference(inner) => Type::MutableReference(Box::new(self.resolve_final_type(inner)))
        }
    }

    fn substitution_pass_check_node(&mut self, node: &mut AstNode) -> Result<(), BoxedError> {
        for child in node.children_mut() {
            self.substitution_pass_check_node(child)?;
        }

        if let Some(ty) = node.type_id.take() {
            let resolved_type = self.resolve_final_type(&ty);
            node.type_id = Some(resolved_type);
        }

        if let Some(value_id) = node.value_id {
            let maybe_type_id = self.symbol_table
                .get_value_symbol_mut(value_id)
                .and_then(|symbol| symbol.type_id.take());

            if let Some(ty) = maybe_type_id {
                let resolved_type = self.resolve_final_type(&ty);

                if let Some(symbol) = self.symbol_table.get_value_symbol_mut(value_id) {
                    symbol.type_id = Some(resolved_type);
                }
            }
        }

        if let Some(base_type) = &node.type_id {
            if let Some(symbol_clone) = self.symbol_table.get_type_symbol(base_type.get_base_symbol()).cloned() {
                let mut new_kind = symbol_clone.kind;
                let mut was_changed = false;

                match &mut new_kind {
                    TypeSymbolKind::FunctionSignature { params, return_type, .. } => {
                        let new_params = params.iter().map(|p| self.resolve_final_type(p)).collect::<Vec<_>>();
                        let new_return = self.resolve_final_type(return_type);
                        
                        if &new_params != params || &new_return != return_type {
                            *params = new_params;
                            *return_type = new_return;
                            was_changed = true;
                        }
                    },
                    TypeSymbolKind::TypeAlias((_, Some(alias_ty))) => {
                        let new_alias = self.resolve_final_type(alias_ty);
                        if &new_alias != alias_ty {
                            *alias_ty = new_alias;
                            was_changed = true;
                        }
                    },
                    _ => {}
                }

                if was_changed {
                    self.symbol_table.get_type_symbol_mut(symbol_clone.id).unwrap().kind = new_kind;
                }
            }
        }
        
        Ok(())
    }
}

impl SemanticAnalyzer {
    pub fn mutability_check_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(e) = self.mutability_check_node(statement) {
                    errors.push(*e);
                }
            }
        } else {
            unreachable!();
        }
        
        errors
    }

    fn mutability_check_node(&mut self, node: &mut AstNode) -> Result<(), BoxedError> {
        for child in node.children_mut() {
            self.mutability_check_node(child)?;
        }

        match &node.kind {
            AstNodeKind::BinaryOperation { operator, left, .. } if operator.is_assignment() => {
                if !self.is_place_expr_and_mutable(left)? {
                    let name = left.get_name().unwrap_or_default();
                    return Err(self.create_error(
                        ErrorKind::MutatingImmutableData(name),
                        left.span,
                        &[left.span]
                    ));
                }
            },
            AstNodeKind::UnaryOperation { operator: Operation::MutableAddressOf, operand } => {
                 if !self.is_place_expr_and_mutable(operand)? {
                    let name = operand.get_name().unwrap_or_default();
                    return Err(self.create_error(
                        ErrorKind::MutatingImmutableData(name),
                        operand.span,
                        &[operand.span]
                    ));
                }
            },
            _ => {}
        }

        Ok(())
    }
    
    fn is_place_expr_and_mutable(&mut self, place: &AstNode) -> Result<bool, BoxedError> {
        match &place.kind {
            AstNodeKind::Identifier(name) => {
                if let Some(symbol) = self.symbol_table.find_value_symbol_from_scope(place.scope_id.unwrap(), name) {
                    if !matches!(symbol.kind, ValueSymbolKind::Variable) {
                        return Ok(false);
                    }

                    Ok(symbol.mutable)
                } else {
                    Err(self.create_error(ErrorKind::ExpectedValue, place.span, &[place.span]))
                }
            },
            AstNodeKind::FieldAccess { left: base, .. } => {
                if let AstNodeKind::Identifier(name) = &base.kind {
                    if self.symbol_table.find_type_symbol_from_scope(base.scope_id.unwrap(), name).is_some() {
                        return Ok(false);
                    }
                }

                let base_type = self.resolve_type(base.type_id.as_ref().unwrap());
                match &base_type {
                    Type::MutableReference(_) => Ok(true),
                    Type::Reference(_) => Ok(false),
                    Type::Base { .. } => self.is_place_expr_and_mutable(base),
                }
            },
            AstNodeKind::UnaryOperation { operator: Operation::Dereference, operand } => {
                let operand_type = self.resolve_type(operand.type_id.as_ref().unwrap());
                Ok(matches!(operand_type, Type::MutableReference(_)))
            },
            _ => Ok(false)
        }
    }
}

impl SemanticAnalyzer {
    pub fn trait_conformance_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(e) = self.trait_conformance_pass_check_node(statement) {
                    errors.push(*e);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn trait_conformance_pass_check_node(
        &mut self,
        statement: &mut AstNode,
    ) -> Result<(), BoxedError> {
        if let AstNodeKind::ImplDeclaration { .. } = &statement.kind {
            self.check_trait_conformance(statement)?;
        }

        for child in statement.children_mut() {
            self.trait_conformance_pass_check_node(child)?;
        }

        Ok(())
    }

    fn apply_trait_substitutions(
        &mut self,
        ty: &Type,
        substitutions: &HashMap<TypeSymbolId, Type>,
    ) -> Type {
        match ty {
            Type::Base { symbol, args } => {
                if let Some(substituted_type) = substitutions.get(symbol) {
                    return substituted_type.clone();
                }

                let type_symbol = self.symbol_table.get_type_symbol(*symbol).unwrap().clone();
                if let TypeSymbolKind::FunctionSignature { params, return_type, instance } = &type_symbol.kind {
                    let substituted_params: Vec<Type> = params
                        .iter()
                        .map(|p| self.apply_trait_substitutions(p, substitutions))
                        .collect();

                    let substituted_return_type = self.apply_trait_substitutions(return_type, substitutions);

                    if &substituted_params == params && &substituted_return_type == return_type {
                        return ty.clone();
                    }

                    let new_sig_name = format!("#fn_sig_conformance_{}_{:?}", symbol, substitutions.keys());

                    let specialized_sig_id = self.symbol_table.add_type_symbol(
                        &new_sig_name,
                        TypeSymbolKind::FunctionSignature {
                            params: substituted_params,
                            return_type: substituted_return_type,
                            instance: *instance
                        },
                        vec![],
                        QualifierKind::Private,
                        type_symbol.span,
                    ).unwrap();

                    return Type::Base {
                        symbol: specialized_sig_id,
                        args: vec![],
                    };
                }

                let substituted_args: Vec<Type> = args
                    .iter()
                    .map(|arg| self.apply_trait_substitutions(arg, substitutions))
                    .collect();

                Type::Base {
                    symbol: *symbol,
                    args: substituted_args,
                }
            },
            Type::Reference(inner) => {
                Type::Reference(Box::new(self.apply_trait_substitutions(inner, substitutions)))
            },
            Type::MutableReference(inner) => {
                Type::MutableReference(Box::new(self.apply_trait_substitutions(inner, substitutions)))
            }
        }
    }

    fn check_constant_conformance(
        &mut self,
        member_name: &str,
        trait_scope_id: ScopeId,
        impl_scope_id: ScopeId,
        substitution_map: &HashMap<TypeSymbolId, Type>,
    ) -> Result<(), BoxedError> {
        let trait_const_symbol = self.symbol_table.find_value_symbol_in_scope(member_name, trait_scope_id).unwrap().clone();
        let impl_const_symbol = self.symbol_table.find_value_symbol_in_scope(member_name, impl_scope_id).unwrap().clone();

        let template_type = trait_const_symbol.type_id.as_ref().unwrap();
        let actual_type = impl_const_symbol.type_id.as_ref().unwrap();

        let expected_type = self.apply_trait_substitutions(template_type, substitution_map);

        let info = ConstraintInfo {
            span: impl_const_symbol.span.unwrap(),
            scope_id: impl_scope_id,
        };

        if self.unify(expected_type.clone(), actual_type.clone(), info).is_err() {
            return Err(self.create_error(
                ErrorKind::TypeMismatch(
                    self.symbol_table.display_type(&expected_type),
                    self.symbol_table.display_type(actual_type),
                    Some(format!("for associated constant `{}`", member_name)),
                ),
                impl_const_symbol.span.unwrap(),
                &[impl_const_symbol.span.unwrap(), trait_const_symbol.span.unwrap()],
            ));
        }

        Ok(())
    }

    fn check_function_conformance(
        &mut self,
        member_name: &str,
        trait_scope_id: ScopeId,
        impl_scope_id: ScopeId,
        substitution_map: &HashMap<TypeSymbolId, Type>,
    ) -> Result<(), BoxedError> {
        let trait_fn_symbol = self.symbol_table.find_value_symbol_in_scope(member_name, trait_scope_id).unwrap().clone();
        let impl_fn_symbol = self.symbol_table.find_value_symbol_in_scope(member_name, impl_scope_id).unwrap().clone();

        let trait_fn_type = trait_fn_symbol.type_id.as_ref().unwrap();
        let impl_fn_type = impl_fn_symbol.type_id.as_ref().unwrap();

        let (trait_params, trait_return) = if let TypeSymbolKind::FunctionSignature { params, return_type, .. } = &self.symbol_table.get_type_symbol(trait_fn_type.get_base_symbol()).unwrap().kind {
            (params.clone(), return_type.clone())
        } else { unreachable!(); };

        let (impl_params, impl_return) = if let TypeSymbolKind::FunctionSignature { params, return_type, .. } = &self.symbol_table.get_type_symbol(impl_fn_type.get_base_symbol()).unwrap().kind {
            (params.clone(), return_type.clone())
        } else { unreachable!(); };

        if trait_params.len() != impl_params.len() {
            return Err(self.create_error(ErrorKind::ArityMismatch(trait_params.len(), impl_params.len()), impl_fn_symbol.span.unwrap(), &[trait_fn_symbol.span.unwrap()]));
        }

        let info = ConstraintInfo {
            span: impl_fn_symbol.span.unwrap(),
            scope_id: impl_scope_id,
        };

        for (trait_param, impl_param) in trait_params.iter().zip(impl_params.iter()) {
            let expected_param = self.apply_trait_substitutions(trait_param, substitution_map);
            if self.unify(expected_param.clone(), impl_param.clone(), info).is_err() {
                 return Err(self.create_error(
                    ErrorKind::TypeMismatch(
                        self.symbol_table.display_type(&expected_param),
                        self.symbol_table.display_type(impl_param),
                        Some(format!("in parameter for function `{}`", member_name)),
                    ),
                    info.span,
                    &[trait_fn_symbol.span.unwrap()],
                ));
            }
        }

        let expected_return = self.apply_trait_substitutions(&trait_return, substitution_map);
        if self.unify(expected_return.clone(), impl_return.clone(), info).is_err() {
            return Err(self.create_error(
                ErrorKind::TypeMismatch(
                    self.symbol_table.display_type(&expected_return),
                    self.symbol_table.display_type(&impl_return),
                    Some(format!("for return type of function `{}`", member_name)),
                ),
                info.span,
                &[trait_fn_symbol.span.unwrap()],
            ));
        }

        Ok(())
    }

    fn check_trait_conformance(&mut self, impl_node: &AstNode) -> Result<(), BoxedError> {
        let (trait_node, type_reference, impl_scope_id) =
            if let AstNodeKind::ImplDeclaration { trait_node, type_reference, .. } = &impl_node.kind {
                if let Some(tn) = trait_node {
                    (tn, type_reference, impl_node.scope_id.unwrap())
                } else {
                    return Ok(());
                }
            } else {
                unreachable!();
            };

        let trait_type = trait_node.type_id.as_ref().unwrap();
        let implementing_type = type_reference.type_id.as_ref().unwrap();

        let trait_id = trait_type.get_base_symbol();
        let trait_symbol = self.symbol_table.get_type_symbol(trait_id).unwrap().clone();
        let TypeSymbolKind::Trait(trait_scope_id) = trait_symbol.kind else {
            return Err(self.create_error(
                ErrorKind::InvalidConstraint(self.symbol_table.display_type(trait_type)),
                trait_node.span,
                &[trait_node.span],
            ));
        };

        let trait_scope = self.symbol_table.get_scope(trait_scope_id).unwrap();
        let impl_scope = self.symbol_table.get_scope(impl_scope_id).unwrap();

        let get_member_names = |scope: &Scope, table: &SymbolTable| {
            let mut members = HashSet::new();

            for (name_id, symbol_id) in &scope.types {
                let symbol = table.get_type_symbol(*symbol_id).unwrap();
                if matches!(symbol.kind, TypeSymbolKind::Generic(_)) {
                    continue;
                }

                let name = table.get_type_name(*name_id);
                if name != "Self" {
                    members.insert(name.to_string());
                }
            }

            for name_id in scope.values.keys() {
                members.insert(table.get_value_name(*name_id).to_string());
            }

            members
        };

        let trait_members = get_member_names(trait_scope, &self.symbol_table);
        let impl_members = get_member_names(impl_scope, &self.symbol_table);

        let missing: Vec<String> = trait_members.difference(&impl_members).cloned().collect();
        let extra: Vec<String> = impl_members.difference(&trait_members).cloned().collect();

        if !missing.is_empty() || !extra.is_empty() {
            return Err(self.create_error(
                ErrorKind::DeformedTraitImpl {
                    trait_name: self.symbol_table.display_type(trait_type),
                    missing,
                    extra,
                },
                impl_node.span,
                &[impl_node.span, trait_node.span],
            ));
        }

        let mut substitution_map: HashMap<TypeSymbolId, Type> = HashMap::new();

        substitution_map.insert(
            self.symbol_table.find_type_symbol_in_scope("Self", trait_scope_id).unwrap().id,
            implementing_type.clone(),
        );

        if let Type::Base { args, .. } = trait_type {
            if !trait_symbol.generic_parameters.is_empty() {
                let generic_substitutions = self.create_generic_substitution_map(
                    &trait_symbol.generic_parameters,
                    args,
                );
                substitution_map.extend(generic_substitutions);
            }
        }

        for member_name in trait_members.iter() {
            if let Some(trait_type_symbol) = self.symbol_table.find_type_symbol_in_scope(member_name, trait_scope_id) {
                if let Some(impl_type_symbol) = self.symbol_table.find_type_symbol_in_scope(member_name, impl_scope_id) {
                    let TypeSymbolKind::TypeAlias((_, Some(alias))) = &impl_type_symbol.kind else {
                        unreachable!();
                    };

                    substitution_map.insert(trait_type_symbol.id, alias.clone());
                }
            }
        }

        for member_name in trait_members.iter() {
            if let Some(trait_value_symbol) = self.symbol_table.find_value_symbol_in_scope(member_name, trait_scope_id) {
                match trait_value_symbol.kind {
                    ValueSymbolKind::Variable => self.check_constant_conformance(member_name, trait_scope_id, impl_scope_id, &substitution_map)?,
                    ValueSymbolKind::Function(_) => self.check_function_conformance(member_name, trait_scope_id, impl_scope_id, &substitution_map)?,
                    _ => {}
                }
            }
        }

        Ok(())
    }
}

// utils/error.rs
use colored::Colorize;

use crate::boxed;

use super::kind::Span;

#[derive(Debug, Clone, PartialEq)]
pub enum ErrorKind {
    UnrecognizedSymbol(String),
    UnexpectedEOF,
    InvalidDigit(String),
    InvalidEscapeSequence(String),
    UnterminatedString,
    InvalidChar(String),
    UnterminatedChar,
    UnexpectedToken(String, String, String),
    UninitializedConstant,
    UnknownIdentifier(String),
    UnresolvedType(String),
    AlreadyDeclared(String),
    UnknownType,
    InvalidImpl(Option<String>),
    ExpectedType,
    InvalidConstraint(String),
    UnimplementedTrait(String, String),
    ConflictingTraitImpl(String, String),
    DeformedTraitImpl {
        trait_name: String,
        missing: Vec<String>,
        extra: Vec<String>,
    },
    ConflictingInherentImpl(String),
    InvalidDereference(String),
    ExpectedScopedItem,
    MemberNotFound(String, String),
    InvalidFieldAccess(String),
    IncorrectFieldAccessRhs,
    BadVariableDeclaration,
    TypeAnnotationNeeded,
    SelfOutsideImpl,
    InvalidThis(&'static str),
    ExpectedIdentifier,
    TypeMismatch(String, String, Option<String>),
    NotCallable(String),
    ArityMismatch(usize, usize),
    InvalidReturn,
    InvalidField(String, String),
    MismatchedStructFields {
        struct_name: String,
        missing_fields: Vec<String>,
        extra_fields: Vec<String>,
    },
    InvalidCast(String, String),
    DuplicateSymbolsInInherentImpl(String, String),
    InvalidPathQualifier,
    OutsideOfLoop,
    InvalidTypeReference(String, usize, usize),
    MutatingImmutableData(String),
    ExpectedValue,
    PrivateMemberAccess(String, String)
}

impl ErrorKind {
    fn as_str(&self) -> String {
        match self {
            ErrorKind::UnrecognizedSymbol(symbol) => format!("unrecognized symbol {symbol}"),
            ErrorKind::UnexpectedEOF => "unexpected <eof> while parsing".to_string(),
            ErrorKind::InvalidDigit(digit) => format!("invalid digit {digit}"),
            ErrorKind::InvalidEscapeSequence(sequence) => {
                format!("invalid escape sequence {sequence}")
            }
            ErrorKind::UnterminatedString => "string left unterminated".to_string(),
            ErrorKind::InvalidChar(char) => format!("invalid char {char}"),
            ErrorKind::UnterminatedChar => "unterminated or degenerate char".to_string(),
            ErrorKind::UnexpectedToken(symbol, found, expected) => format!(
                "unexpected token: found \"{symbol}\" of type {found}, expected {expected}"
            ),
            ErrorKind::UninitializedConstant => "constant declared but no value assigned".to_string(),
            ErrorKind::UnknownIdentifier(name) => format!("could not find \"{name}\" in scope"),
            ErrorKind::UnresolvedType(name) => format!(
                "type for symbol \"{name}\" has not been determined by this line"
            ),
            ErrorKind::AlreadyDeclared(variable) => format!(
                "attempted to declare {variable}, but it already exists in scope"
            ),
            ErrorKind::UnknownType => "could not determine type of data by this line".to_string(),
            ErrorKind::InvalidImpl(type_ref) => format!(
                "cannot construct impl block for {}",
                type_ref.as_ref().map_or("an unnamed identifier", |v| v)
            ),
            ErrorKind::ExpectedType => "expected this to resolve to a type".to_string(),
            ErrorKind::InvalidConstraint(constraint) => format!(
                "expected constraint to be a trait, instead found \"{constraint}\""
            ),
            ErrorKind::UnimplementedTrait(tr, ty) => {
                format!("trait {tr} not implemented for type {ty}")
            }
            ErrorKind::ConflictingTraitImpl(tr, ty) => {
                format!("conflicting trait implementations for {tr} on type {ty}")
            }
            ErrorKind::DeformedTraitImpl {
                trait_name,
                missing,
                extra,
            } => {
                let mut message = format!("deformed implementation of trait `{}`", trait_name);
                if !missing.is_empty() {
                    message.push_str(&format!("\n  - missing items: {}", missing.join(", ")));
                }
                if !extra.is_empty() {
                    message.push_str(&format!("\n  - extraneous items: {}", extra.join(", ")));
                }
                message
            }
            ErrorKind::ConflictingInherentImpl(ty) => {
                format!("conflicting implementations for type {ty}")
            }
            ErrorKind::InvalidDereference(ty) => {
                format!("attempted to dereference non-pointer type {ty}")
            }
            ErrorKind::ExpectedScopedItem => "expected an item with a scope".to_string(),
            ErrorKind::MemberNotFound(field, type_name) => {
                format!("member \"{field}\" not found in type {type_name}")
            }
            ErrorKind::InvalidFieldAccess(type_name) => {
                format!("type {type_name} does not comprise fields")
            }
            ErrorKind::IncorrectFieldAccessRhs => "cannot access this field".to_string(),
            ErrorKind::BadVariableDeclaration => {
                "variable declaration must be annotated with a type or value".to_string()
            },
            ErrorKind::TypeAnnotationNeeded => "cannot infer type for this; a type annotation may be needed".to_string(),
            ErrorKind::SelfOutsideImpl => "use of Self outside of an impl block".to_string(),
            ErrorKind::InvalidThis(place) => format!("found \"this\" {place}"),
            ErrorKind::ExpectedIdentifier => {
                "expected an identifier for the rhs of a field access operation".to_string()
            }
            ErrorKind::TypeMismatch(t1, t2, str) => {
                format!("types {t1} and {t2} are incompatible{}", match str {
                    Some(s) => format!(" [{s}]"),
                    None => "".to_string()
                })
            },
            ErrorKind::NotCallable(ty) => format!("{ty} is not callable"),
            ErrorKind::ArityMismatch(expected, given) => format!("expected {expected} arguments, got {given} arguments"),
            ErrorKind::InvalidReturn => "return statement found outside of function".to_string(),
            ErrorKind::InvalidField(struct_name, field_name) => format!("struct {struct_name} does not have field {field_name}"),
            ErrorKind::MismatchedStructFields {
                struct_name,
                missing_fields,
                extra_fields,
            } => {
                let mut message = format!("mismatched fields for struct `{}`", struct_name);
                if !missing_fields.is_empty() {
                    message.push_str(&format!(
                        "\n  - missing fields: {}",
                        missing_fields.join(", ")
                    ));
                }
                if !extra_fields.is_empty() {
                    message.push_str(&format!(
                        "\n  - extra fields: {}",
                        extra_fields.join(", ")
                    ));
                }
                message
            },
            ErrorKind::InvalidCast(from, to) => format!("cannot cast type `{from}` to `{to}`"),
            ErrorKind::DuplicateSymbolsInInherentImpl(name, namespace) => {
                format!("symbol `{name}` defined multiple times in inherent impls for namespace {namespace}")
            },
            ErrorKind::InvalidPathQualifier => "path qualifier can only be used on the left side of a member access".to_string(),
            ErrorKind::OutsideOfLoop => "use of control flow keyword outside of loop".to_string(),
            ErrorKind::InvalidTypeReference(ty, given, expected) => {
                format!("type {ty} was given {given} generic parameters but expects {expected} generic parameters")
            },
            ErrorKind::MutatingImmutableData(ident) => format!("cannot mutable immutable data {ident}"),
            ErrorKind::ExpectedValue => "expected a value".to_string(),
            ErrorKind::PrivateMemberAccess(member, ty) => format!("member `{}` is private to type `{}`", member, ty)
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct Error {
    kind: ErrorKind,
    span: Span,
    source_lines: Vec<(String, usize)>,
}

pub type BoxedError = Box<Error>;

impl Error {
    pub fn new(kind: ErrorKind) -> BoxedError {
        boxed!(Error {
            kind,
            span: Span::default(),
            source_lines: vec![]
        })
    }

    pub fn from_one_error(kind: ErrorKind, span: Span, source_line: (String, usize)) -> BoxedError {
        boxed!(Error {
            kind,
            span,
            source_lines: vec![source_line]
        })
    }

    pub fn from_multiple_errors(
        kind: ErrorKind,
        span: Span,
        source_lines: Vec<(String, usize)>,
    ) -> BoxedError {
        boxed!(Error {
            kind,
            span,
            source_lines
        })
    }
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "[{}] {}", "error".red().bold(), self.kind.as_str())?;
        writeln!(
            f,
            "as found in [insert_file_here]:{}:{}",
            self.span.start_pos.line, self.span.start_pos.column
        )?;

        let mut used_numbers = vec![];
        for (content, number) in self.source_lines.iter() {
            if used_numbers.contains(number) {
                continue;
            } else {
                used_numbers.push(*number);
            }

            writeln!(f, "    {}", content)?;

            if *number == self.span.start_pos.line {
                writeln!(
                    f,
                    "    {}^{}^",
                    " ".repeat(self.span.start_pos.column - 1),
                    "^".repeat(
                        self.span
                            .end_pos
                            .column
                            .saturating_sub(self.span.start_pos.column)
                    )
                )?;
            }
        }

        Ok(())
    }
}

impl std::error::Error for Error {}


// utils/kind.rs
use colored::*;
use std::rc::Rc;

use crate::frontend::semantics::analyzer::PrimitiveKind;

pub const NOT_TOKEN: char = '!';
pub const BITWISE_NEGATE_TOKEN: char = '~';
pub const ADD_TOKEN: char = '+';
pub const SUB_TOKEN: char = '-';
pub const MUL_TOKEN: char = '*';
pub const DIV_TOKEN: char = '/';
pub const MOD_TOKEN: char = '%';
pub const BITWISE_AND_TOKEN: char = '&';
pub const BITWISE_OR_TOKEN: char = '|';
pub const BITWISE_XOR_TOKEN: char = '^';
pub const ASSIGNMENT_TOKEN: char = '=';
pub const GREATER_THAN_TOKEN: char = '>';
pub const LESS_THAN_TOKEN: char = '<';
pub const FIELD_ACCESS_TOKEN: char = '.';

pub const INT_TYPE: &str = "int";
pub const FLOAT_TYPE: &str = "float";
pub const BOOL_TYPE: &str = "bool";
pub const STRING_TYPE: &str = "string";
pub const CHAR_TYPE: &str = "char";
pub const VOID_TYPE: &str = "void"; // NOTE: Programs may not use this type.
pub const NEVER_TYPE: &str = "never"; // NOTE: Programs may not use this type.

pub const LET_KEYWORD: &str = "let";
pub const CONST_KEYWORD: &str = "const";
pub const ENUM_KEYWORD: &str = "enum";
pub const STRUCT_KEYWORD: &str = "struct";
pub const IMPL_KEYWORD: &str = "impl";
pub const TRUE_KEYWORD: &str = "true";
pub const FALSE_KEYWORD: &str = "false";
pub const FN_KEYWORD: &str = "fn";
pub const FOR_KEYWORD: &str = "for";
pub const WHILE_KEYWORD: &str = "while";
pub const RETURN_KEYWORD: &str = "return";
pub const BREAK_KEYWORD: &str = "break";
pub const CONTINUE_KEYWORD: &str = "continue";
pub const IF_KEYWORD: &str = "if";
pub const ELSE_KEYWORD: &str = "else";
pub const THIS_KEYWORD: &str = "this";
pub const PUBLIC_KEYWORD: &str = "public";
pub const PRIVATE_KEYWORD: &str = "private";
pub const TRAIT_KEYWORD: &str = "trait";
pub const TYPE_KEYWORD: &str = "type";
pub const MUT_KEYWORD: &str = "mut";
pub const AS_KEYWORD: &str = "as";

pub const END_OF_LINE: char = ';';
pub const OPEN_PARENTHESIS: char = '(';
pub const CLOSE_PARENTHESIS: char = ')';
pub const OPEN_BRACKET: char = '[';
pub const CLOSE_BRACKET: char = ']';
pub const OPEN_BRACE: char = '{';
pub const CLOSE_BRACE: char = '}';
pub const COMMA: char = ',';
pub const COLON: char = ':';

pub const STRING_DELIMITER: char = '"';
pub const CHAR_DELIMITER: char = '\'';

#[derive(Debug, Hash, Eq, Clone, Copy, PartialEq, strum_macros::EnumIter)]
pub enum Operation {
    // UNARY
    Not, // !
    Neg, // Negate, i.e. `-1`
    BitwiseNegate,

    // BINARY
    Plus,
    Minus,
    Mul,
    Exp,
    Div,
    Mod,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    RightBitShift,
    LeftBitShift,
    Assign,
    PlusEq,
    MinusEq,
    MulEq,
    ExpEq,
    DivEq,
    ModEq,
    BitwiseAndEq,
    BitwiseOrEq,
    BitwiseXorEq,
    RightBitShiftEq,
    LeftBitShiftEq,

    // CONDITIONAL
    And,
    Or,
    GreaterThan,
    Geq, // 
    LessThan,
    Leq,         // 
    Equivalence, // ==
    NotEqual,    // !=

    // CALL
    FieldAccess,
    FunctionCall,

    // POINTER OPS
    Dereference,
    ImmutableAddressOf,
    MutableAddressOf,

    // CAST
    As
}

impl Operation {
    pub fn is_unary(self) -> bool {
        matches!(
            self,
            Operation::Not
                | Operation::Neg
                | Operation::BitwiseNegate
                | Operation::Plus
                | Operation::Minus
                | Operation::Mul
                | Operation::BitwiseAnd
                | Operation::Dereference
                | Operation::ImmutableAddressOf
                | Operation::MutableAddressOf
        )
    }

    pub fn is_binary(self) -> bool {
        matches!(
            self,
            Operation::Plus
                | Operation::Minus
                | Operation::Mul
                | Operation::Exp
                | Operation::Div
                | Operation::Mod
                | Operation::BitwiseAnd
                | Operation::BitwiseOr
                | Operation::BitwiseXor
                | Operation::RightBitShift
                | Operation::LeftBitShift
                | Operation::Assign
                | Operation::PlusEq
                | Operation::MinusEq
                | Operation::MulEq
                | Operation::ExpEq
                | Operation::DivEq
                | Operation::ModEq
                | Operation::BitwiseAndEq
                | Operation::BitwiseOrEq
                | Operation::BitwiseXorEq
                | Operation::RightBitShiftEq
                | Operation::LeftBitShiftEq
        )
    }

    pub fn is_conditional(&self) -> bool {
        matches!(
            self,
            Operation::And
                | Operation::Or
                | Operation::GreaterThan
                | Operation::Geq
                | Operation::LessThan
                | Operation::Leq
                | Operation::Equivalence
                | Operation::NotEqual
        )
    }

    pub fn is_assignment(&self) -> bool {
        matches!(
            self,
            Operation::Assign
                | Operation::PlusEq
                | Operation::MinusEq
                | Operation::MulEq
                | Operation::ExpEq
                | Operation::DivEq
                | Operation::ModEq
                | Operation::BitwiseAndEq
                | Operation::BitwiseOrEq
                | Operation::BitwiseXorEq
                | Operation::RightBitShiftEq
                | Operation::LeftBitShiftEq
        )
    }

    pub fn binding_power(&self) -> (u8, u8) {
        match self {
            Operation::Assign
            | Operation::PlusEq
            | Operation::MinusEq
            | Operation::MulEq
            | Operation::ExpEq
            | Operation::DivEq
            | Operation::ModEq
            | Operation::BitwiseAndEq
            | Operation::BitwiseOrEq
            | Operation::BitwiseXorEq
            | Operation::RightBitShiftEq
            | Operation::LeftBitShiftEq
            | Operation::NotEqual => (1, 2),

            Operation::Or => (2, 3),

            Operation::And => (3, 4),

            Operation::Equivalence => (4, 5),

            Operation::GreaterThan | Operation::Geq | Operation::LessThan | Operation::Leq => (5, 6),

            Operation::BitwiseOr => (6, 7),

            Operation::BitwiseXor => (7, 8),

            Operation::BitwiseAnd => (8, 9),

            Operation::Plus | Operation::Minus => (9, 10),

            Operation::Mul | Operation::Div | Operation::Mod => (10, 11),

            Operation::LeftBitShift | Operation::RightBitShift => (11, 12),

            Operation::Exp => (12, 11),

            Operation::As => (13, 14),
            Operation::Not | Operation::Neg | Operation::BitwiseNegate => (13, 14),

            Operation::FunctionCall => (14, 0),
            Operation::FieldAccess => (14, 15),

            Operation::Dereference | Operation::ImmutableAddressOf | Operation::MutableAddressOf => (15, 16),
        }
    }

    /// Returns the trait name and if it is a binary operation
    pub fn to_trait_data(&self) -> Option<(String, bool)> {
        match self {
            Operation::Not => Some(("Not".to_string(), false)),
            Operation::Neg => Some(("Neg".to_string(), false)),
            Operation::BitwiseNegate => Some(("BitwiseNegate".to_string(), false)),
            Operation::Plus => Some(("Add".to_string(), true)),
            Operation::Minus => Some(("Subtract".to_string(), true)),
            Operation::Mul => Some(("Multiply".to_string(), true)),
            Operation::Exp => Some(("Exponentiate".to_string(), true)),
            Operation::Div => Some(("Divide".to_string(), true)),
            Operation::Mod => Some(("Modulo".to_string(), true)),
            Operation::BitwiseAnd => Some(("BitwiseAnd".to_string(), true)),
            Operation::BitwiseOr => Some(("BitwiseOr".to_string(), true)),
            Operation::BitwiseXor => Some(("BitwiseXor".to_string(), true)),
            Operation::RightBitShift => Some(("RightBitShift".to_string(), true)),
            Operation::LeftBitShift => Some(("LeftBitShift".to_string(), true)),
            Operation::PlusEq => Some(("AddAssign".to_string(), true)),
            Operation::MinusEq => Some(("SubtractAssign".to_string(), true)),
            Operation::MulEq => Some(("MultiplyAssign".to_string(), true)),
            Operation::ExpEq => Some(("ExponentiateAssign".to_string(), true)),
            Operation::DivEq => Some(("DivideAssign".to_string(), true)),
            Operation::ModEq => Some(("ModuloAssign".to_string(), true)),
            Operation::BitwiseAndEq => Some(("BitwiseAndAssign".to_string(), true)),
            Operation::BitwiseOrEq => Some(("BitwiseOrAssign".to_string(), true)),
            Operation::BitwiseXorEq => Some(("BitwiseXorAssign".to_string(), true)),
            Operation::RightBitShiftEq => Some(("RightBitShiftAssign".to_string(), true)),
            Operation::LeftBitShiftEq => Some(("LeftBitShiftAssign".to_string(), true)),
            Operation::NotEqual => Some(("NotEqual".to_string(), true)),
            Operation::And => Some(("And".to_string(), true)),
            Operation::Or => Some(("Or".to_string(), true)),
            Operation::GreaterThan => Some(("GreaterThan".to_string(), true)),
            Operation::Geq => Some(("GreaterThanOrEqual".to_string(), true)),
            Operation::LessThan => Some(("LessThan".to_string(), true)),
            Operation::Leq => Some(("LessThanOrEqual".to_string(), true)),
            Operation::Equivalence => Some(("Equivalence".to_string(), true)),
            Operation::FieldAccess => None,
            Operation::FunctionCall => None,
            Operation::Dereference => None,
            Operation::ImmutableAddressOf => None,
            Operation::MutableAddressOf => None,
            Operation::Assign => None,
            Operation::As => None
        }
    }

    /// Gives the output type for a default Operation implementation of a trait on a primitive type.
    pub fn to_default_trait_return_type(&self, primitive: PrimitiveKind) -> Option<PrimitiveKind> {
        use Operation::*;
        use PrimitiveKind::*;

        match primitive {
            Int => match self {
                Not => Some(Bool),
                Neg | BitwiseNegate => Some(Int),

                Plus | Minus | Mul | Div | Mod | Exp | BitwiseAnd | BitwiseOr | BitwiseXor
                | RightBitShift | LeftBitShift => Some(Int),

                And | Or | GreaterThan | Geq | LessThan | Leq | Equivalence | NotEqual => Some(Bool),

                PlusEq | MinusEq | MulEq | DivEq | ModEq | ExpEq | BitwiseAndEq | BitwiseOrEq
                | BitwiseXorEq | RightBitShiftEq | LeftBitShiftEq => Some(Void),

                Assign | FieldAccess | FunctionCall | Dereference | ImmutableAddressOf 
                | MutableAddressOf | As => None,
            },

            Float => match self {
                Not => Some(Bool),
                Neg => Some(Float),
                BitwiseNegate => None,

                Plus | Minus | Mul | Div | Mod | Exp => Some(Float),

                BitwiseAnd | BitwiseOr | BitwiseXor | RightBitShift | LeftBitShift => None,

                And | Or | GreaterThan | Geq | LessThan | Leq | Equivalence | NotEqual => Some(Bool),

                PlusEq | MinusEq | MulEq | DivEq | ModEq | ExpEq => Some(Void),

                Assign | BitwiseAndEq | BitwiseOrEq | BitwiseXorEq | RightBitShiftEq 
                | LeftBitShiftEq | FieldAccess | FunctionCall | Dereference 
                | ImmutableAddressOf | MutableAddressOf | As => None,
            },

            Bool => match self {
                Not => Some(Bool),
                And | Or | Equivalence | NotEqual => Some(Bool),

                Neg | Assign | BitwiseNegate | Plus | Minus | Mul | Div | Mod | Exp | PlusEq | MinusEq | MulEq
                | DivEq | ModEq | ExpEq | BitwiseAnd | BitwiseOr | BitwiseXor | BitwiseAndEq | BitwiseOrEq
                | BitwiseXorEq | GreaterThan | Geq | LessThan | Leq | RightBitShift | LeftBitShift
                | RightBitShiftEq | LeftBitShiftEq | FieldAccess | FunctionCall | Dereference
                | ImmutableAddressOf | MutableAddressOf | As => None,
            },

            String => match self {
                Plus => Some(String),
                Equivalence | NotEqual | GreaterThan | Geq | LessThan | Leq => Some(Bool),

                PlusEq => Some(Void),

                Neg | Not | BitwiseNegate | Minus | Mul | Div | Mod | Exp | MinusEq | MulEq | DivEq
                | ModEq | ExpEq | BitwiseAnd | BitwiseOr | BitwiseXor | BitwiseAndEq | BitwiseOrEq
                | BitwiseXorEq | RightBitShift | LeftBitShift | RightBitShiftEq | LeftBitShiftEq | And
                | Or | Assign | FieldAccess | FunctionCall | Dereference | ImmutableAddressOf
                | MutableAddressOf | As => None,
            },

            Char => match self {
                Equivalence | NotEqual | GreaterThan | Geq | LessThan | Leq => Some(Bool),

                Neg | Plus | Minus | Mul | Div | Mod | Exp | PlusEq | MinusEq | MulEq | DivEq | ModEq | ExpEq
                | BitwiseAnd | BitwiseOr | BitwiseXor | BitwiseAndEq | BitwiseOrEq | BitwiseXorEq
                | RightBitShift | LeftBitShift | RightBitShiftEq | LeftBitShiftEq | Not | BitwiseNegate
                | And | Or | Assign | FieldAccess | FunctionCall | Dereference | ImmutableAddressOf
                | MutableAddressOf | As => None,
            },

            Void | Never => None,
        }
    }
}

impl std::fmt::Display for Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            Operation::Not => NOT_TOKEN.to_string(),
            Operation::Neg => SUB_TOKEN.to_string(),
            Operation::BitwiseNegate => BITWISE_NEGATE_TOKEN.to_string(),

            Operation::Plus => ADD_TOKEN.to_string(),
            Operation::Minus => SUB_TOKEN.to_string(),
            Operation::Mul | Operation::Dereference => MUL_TOKEN.to_string(),
            Operation::Exp => format!("{}{}", MUL_TOKEN, MUL_TOKEN),
            Operation::Div => DIV_TOKEN.to_string(),
            Operation::Mod => MOD_TOKEN.to_string(),

            Operation::BitwiseAnd | Operation::ImmutableAddressOf => BITWISE_AND_TOKEN.to_string(),
            Operation::BitwiseOr => BITWISE_OR_TOKEN.to_string(),
            Operation::BitwiseXor => BITWISE_XOR_TOKEN.to_string(),
            Operation::RightBitShift => format!("{}{}", GREATER_THAN_TOKEN, GREATER_THAN_TOKEN),
            Operation::LeftBitShift => format!("{}{}", LESS_THAN_TOKEN, LESS_THAN_TOKEN),

            Operation::Assign => ASSIGNMENT_TOKEN.to_string(),
            Operation::PlusEq => format!("{}{}", ADD_TOKEN, ASSIGNMENT_TOKEN),
            Operation::MinusEq => format!("{}{}", SUB_TOKEN, ASSIGNMENT_TOKEN),
            Operation::MulEq => format!("{}{}", MUL_TOKEN, ASSIGNMENT_TOKEN),
            Operation::ExpEq => format!("{}{}{}", MUL_TOKEN, MUL_TOKEN, ASSIGNMENT_TOKEN),
            Operation::DivEq => format!("{}{}", DIV_TOKEN, ASSIGNMENT_TOKEN),
            Operation::ModEq => format!("{}{}", MOD_TOKEN, ASSIGNMENT_TOKEN),
            Operation::BitwiseAndEq => format!("{}{}", BITWISE_AND_TOKEN, ASSIGNMENT_TOKEN),
            Operation::BitwiseOrEq => format!("{}{}", BITWISE_OR_TOKEN, ASSIGNMENT_TOKEN),
            Operation::BitwiseXorEq => format!("{}{}", BITWISE_XOR_TOKEN, ASSIGNMENT_TOKEN),
            Operation::RightBitShiftEq => {
                format!("{}{}{}", GREATER_THAN_TOKEN, GREATER_THAN_TOKEN, ASSIGNMENT_TOKEN)
            }
            Operation::LeftBitShiftEq => {
                format!("{}{}{}", LESS_THAN_TOKEN, LESS_THAN_TOKEN, ASSIGNMENT_TOKEN)
            }
            Operation::NotEqual => format!("{}{}", NOT_TOKEN, ASSIGNMENT_TOKEN),

            Operation::And => format!("{}{}", BITWISE_AND_TOKEN, BITWISE_AND_TOKEN),
            Operation::Or => format!("{}{}", BITWISE_OR_TOKEN, BITWISE_OR_TOKEN),
            Operation::GreaterThan => GREATER_THAN_TOKEN.to_string(),
            Operation::Geq => format!("{}{}", GREATER_THAN_TOKEN, ASSIGNMENT_TOKEN),
            Operation::LessThan => LESS_THAN_TOKEN.to_string(),
            Operation::Leq => format!("{}{}", LESS_THAN_TOKEN, ASSIGNMENT_TOKEN),
            Operation::Equivalence => format!("{}{}", ASSIGNMENT_TOKEN, ASSIGNMENT_TOKEN),

            Operation::FieldAccess => FIELD_ACCESS_TOKEN.to_string(),
            Operation::FunctionCall => "()".to_string(),
            Operation::MutableAddressOf => "&mut".to_string(),

            Operation::As => AS_KEYWORD.to_string()
        };

        write!(f, "{}", s)
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum NumberKind {
    // INTEGERS
    Decimal,
    Binary,
    Octal,
    Hex,

    // FLOATS
    Float,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum LoopKind {
    For,
    While,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ControlFlowKind {
    Return,
    Break,
    Continue,
    Throw,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum KeywordKind {
    Int,
    Float,
    String,
    Bool,
    Char,
    If,
    Else,
    While,
    For,
    Break,
    Continue,
    Return,
    Throw,
    Fn,
    Struct,
    Impl,
    Let,
    Const,
    Enum,
    Public,
    Private,
    This,
    Trait,
    Type,
    Mut
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum QualifierKind {
    Public,
    Private,
}

impl std::fmt::Display for QualifierKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            QualifierKind::Public => write!(f, "public"),
            QualifierKind::Private => write!(f, "private"),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TokenKind {
    Identifier,
    Operator(Operation),
    NumberLiteral(NumberKind),
    BooleanLiteral,
    StringLiteral,
    CharLiteral,
    Keyword(KeywordKind),
    Semicolon,
    OpenParenthesis,
    CloseParenthesis,
    OpenBracket,
    CloseBracket,
    OpenBrace,
    CloseBrace,
    Comma,
    Colon,
    EndOfFile,
}

pub const SYNC_TOKENS: [TokenKind; 16] = [
    TokenKind::Keyword(KeywordKind::If),
    TokenKind::Keyword(KeywordKind::For),
    TokenKind::Keyword(KeywordKind::While),
    TokenKind::Keyword(KeywordKind::Return),
    TokenKind::Keyword(KeywordKind::Break),
    TokenKind::Keyword(KeywordKind::Continue),
    TokenKind::Keyword(KeywordKind::Let),
    TokenKind::Keyword(KeywordKind::Const),
    TokenKind::Keyword(KeywordKind::Fn),
    TokenKind::Keyword(KeywordKind::Struct),
    TokenKind::Keyword(KeywordKind::Enum),
    TokenKind::Keyword(KeywordKind::Impl),
    TokenKind::Keyword(KeywordKind::Trait),
    TokenKind::Keyword(KeywordKind::Type),
    TokenKind::Keyword(KeywordKind::Public),
    TokenKind::Keyword(KeywordKind::Private),
];

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Position {
    pub line: usize,
    pub column: usize,
}

impl Default for Position {
    fn default() -> Self {
        Position { line: 1, column: 1 }
    }
}

#[derive(Default, Clone, Copy, PartialEq)]
pub struct Span {
    pub start: usize,
    pub end: usize,
    pub start_pos: Position,
    pub end_pos: Position,
}

impl std::fmt::Debug for Span {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}..{} | {}:{}  {}:{}",
            self.start,
            self.end,
            self.start_pos.line,
            self.start_pos.column,
            self.end_pos.line,
            self.end_pos.column
        )
    }
}

impl std::fmt::Display for Span {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "starting line {}, starting col {} | span {}..{} | ending line {}, ending col {}",
            self.start_pos.line,
            self.start_pos.column,
            self.start,
            self.end,
            self.end_pos.line,
            self.end_pos.column
        )
    }
}

impl Span {
    pub fn set_end_from_values(mut self, index: usize, line: usize, column: usize) -> Span {
        self.end = index;
        self.end_pos = Position { line, column };

        self
    }

    pub fn set_end_from_span(mut self, span: Span) -> Span {
        self.end = span.end;
        self.end_pos = span.end_pos;

        self
    }

    pub fn get_lines(&self, lines: Rc<Vec<String>>) -> Vec<(String, usize)> {
        let mut ret: Vec<(String, usize)> = vec![];

        for i in self.start_pos.line..=self.end_pos.line {
            ret.push((lines[i - 1].clone(), i));
        }

        ret
    }

    pub fn get_all_lines(lines: Rc<Vec<String>>, spans: &[Span]) -> Vec<(String, usize)> {
        let mut ret = vec![];
        for span in spans.iter() {
            ret.extend(span.get_lines(lines.clone()));
        }

        return ret;
    }
}

#[derive(Debug, Clone)]
pub struct Token {
    /// The true value in source.
    value: String,
    /// The type of token.
    token_kind: TokenKind,
    /// Details about the token's placement in source.
    span: Span,
}

impl Token {
    pub fn new(value: String, token_type: TokenKind, span: Span) -> Token {
        Token {
            value,
            token_kind: token_type,
            span,
        }
    }

    pub fn get_value(&self) -> &String {
        &self.value
    }

    pub fn get_token_kind(&self) -> TokenKind {
        self.token_kind
    }

    pub fn get_span(&self) -> Span {
        self.span
    }
}

impl std::fmt::Display for TokenKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let token_type_str = match self {
            TokenKind::Identifier => "Identifier".cyan(),
            TokenKind::Operator(op) => format!("Operator::{:?}", op).bright_magenta(),
            TokenKind::NumberLiteral(n) => format!("Number::{:?}", n).blue(),
            TokenKind::BooleanLiteral => "Boolean".magenta(),
            TokenKind::StringLiteral => "String".green(),
            TokenKind::CharLiteral => "Character".green(),
            TokenKind::Keyword(keyword) => match keyword {
                KeywordKind::Int => "Keyword::Int".cyan(),
                KeywordKind::Float => "Keyword::Float".cyan(),
                KeywordKind::String => "Keyword::String".cyan(),
                KeywordKind::Bool => "Keyword::Bool".cyan(),
                KeywordKind::Char => "Keyword::Char".cyan(),
                KeywordKind::If => "Keyword::If".yellow(),
                KeywordKind::Else => "Keyword::Else".yellow(),
                KeywordKind::While => "Keyword::While".yellow(),
                KeywordKind::For => "Keyword::For".yellow(),
                KeywordKind::Break => "Keyword::Break".red(),
                KeywordKind::Continue => "Keyword::Continue".red(),
                KeywordKind::Return => "Keyword::Return".red(),
                KeywordKind::Throw => "Keyword::Throw".red(),
                KeywordKind::Fn => "Keyword::Fn".green(),
                KeywordKind::Struct => "Keyword::Struct".green(),
                KeywordKind::Let => "Keyword::Let".green(),
                KeywordKind::Const => "Keyword::Const".green(),
                KeywordKind::Mut => "Keyword::Mut".green(),
                KeywordKind::Enum => "Keyword::Enum".green(),
                KeywordKind::Public => "Keyword::Public".blue(),
                KeywordKind::Private => "Keyword::Private".blue(),
                KeywordKind::This => "Keyword::This".blue(),
                KeywordKind::Impl => "Keyword::Impl".purple(),
                KeywordKind::Trait => "Keyword::Trait".purple(),
                KeywordKind::Type => "Keyword::Type".purple()
            },
            TokenKind::Semicolon => "Semicolon".dimmed(),
            TokenKind::OpenParenthesis => "OpenParen".dimmed(),
            TokenKind::CloseParenthesis => "CloseParen".dimmed(),
            TokenKind::OpenBracket => "OpenBracket".dimmed(),
            TokenKind::CloseBracket => "CloseBracket".dimmed(),
            TokenKind::OpenBrace => "OpenCurly".dimmed(),
            TokenKind::CloseBrace => "CloseCurly".dimmed(),
            TokenKind::Comma => "Comma".dimmed(),
            TokenKind::Colon => "Colon".dimmed(),
            TokenKind::EndOfFile => "<EOF>".into(),
        };

        write!(f, "{}", token_type_str)
    }
}

impl std::fmt::Display for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{} ({}) at [{}]",
            self.value.bold(),
            self.get_token_kind(),
            self.span
        )
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ReferenceKind {
    Value,
    Reference,
    MutableReference,
}

