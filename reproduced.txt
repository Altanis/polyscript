// frontend/ast.rs
use crate::{
    middle::semantic_analyzer::{ScopeId, SymbolTable, Type, TypeSymbol, ValueSymbol, ValueSymbolId},
    utils::kind::*,
};
use colored::*;
use indexmap::IndexMap;

/// The various denominations of an AstNode.
#[derive(Debug, Clone)]
pub enum AstNodeKind {
    IntegerLiteral(i64),
    FloatLiteral(f64),
    BooleanLiteral(bool),
    StringLiteral(String),
    CharLiteral(char),

    /// A named entity with no semantic meaning.
    Identifier(String),
    VariableDeclaration {
        name: String,
        mutable: bool,
        type_annotation: Option<BoxedAstNode>,
        initializer: Option<BoxedAstNode>,
    },

    UnaryOperation {
        operator: Operation,
        operand: BoxedAstNode,
    },
    BinaryOperation {
        operator: Operation,
        left: BoxedAstNode,
        right: BoxedAstNode,
    },
    ConditionalOperation {
        operator: Operation,
        left: BoxedAstNode,
        right: BoxedAstNode,
    },

    // A sequence of statements encapsulated by braces.
    Block(Vec<AstNode>),
    IfStatement {
        condition: BoxedAstNode,
        then_branch: BoxedAstNode,
        else_if_branches: Vec<(BoxedAstNode, BoxedAstNode)>,
        else_branch: Option<BoxedAstNode>,
    },
    ForLoop {
        initializer: Option<BoxedAstNode>,
        condition: Option<BoxedAstNode>,
        increment: Option<BoxedAstNode>,
        body: BoxedAstNode,
    },
    WhileLoop {
        condition: BoxedAstNode,
        body: BoxedAstNode,
    },
    Return(Option<BoxedAstNode>),
    Break,
    Continue,

    /// An expression or declaration that takes inputs and returns an output.
    Function {
        qualifier: Option<QualifierKind>,
        name: String,
        generic_parameters: Vec<AstNode>,
        parameters: Vec<AstNode>,
        return_type: Option<BoxedAstNode>,
        instance: Option<ReferenceKind>,
        body: Option<BoxedAstNode>,
    },
    /// A type that denotes the signature of a function.
    FunctionPointer {
        params: Vec<AstNode>,
        return_type: Option<BoxedAstNode>,
    },
    /// A parameter inside a function declaration or expression.
    FunctionParameter {
        name: String,
        type_annotation: BoxedAstNode,
        initializer: Option<BoxedAstNode>,
        mutable: bool,
    },

    StructDeclaration {
        name: String,
        generic_parameters: Vec<AstNode>,
        fields: Vec<AstNode>,
    },
    StructField {
        qualifier: QualifierKind,
        name: String,
        type_annotation: BoxedAstNode,
    },
    StructLiteral {
        name: String,
        fields: IndexMap<String, AstNode>,
    },

    EnumDeclaration {
        name: String,
        variants: IndexMap<String, (AstNode, Option<AstNode>)>,
    },
    EnumVariant(String),

    ImplDeclaration {
        generic_parameters: Vec<AstNode>,
        type_reference: BoxedAstNode,
        trait_node: Option<BoxedAstNode>,
        associated_constants: Vec<AstNode>,
        associated_functions: Vec<AstNode>,
        associated_types: Vec<AstNode>,
    },
    AssociatedConstant {
        qualifier: QualifierKind,
        name: String,
        type_annotation: Option<BoxedAstNode>,
        initializer: BoxedAstNode,
    },
    AssociatedType {
        qualifier: QualifierKind,
        name: String,
        value: BoxedAstNode,
    },

    ///`this`
    SelfValue,
    /// `Self`, used as the type annotation for `this`, `&this`, and `&mut this`
    /// in an associated function.
    SelfType(ReferenceKind),

    /// A member access operation (i.e. `x.y`).
    FieldAccess {
        left: BoxedAstNode,
        right: BoxedAstNode,
    },
    /// A function call (i.e. `f()`).
    FunctionCall {
        function: BoxedAstNode,
        arguments: Vec<AstNode>,
    },

    TraitDeclaration {
        name: String,
        generic_parameters: Vec<AstNode>,
        types: Vec<AstNode>,
        constants: Vec<AstNode>,
        signatures: Vec<AstNode>,
    },
    TraitConstant {
        name: String,
        type_annotation: BoxedAstNode,
    },
    TraitType(String),

    GenericParameter {
        name: String,
        constraints: Vec<String>,
    },

    TypeReference {
        type_name: String,
        generic_types: Vec<AstNode>,
        reference_kind: ReferenceKind,
    },
    TypeDeclaration {
        name: String,
        generic_parameters: Vec<AstNode>,
        value: BoxedAstNode,
    },

    // PROGRAM //
    Program(Vec<AstNode>),
}

#[derive(Debug, Clone)]
pub struct AstNode {
    /// The type of node.
    pub kind: AstNodeKind,
    /// The location of the node in the source file.
    pub span: Span,
    /// A pointer to the value it holds in the symbol table.
    pub value_id: Option<ValueSymbolId>,
    /// A pointer to the type it holds in the symbol table.
    pub type_id: Option<Type>,
    /// The scope the node lives in.
    pub scope_id: Option<ScopeId>,
}

pub type BoxedAstNode = Box<AstNode>;

impl AstNode {
    pub fn get_value_symbol<'a>(&self, symbol_table: &'a SymbolTable) -> Option<&'a ValueSymbol> {
        if let Some(id) = self.value_id {
            return symbol_table.get_value_symbol(id);
        }

        None
    }

    pub fn get_value_symbol_mut<'a>(&self, symbol_table: &'a mut SymbolTable) -> Option<&'a mut ValueSymbol> {
        if let Some(id) = self.value_id {
            return symbol_table.get_value_symbol_mut(id);
        }

        None
    }

    pub fn get_type_symbol<'a>(&self, symbol_table: &'a SymbolTable) -> Option<&'a TypeSymbol> {
        if let Some(id) = self.value_id {
            return symbol_table.get_type_symbol(id);
        }

        None
    }

    pub fn get_type_symbol_mut<'a>(&self, symbol_table: &'a mut SymbolTable) -> Option<&'a mut TypeSymbol> {
        if let Some(id) = self.value_id {
            return symbol_table.get_type_symbol_mut(id);
        }

        None
    }

    pub fn get_name(&self) -> Option<String> {
        match &self.kind {
            AstNodeKind::Identifier(name) => Some(name.clone()),

            AstNodeKind::VariableDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::Function { name, .. } => {
                if name.is_empty() {
                    None
                } else {
                    Some(name.clone())
                }
            }
            AstNodeKind::FunctionParameter { name, .. } => Some(name.clone()),

            AstNodeKind::StructDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::StructField { name, .. } => Some(name.clone()),
            AstNodeKind::StructLiteral { name, .. } => Some(name.clone()),

            AstNodeKind::EnumDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::EnumVariant(name) => Some(name.clone()),

            AstNodeKind::TraitDeclaration { name, .. } => Some(name.clone()),
            AstNodeKind::TraitConstant { name, .. } => Some(name.clone()),
            AstNodeKind::TraitType(name) => Some(name.clone()),

            AstNodeKind::AssociatedConstant { name, .. } => Some(name.clone()),
            AstNodeKind::AssociatedType { name, .. } => Some(name.clone()),

            AstNodeKind::GenericParameter { name, .. } => Some(name.clone()),

            AstNodeKind::TypeReference { type_name, .. } => Some(type_name.clone()),
            AstNodeKind::TypeDeclaration { name, .. } => Some(name.clone()),

            _ => None,
        }
    }
}

impl std::fmt::Display for AstNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.fmt_with_indent(f, 0)
    }
}

impl AstNode {
    fn fmt_with_indent(&self, f: &mut std::fmt::Formatter<'_>, indent: usize) -> std::fmt::Result {
        let indent_str = " ".repeat(indent);
        let child_indent = indent + 4;

        match &self.kind {
            AstNodeKind::Program(nodes) => {
                let header = format!(
                    "{} ({} top-level items)",
                    "Program".bright_blue().bold(),
                    nodes.len()
                );
                writeln!(f, "{}", header)?;
                for node in nodes {
                    node.fmt_with_indent(f, indent)?;
                    writeln!(f)?;
                }
            }
            AstNodeKind::IntegerLiteral(val) => write!(f, "{}{}", indent_str, val.to_string().blue())?,
            AstNodeKind::FloatLiteral(val) => write!(f, "{}{}", indent_str, val.to_string().blue())?,
            AstNodeKind::BooleanLiteral(val) => write!(f, "{}{}", indent_str, val.to_string().magenta())?,
            AstNodeKind::StringLiteral(s) => write!(f, "{}{}", indent_str, format!("\"{s}\"").green())?,
            AstNodeKind::CharLiteral(c) => write!(f, "{}\'{}\'", indent_str, c.to_string().red())?,
            AstNodeKind::Identifier(name) => write!(f, "{}{}", indent_str, name.yellow())?,
            AstNodeKind::VariableDeclaration {
                mutable,
                name,
                type_annotation,
                initializer,
            } => {
                write!(f, "{}", indent_str)?;
                let decl_type = if *mutable {
                    "let".bright_green()
                } else {
                    "const".green()
                };
                write!(f, "{} {}", decl_type, name.yellow())?;
                if let Some(ty) = type_annotation {
                    write!(f, ": {}", ty)?;
                }
                if let Some(init) = initializer {
                    write!(f, " = {}", init)?;
                }
            }
            AstNodeKind::UnaryOperation { operator, operand } => {
                write!(f, "{}", indent_str)?;
                write!(f, "{}{}", operator, operand)?
            }
            AstNodeKind::BinaryOperation {
                operator,
                left,
                right,
            } => {
                write!(f, "{}(", indent_str)?;
                left.fmt_with_indent(f, 0)?;
                write!(f, " {} ", operator)?;
                right.fmt_with_indent(f, 0)?;
                write!(f, ")")?
            }
            AstNodeKind::ConditionalOperation {
                operator,
                left,
                right,
            } => {
                write!(f, "{}(", indent_str)?;
                left.fmt_with_indent(f, 0)?;
                write!(f, " {} ", operator)?;
                right.fmt_with_indent(f, 0)?;
                write!(f, ")")?
            }

            AstNodeKind::Block(nodes) => {
                write!(f, "{}", "{".dimmed())?;
                if !nodes.is_empty() {
                    writeln!(f)?;
                    for node in nodes {
                        write!(f, "{}", " ".repeat(child_indent))?;
                        node.fmt_with_indent(f, child_indent)?;
                        writeln!(f)?;
                    }
                    write!(f, "{}", indent_str)?;
                }
                write!(f, "{}", " ".repeat(child_indent))?;
                write!(f, "{}", "}".dimmed())?
            }

            AstNodeKind::Function {
                qualifier,
                name,
                generic_parameters,
                parameters,
                return_type,
                body,
                ..
            } => {
                write!(f, "{}", indent_str)?;
                if let Some(q) = qualifier {
                    write!(
                        f,
                        "{} ",
                        match q {
                            QualifierKind::Public => "public".purple(),
                            QualifierKind::Private => "private".purple(),
                        }
                    )?;
                }
                write!(
                    f,
                    "{} {}",
                    "fn".bright_blue(),
                    if name.is_empty() {
                        "".white()
                    } else {
                        name.yellow()
                    }
                )?;

                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0)?;
                    }
                    write!(f, "]")?;
                }

                write!(f, "(")?;
                for (i, param) in parameters.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    param.fmt_with_indent(f, 0)?;
                }
                write!(f, ")")?;

                if let Some(ret_ty) = return_type {
                    write!(f, ": {}", ret_ty)?;
                }

                if let Some(b) = body {
                    write!(f, " ")?;
                    b.fmt_with_indent(f, indent)?;
                } else {
                    write!(f, ";")?;
                }
            }

            AstNodeKind::ImplDeclaration {
                generic_parameters,
                type_reference: name,
                trait_node: trait_name,
                associated_constants,
                associated_functions,
                associated_types,
            } => {
                write!(f, "{}{} ", indent_str, "impl".bright_cyan())?;
                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0)?;
                    }
                    write!(f, "]")?;
                }

                if let Some(trait_name) = trait_name {
                    write!(f, "{} for ", trait_name)?;
                }
                write!(f, "{}", name)?;

                writeln!(f, " {}", "{".dimmed())?;
                for type_node in associated_types {
                    writeln!(f, "    {}", type_node)?;
                }
                for constant in associated_constants {
                    writeln!(f, "    {}", constant)?;
                }
                for function in associated_functions {
                    writeln!(f, "    {}", function)?;
                }
                write!(f, "{}", "}".dimmed())?
            }

            AstNodeKind::AssociatedType {
                qualifier,
                name,
                value,
            } => {
                write!(
                    f,
                    "{} ",
                    match qualifier {
                        QualifierKind::Public => "public",
                        QualifierKind::Private => "private",
                    }
                    .purple()
                )?;

                write!(f, "type ")?;
                write!(f, "{}", name.yellow())?;
                write!(f, " = {}", value)?;
            }

            AstNodeKind::AssociatedConstant {
                qualifier,
                name,
                type_annotation,
                initializer,
            } => {
                write!(
                    f,
                    "{} ",
                    match qualifier {
                        QualifierKind::Public => "public",
                        QualifierKind::Private => "private",
                    }
                    .purple()
                )?;

                write!(f, "const ")?;
                write!(f, "{}", name.yellow())?;

                if let Some(type_annotation) = type_annotation {
                    write!(f, ": {}", type_annotation)?;
                }

                write!(f, " = {}", initializer)?;
            }

            AstNodeKind::SelfValue => write!(f, "{}this", indent_str)?,
            AstNodeKind::SelfType(operation) => {
                let operation_str = match operation {
                    ReferenceKind::Reference => "&",
                    ReferenceKind::MutableReference => "&mut ",
                    ReferenceKind::Value => "",
                };

                write!(f, "{}{operation_str}Self", indent_str)?
            }

            AstNodeKind::IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => {
                write!(f, "{}if (", indent_str)?;
                condition.fmt_with_indent(f, 0)?;
                write!(f, ") ")?;
                then_branch.fmt_with_indent(f, indent)?; // Same indent for block

                for (cond, branch) in else_if_branches {
                    write!(f, "{}else if (", indent_str)?;
                    cond.fmt_with_indent(f, 0)?;
                    write!(f, ") ")?;
                    branch.fmt_with_indent(f, indent)?; // Same indent for block
                }

                if let Some(else_node) = else_branch {
                    write!(f, "{}else ", indent_str)?;
                    else_node.fmt_with_indent(f, indent)?; // Same indent for block
                }
            }

            AstNodeKind::ForLoop {
                initializer,
                condition,
                increment,
                body,
            } => {
                write!(f, "{}for (", indent_str)?;
                if let Some(init) = initializer {
                    init.fmt_with_indent(f, 0)?;
                }
                write!(f, "; ")?;
                if let Some(cond) = condition {
                    cond.fmt_with_indent(f, 0)?;
                }
                write!(f, "; ")?;
                if let Some(inc) = increment {
                    inc.fmt_with_indent(f, 0)?;
                }
                write!(f, ") ")?;
                body.fmt_with_indent(f, indent)? // Same indent for block
            }

            AstNodeKind::WhileLoop { condition, body } => {
                write!(f, "{}while (", indent_str)?;
                condition.fmt_with_indent(f, 0)?;
                write!(f, ") ")?;
                body.fmt_with_indent(f, indent)? // Same indent for block
            }

            AstNodeKind::Return(Some(expr)) => {
                write!(f, "{}return ", indent_str)?;
                expr.fmt_with_indent(f, 0)?
            }
            AstNodeKind::Return(None) => write!(f, "{}return", indent_str)?,
            AstNodeKind::Break => write!(f, "{}break", indent_str)?,
            AstNodeKind::Continue => write!(f, "{}continue", indent_str)?,

            AstNodeKind::FunctionParameter {
                name,
                type_annotation,
                initializer,
                mutable,
            } => {
                write!(f, "{}", indent_str)?;
                write!(
                    f,
                    "{}{}: {}",
                    if *mutable { "mut ".purple() } else { "".white() },
                    name.yellow(),
                    type_annotation
                )?;
                if let Some(default) = initializer {
                    write!(f, " = ")?;
                    default.fmt_with_indent(f, 0)?;
                }
            }

            AstNodeKind::StructDeclaration {
                name,
                generic_parameters,
                fields,
            } => {
                write!(f, "{}struct {}", indent_str, name.yellow())?;

                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0)?;
                    }
                    write!(f, "]")?;
                }

                writeln!(f, " {}", "{".dimmed())?;

                for field in fields {
                    field.fmt_with_indent(f, child_indent)?;
                    writeln!(f)?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::StructField {
                qualifier,
                name,
                type_annotation,
            } => {
                write!(f, "{}", indent_str)?;
                write!(
                    f,
                    "{} ",
                    match qualifier {
                        QualifierKind::Public => "public".purple(),
                        QualifierKind::Private => "private".purple(),
                    }
                )?;

                write!(f, "{}", name.yellow())?;
                write!(f, ": {}", type_annotation)?;
            }
            AstNodeKind::StructLiteral { name, fields } => {
                write!(f, "{}{}{}", indent_str, name.yellow(), " ".dimmed())?;
                write!(f, "{}", "{".dimmed())?;

                for (i, (field_name, expr)) in fields.iter().enumerate() {
                    write!(f, " ")?;
                    write!(f, "{}: ", field_name.yellow())?;
                    write!(f, "{}", expr)?;

                    write!(f, "{}", if i + 1 < fields.len() { "," } else { " " })?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::EnumDeclaration { name, variants } => {
                write!(f, "{}enum {}", indent_str, name.yellow())?;
                writeln!(f, " {}", "{".dimmed())?;

                for (_, (variant, expr)) in variants {
                    write!(f, "{}", " ".repeat(child_indent + 4))?;
                    write!(f, "{}", variant)?;

                    if let Some(expr) = expr {
                        write!(f, " = {}", expr)?;
                    }
                    writeln!(f)?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::EnumVariant(name) => write!(f, "{}", name)?,
            AstNodeKind::TypeReference {
                type_name,
                generic_types,
                reference_kind,
            } => {
                let type_name = match reference_kind {
                    ReferenceKind::Value => type_name.clone(),
                    ReferenceKind::MutableReference => format!("&mut {type_name}"),
                    ReferenceKind::Reference => format!("&{type_name}"),
                };

                write!(f, "{}{}", indent_str, type_name.bright_blue())?;
                if !generic_types.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_types.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0)?;
                    }
                    write!(f, "]")?;
                }
            }
            AstNodeKind::TypeDeclaration {
                name,
                generic_parameters,
                value,
            } => {
                write!(f, "{}", "type ".purple())?;
                write!(f, "{}", name)?;

                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0)?;
                    }
                    write!(f, "]")?;
                }

                write!(f, "= ")?;
                write!(f, "{}", value)?
            }
            AstNodeKind::FieldAccess { left, right } => {
                write!(f, "{}(", indent_str)?;
                left.fmt_with_indent(f, 0)?;
                write!(f, ".")?;
                right.fmt_with_indent(f, 0)?;
                write!(f, ")")?
            }
            AstNodeKind::FunctionCall { function, arguments } => {
                write!(f, "{}", indent_str)?;
                function.fmt_with_indent(f, 0)?;
                write!(f, "(")?;
                for (i, param) in arguments.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    param.fmt_with_indent(f, 0)?;
                }
                write!(f, ")")?
            }
            AstNodeKind::TraitDeclaration {
                name,
                generic_parameters,
                signatures,
                types,
                constants,
            } => {
                write!(f, "{}trait", indent_str)?;
                if !generic_parameters.is_empty() {
                    write!(f, "[")?;
                    for (i, param) in generic_parameters.iter().enumerate() {
                        if i > 0 {
                            write!(f, ", ")?;
                        }
                        param.fmt_with_indent(f, 0)?;
                    }
                    write!(f, "]")?;
                }

                write!(f, " {}", name.yellow())?;

                writeln!(f, " {}", "{".dimmed())?;

                for type_node in types {
                    write!(f, "{}    ", indent_str)?;
                    type_node.fmt_with_indent(f, 0)?;
                    writeln!(f)?;
                }

                for constant in constants {
                    write!(f, "{}    ", indent_str)?;
                    constant.fmt_with_indent(f, 0)?;
                    writeln!(f)?;
                }

                for signature in signatures {
                    signature.fmt_with_indent(f, child_indent)?;
                    writeln!(f)?;
                }

                write!(f, "{}{}", indent_str, "}".dimmed())?
            }
            AstNodeKind::TraitConstant {
                name,
                type_annotation,
            } => {
                write!(f, "{}const {}: {}", indent_str, name.yellow(), type_annotation)?;
            }
            AstNodeKind::TraitType(name) => {
                write!(f, "{}type {}", indent_str, name.bright_blue())?;
            }
            AstNodeKind::GenericParameter { name, constraints } => {
                write!(f, "{}{}", indent_str, name.yellow())?;

                if !constraints.is_empty() {
                    write!(f, ": ")?;
                }

                for (i, constraint) in constraints.iter().enumerate() {
                    write!(f, "{}", constraint)?;
                    if i + 1 < constraints.len() {
                        write!(f, " + ")?;
                    }
                }
            }
            AstNodeKind::FunctionPointer { params, return_type } => {
                write!(f, "{}{}", indent_str, "fn".bright_blue())?;
                write!(f, "(")?;
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    param.fmt_with_indent(f, 0)?;
                }
                write!(f, ")")?;

                if let Some(return_type) = return_type {
                    write!(f, ": {}", return_type)?;
                }
            }
        }

        if let Some(id) = &self.type_id {
            write!(f, " {}", format_args!("[{}]", id))?;
        }

        if let Some(id) = self.value_id {
            write!(f, " [Symbol({})]", id)?;
        }

        Ok(())
    }
}

impl AstNode {
    pub fn children_mut(&mut self) -> Vec<&mut AstNode> {
        use AstNodeKind::*;

        match &mut self.kind {
            IntegerLiteral(_) | FloatLiteral(_) | BooleanLiteral(_) | StringLiteral(_) | CharLiteral(_)
            | Identifier(_) | EnumVariant(_) | SelfValue | SelfType(_) => vec![],

            Program(statements) => statements.iter_mut().collect(),

            VariableDeclaration {
                type_annotation,
                initializer,
                ..
            } => {
                let mut children = vec![];

                if let Some(node) = type_annotation.as_mut() {
                    children.push(node.as_mut());
                }

                if let Some(node) = initializer.as_mut() {
                    children.push(node.as_mut());
                }

                children
            }

            UnaryOperation { operand, .. } => vec![operand.as_mut()],

            BinaryOperation { left, right, .. } | ConditionalOperation { left, right, .. } => {
                vec![left.as_mut(), right.as_mut()]
            }

            Block(statements) => statements.iter_mut().collect(),

            IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => {
                let mut children = vec![];

                children.push(condition.as_mut());
                children.push(then_branch.as_mut());

                for (elif_cond, elif_branch) in else_if_branches.iter_mut() {
                    children.push(elif_cond.as_mut());
                    children.push(elif_branch.as_mut());
                }

                if let Some(else_node) = else_branch.as_mut() {
                    children.push(else_node.as_mut());
                }

                children
            }

            ForLoop {
                initializer,
                condition,
                increment,
                body,
            } => {
                let mut children = vec![];

                if let Some(init) = initializer.as_mut() {
                    children.push(init.as_mut());
                }

                if let Some(cond) = condition.as_mut() {
                    children.push(cond.as_mut());
                }

                if let Some(inc) = increment.as_mut() {
                    children.push(inc.as_mut());
                }

                children.push(body.as_mut());

                children
            }

            WhileLoop { condition, body } => vec![condition.as_mut(), body.as_mut()],

            Return(opt_expr) => {
                if let Some(expr) = opt_expr.as_mut() {
                    vec![expr.as_mut()]
                } else {
                    vec![]
                }
            }

            Break | Continue => vec![],

            Function {
                generic_parameters,
                parameters,
                return_type,
                body,
                ..
            } => {
                let mut children = vec![];

                children.extend(generic_parameters.iter_mut());
                children.extend(parameters.iter_mut());

                if let Some(rt) = return_type.as_mut() {
                    children.push(rt.as_mut());
                }

                if let Some(b) = body.as_mut() {
                    children.push(b.as_mut());
                }

                children
            }

            FunctionPointer { params, return_type } => {
                let mut children = vec![];

                for p in params.iter_mut() {
                    children.push(p);
                }

                if let Some(ret) = return_type.as_mut() {
                    children.push(ret.as_mut());
                }

                children
            }

            FunctionParameter {
                type_annotation,
                initializer,
                ..
            } => {
                let mut children = vec![];
                children.push(type_annotation.as_mut());

                if let Some(init) = initializer.as_mut() {
                    children.push(init.as_mut());
                }

                children
            }

            StructDeclaration {
                generic_parameters,
                fields,
                ..
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                for field_node in fields.iter_mut() {
                    children.push(field_node);
                }

                children
            }

            StructField { type_annotation, .. } => vec![type_annotation.as_mut()],

            StructLiteral { fields, .. } => fields.values_mut().collect(),

            EnumDeclaration { variants, .. } => {
                let mut children = vec![];

                for (_, (variant_node, opt_payload)) in variants.iter_mut() {
                    children.push(variant_node);
                    if let Some(payload) = opt_payload.as_mut() {
                        children.push(payload);
                    }
                }

                children
            }

            ImplDeclaration {
                generic_parameters,
                type_reference,
                associated_constants,
                associated_functions,
                associated_types,
                ..
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                children.push(type_reference.as_mut());

                for const_node in associated_constants.iter_mut() {
                    children.push(const_node);
                }

                for func_node in associated_functions.iter_mut() {
                    children.push(func_node);
                }

                for type_node in associated_types.iter_mut() {
                    children.push(type_node);
                }

                children
            }

            AssociatedConstant {
                type_annotation,
                initializer,
                ..
            } => {
                let mut children = vec![];

                if let Some(ta) = type_annotation.as_mut() {
                    children.push(ta.as_mut());
                }

                children.push(initializer.as_mut());
                children
            }

            AssociatedType { value, .. } => vec![value.as_mut()],

            TraitDeclaration {
                generic_parameters,
                types,
                constants,
                signatures,
                ..
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                for t in types.iter_mut() {
                    children.push(t);
                }

                for c in constants.iter_mut() {
                    children.push(c);
                }

                for s in signatures.iter_mut() {
                    children.push(s);
                }

                children
            }

            TraitConstant { type_annotation, .. } => vec![type_annotation.as_mut()],

            TraitType(_) => vec![],

            TypeReference { generic_types, .. } => generic_types.iter_mut().collect(),

            TypeDeclaration {
                generic_parameters,
                value,
                ..
            } => {
                let mut children = vec![];

                for gp in generic_parameters.iter_mut() {
                    children.push(gp);
                }

                children.push(value.as_mut());
                children
            }

            FieldAccess { left, right } => vec![left.as_mut(), right.as_mut()],

            FunctionCall { function, arguments } => {
                let mut children = vec![];
                children.push(function.as_mut());

                for arg in arguments.iter_mut() {
                    children.push(arg);
                }

                children
            }

            GenericParameter { .. } => vec![],
        }
    }
}


// frontend/token_parser.rs
use indexmap::IndexMap;

use crate::{
    boxed,
    frontend::ast::BoxedAstNode,
    utils::{error::*, kind::*},
};

use super::ast::{AstNode, AstNodeKind};

pub struct Parser {
    lines: Vec<String>,
    tokens: Vec<Token>,
    current: usize,
    errors: Vec<Error>,
}

impl Parser {
    fn is_at_end(&self) -> bool {
        self.peek().get_token_kind() == TokenKind::EndOfFile
    }

    fn peek(&self) -> &Token {
        &self.tokens[self.current]
    }

    fn previous(&self) -> &Token {
        &self.tokens[self.current - 1]
    }

    fn advance(&mut self) -> &Token {
        if !self.is_at_end() {
            self.current += 1;
        }

        self.previous()
    }

    fn back(&mut self) {
        if self.current > 0 {
            self.current -= 1;
        }
    }

    fn match_token(&mut self, token_type: TokenKind) -> bool {
        if self.peek().get_token_kind() == token_type {
            self.advance();
            true
        } else {
            false
        }
    }

    /// Generates an Error struct based on the position of the parser.
    fn generate_error(&self, kind: ErrorKind, span: Span) -> BoxedError {
        let span = span.set_end_from_span(self.peek().get_span());
        Error::from_one_error(
            kind,
            span,
            (self.lines[span.end_pos.line - 1].clone(), span.start_pos.line),
        )
    }

    fn consume(&mut self, token_type: TokenKind) -> Result<&Token, BoxedError> {
        let peeked = self.peek();

        if peeked.get_token_kind() == token_type {
            Ok(self.advance())
        } else {
            let span = self.previous().get_span();
            return Err(self.generate_error(
                ErrorKind::UnexpectedToken(
                    peeked.get_value().to_string(),
                    format!("{}", peeked.get_token_kind()),
                    format!("a token of type {}", token_type),
                ),
                span,
            ));
        }
    }

    fn synchronize(&mut self) {
        self.advance();

        while !self.is_at_end() {
            if self.previous().get_token_kind() == TokenKind::Semicolon {
                return;
            }

            if SYNC_TOKENS.contains(&self.peek().get_token_kind()) {
                return;
            }

            self.advance();
        }
    }

    fn create_span_from_current_token(&self) -> Span {
        let previous_span = self.peek().get_span();

        Span {
            start: previous_span.start,
            start_pos: previous_span.start_pos,
            end: 0,
            end_pos: Position::default(),
        }
    }

    fn spanned_node<F>(&mut self, builder: F) -> Result<AstNode, BoxedError>
    where
        F: FnOnce(&mut Self) -> Result<AstNodeKind, BoxedError>,
    {
        let start_span = self.peek().get_span();
        let initial = Span {
            start: start_span.start,
            start_pos: start_span.start_pos,
            end: 0,
            end_pos: Position::default(),
        };

        let kind = builder(self)?;
        let finished = initial.set_end_from_span(self.previous().get_span());

        Ok(AstNode {
            kind,
            span: finished,
            type_id: None,
            value_id: None,
            scope_id: None,
        })
    }
}

impl Parser {
    fn parse_expression(&mut self) -> Result<AstNode, BoxedError> {
        self.parse_binding_power(Operation::Assign.binding_power().0)
    }

    fn parse_binding_power(&mut self, min_bp: u8) -> Result<AstNode, BoxedError> {
        let mut lhs = self.parse_prefix()?;

        loop {
            let operator = match self.peek().get_token_kind() {
                TokenKind::Operator(op) => op,
                TokenKind::OpenParenthesis => Operation::FunctionCall,
                _ => break,
            };

            let (left_bp, right_bp) = operator.binding_power();

            if left_bp < min_bp {
                break;
            }

            self.advance();

            if operator == Operation::FunctionCall {
                let mut arguments = vec![];
                if self.peek().get_token_kind() != TokenKind::CloseParenthesis {
                    loop {
                        arguments.push(self.parse_expression()?);
                        if self.peek().get_token_kind() == TokenKind::CloseParenthesis {
                            break;
                        }
                        self.consume(TokenKind::Comma)?;
                    }
                }
                self.consume(TokenKind::CloseParenthesis)?;

                lhs = AstNode {
                    span: lhs.span.set_end_from_span(self.previous().get_span()),
                    kind: AstNodeKind::FunctionCall {
                        function: boxed!(lhs),
                        arguments,
                    },
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                };
            } else {
                let rhs = self.parse_binding_power(right_bp)?;

                lhs = AstNode {
                    span: lhs.span.set_end_from_span(rhs.span),
                    kind: if operator.is_conditional() {
                        AstNodeKind::ConditionalOperation {
                            operator,
                            left: boxed!(lhs),
                            right: boxed!(rhs),
                        }
                    } else if operator == Operation::FieldAccess {
                        AstNodeKind::FieldAccess {
                            left: boxed!(lhs),
                            right: boxed!(rhs),
                        }
                    } else {
                        AstNodeKind::BinaryOperation {
                            operator,
                            left: boxed!(lhs),
                            right: boxed!(rhs),
                        }
                    },
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                };
            }
        }

        Ok(lhs)
    }

    fn parse_prefix(&mut self) -> Result<AstNode, BoxedError> {
        let token = self.peek();
        let span = self.create_span_from_current_token();

        match token.get_token_kind() {
            TokenKind::Operator(operator) => {
                if !operator.is_unary() {
                    return Err(self.generate_error(
                        ErrorKind::UnexpectedToken(
                            token.get_value().to_string(),
                            format!("{}", token.get_token_kind()),
                            "a unary operator".to_string(),
                        ),
                        span,
                    ));
                }

                let _ = self.advance();
                let mut operator = match operator {
                    Operation::Mul => Operation::Dereference,
                    Operation::BitwiseAnd => Operation::ImmutableAddressOf,
                    _ => operator,
                };

                if operator == Operation::ImmutableAddressOf
                    && self.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::Mut)
                {
                    self.advance();
                    operator = Operation::MutableAddressOf;
                }

                let operand = boxed!(self.parse_binding_power(Operation::Not.binding_power().0)?);

                Ok(AstNode {
                    span: span.set_end_from_span(operand.span),
                    kind: AstNodeKind::UnaryOperation { operator, operand },
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::NumberLiteral(_) => {
                let token = self.advance();
                let numeric_literal: String = token.get_value().to_string();

                let (is_integer, value): (bool, f64) = {
                    if numeric_literal.starts_with("0b") || numeric_literal.starts_with("0B") {
                        let without_prefix = &numeric_literal[2..];
                        let int_value = u64::from_str_radix(without_prefix, 2).unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    } else if numeric_literal.starts_with("0o") || numeric_literal.starts_with("0O") {
                        let without_prefix = &numeric_literal[2..];
                        let int_value = u64::from_str_radix(without_prefix, 8).unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    } else if numeric_literal.starts_with("0x") || numeric_literal.starts_with("0X") {
                        let without_prefix = &numeric_literal[2..];
                        let int_value = u64::from_str_radix(without_prefix, 16).unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    } else if numeric_literal.contains('.')
                        || numeric_literal.contains('e')
                        || numeric_literal.contains('E')
                    {
                        let float_value = numeric_literal.parse::<f64>().unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (false, float_value)
                    } else {
                        let int_value = numeric_literal.parse::<u64>().unwrap_or_else(|_| {
                            panic!("The lexer made an error tokenizing token {:?}.", token)
                        });
                        (true, int_value as f64)
                    }
                };

                Ok(AstNode {
                    kind: if is_integer {
                        AstNodeKind::IntegerLiteral(value as i64)
                    } else {
                        AstNodeKind::FloatLiteral(value)
                    },
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::BooleanLiteral => {
                let token = self.advance();
                let value = token.get_value().parse::<bool>().unwrap();

                Ok(AstNode {
                    kind: AstNodeKind::BooleanLiteral(value),
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::StringLiteral => {
                let token = self.advance();

                let raw_value = token.get_value();
                let value = raw_value[1..raw_value.len() - 1].to_string();

                Ok(AstNode {
                    kind: AstNodeKind::StringLiteral(value),
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::CharLiteral => {
                let token = self.advance();

                let raw_value = token.get_value();
                let value = raw_value[1..raw_value.len() - 1].chars().next().unwrap();

                Ok(AstNode {
                    kind: AstNodeKind::CharLiteral(value),
                    span: token.get_span(),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::Identifier => {
                let token = self.advance();
                let name = token.get_value().to_string();
                let span = token.get_span();

                if self.peek().get_token_kind() == TokenKind::OpenBrace {
                    let mut fields = IndexMap::new();

                    self.advance();
                    while self.peek().get_token_kind() != TokenKind::CloseBrace {
                        let name_token = self.consume(TokenKind::Identifier)?.clone();
                        let name = name_token.get_value().to_string();

                        let value = if self.peek().get_token_kind() == TokenKind::Colon {
                            self.consume(TokenKind::Colon)?;
                            self.parse_expression()?
                        } else {
                            AstNode {
                                kind: AstNodeKind::Identifier(name.clone()),
                                span: name_token.get_span(),
                                type_id: None,
                                value_id: None,
                                scope_id: None,
                            }
                        };

                        fields.insert(name, value);

                        if self.peek().get_token_kind() == TokenKind::CloseBrace {
                            break;
                        } else {
                            self.consume(TokenKind::Comma)?;
                        }
                    }
                    self.advance();

                    Ok(AstNode {
                        kind: AstNodeKind::StructLiteral { name, fields },
                        span: span.set_end_from_span(self.previous().get_span()),
                        type_id: None,
                        value_id: None,
                        scope_id: None,
                    })
                } else {
                    Ok(AstNode {
                        kind: AstNodeKind::Identifier(name),
                        span,
                        type_id: None,
                        value_id: None,
                        scope_id: None,
                    })
                }
            }
            TokenKind::OpenParenthesis => {
                self.advance();
                let expr = self.parse_expression()?;
                self.consume(TokenKind::CloseParenthesis)?;
                Ok(expr)
            }
            TokenKind::Keyword(KeywordKind::This) => {
                self.advance();
                Ok(AstNode {
                    kind: AstNodeKind::SelfValue,
                    span: span.set_end_from_span(self.previous().get_span()),
                    type_id: None,
                    value_id: None,
                    scope_id: None,
                })
            }
            TokenKind::Keyword(KeywordKind::Fn) => self.parse_function_expression(),
            _ => {
                return Err(self.generate_error(
                    ErrorKind::UnexpectedToken(
                        token.get_value().to_string(),
                        format!("{}", token.get_token_kind()),
                        "a unary operator, a literal, an identifier, open parentheses, or a function expression".to_string()
                    ),
                    span
                ));
            }
        }
    }

    fn parse_expression_statement(&mut self) -> Result<AstNode, BoxedError> {
        let node = self.parse_expression()?;
        self.consume(TokenKind::Semicolon)?;
        Ok(node)
    }
}

impl Parser {
    pub fn new(lined_source: Vec<String>, tokens: Vec<Token>) -> Parser {
        Parser {
            lines: lined_source,
            tokens,
            current: 0,
            errors: vec![],
        }
    }

    pub fn parse(&mut self) -> Result<AstNode, Vec<Error>> {
        let program = self.parse_program();
        if self.errors.is_empty() {
            Ok(program)
        } else {
            Err(self.errors.clone())
        }
    }

    fn parse_program(&mut self) -> AstNode {
        let mut statements = vec![];

        while !self.is_at_end() {
            match self.parse_statement() {
                Ok(stmt) => statements.push(stmt),
                Err(err) => {
                    self.errors.push(*err);
                    self.synchronize();
                }
            }
        }

        AstNode {
            kind: AstNodeKind::Program(statements),
            span: Span {
                start: 0,
                end: self.tokens.last().unwrap().get_span().end,
                start_pos: Position::default(),
                end_pos: Position {
                    line: self.tokens.last().unwrap().get_span().end_pos.line,
                    column: self.tokens.last().unwrap().get_span().end_pos.column,
                },
            },
            type_id: None,
            value_id: None,
            scope_id: None,
        }
    }

    fn parse_statement(&mut self) -> Result<AstNode, BoxedError> {
        let token = self.peek();
        match token.get_token_kind() {
            TokenKind::Keyword(kind) => self.parse_keyword(kind),
            TokenKind::OpenBrace => self.parse_block(),
            _ => self.parse_expression_statement(),
        }
    }

    fn parse_keyword(&mut self, kind: KeywordKind) -> Result<AstNode, BoxedError> {
        match kind {
            KeywordKind::Let => self.parse_variable_declaration(true),
            KeywordKind::Const => self.parse_variable_declaration(false),
            KeywordKind::Fn => self.parse_function_declaration(),
            KeywordKind::If => self.parse_selection_statements(),
            KeywordKind::While => self.parse_while_loop(),
            KeywordKind::For => self.parse_for_loop(),
            KeywordKind::Struct => self.parse_struct_declaration(),
            KeywordKind::Return => self.parse_return_statement(),
            KeywordKind::Break => self.parse_break_statement(),
            KeywordKind::Continue => self.parse_continue_statement(),
            KeywordKind::Impl => self.parse_impl_statement(),
            KeywordKind::Enum => self.parse_enum_statement(),
            KeywordKind::Trait => self.parse_trait_declaration(),
            KeywordKind::Type => self.parse_type_declaration(),
            _ => self.parse_expression_statement(),
        }
    }

    fn parse_block(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.consume(TokenKind::OpenBrace)?;

            let mut statements = vec![];

            while parser.peek().get_token_kind() != TokenKind::CloseBrace {
                let stmt = parser.parse_statement()?;
                statements.push(stmt);
            }

            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::Block(statements))
        })
    }

    fn parse_variable_declaration(&mut self, mutable: bool) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let var_name = parser.consume(TokenKind::Identifier)?.get_value().to_string();

            let mut type_annotation = None;
            if parser.match_token(TokenKind::Colon) {
                type_annotation = Some(boxed!(parser.parse_type()?));
            }

            let mut initializer = None;
            if parser.match_token(TokenKind::Operator(Operation::Assign)) {
                initializer = Some(boxed!(parser.parse_expression()?));
            }

            if !mutable && initializer.is_none() {
                return Err(
                    parser.generate_error(ErrorKind::UninitializedConstant, parser.previous().get_span())
                );
            }

            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::VariableDeclaration {
                mutable,
                name: var_name,
                type_annotation,
                initializer,
            })
        })
    }

    fn parse_type(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let mut reference_kind = ReferenceKind::Value;

            if parser.peek().get_token_kind() == TokenKind::Operator(Operation::BitwiseAnd) {
                parser.advance();

                if parser.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::Mut) {
                    parser.advance();
                    reference_kind = ReferenceKind::MutableReference;
                } else {
                    reference_kind = ReferenceKind::Reference;
                }
            }

            let type_reference = parser.advance().clone();

            match type_reference.get_token_kind() {
                TokenKind::Identifier => {
                    if parser.peek().get_token_kind() == TokenKind::Operator(Operation::FieldAccess) {
                        parser.advance();
                        let next = parser.consume(TokenKind::Identifier)?;

                        Ok(AstNodeKind::FieldAccess {
                            left: boxed!(AstNode {
                                kind: AstNodeKind::Identifier(type_reference.get_value().to_string()),
                                span: type_reference.get_span(),
                                value_id: None,
                                scope_id: None,
                                type_id: None
                            }),
                            right: boxed!(AstNode {
                                kind: AstNodeKind::Identifier(next.get_value().to_string()),
                                span: next.get_span(),
                                value_id: None,
                                scope_id: None,
                                type_id: None
                            }),
                        })
                    } else {
                        let generic_types = parser.parse_generic_types_list()?;

                        Ok(AstNodeKind::TypeReference {
                            type_name: type_reference.get_value().to_string(),
                            generic_types,
                            reference_kind,
                        })
                    }
                }

                TokenKind::Keyword(KeywordKind::Int)
                | TokenKind::Keyword(KeywordKind::Float)
                | TokenKind::Keyword(KeywordKind::String)
                | TokenKind::Keyword(KeywordKind::Bool) => {
                    let generic_types = parser.parse_generic_types_list()?;

                    Ok(AstNodeKind::TypeReference {
                        type_name: type_reference.get_value().to_string(),
                        generic_types,
                        reference_kind,
                    })
                }
                TokenKind::Keyword(KeywordKind::Fn) => {
                    let mut params = vec![];

                    parser.consume(TokenKind::OpenParenthesis)?;
                    loop {
                        params.push(parser.parse_type()?);
                        if parser.peek().get_token_kind() == TokenKind::Comma {
                            parser.advance();
                        } else {
                            break;
                        }
                    }
                    parser.consume(TokenKind::CloseParenthesis)?;

                    let mut return_type = None;

                    if parser.peek().get_token_kind() == TokenKind::Colon {
                        parser.advance();
                        return_type = Some(boxed!(parser.parse_type()?));
                    }

                    Ok(AstNodeKind::FunctionPointer { params, return_type })
                }
                _ => {
                    let span = type_reference.get_span();
                    return Err(parser.generate_error(
                        ErrorKind::UnexpectedToken(
                            type_reference.get_value().to_string(),
                            format!("{}", type_reference.get_token_kind()),
                            "a type reference".to_string(),
                        ),
                        span,
                    ));
                }
            }
        })
    }

    fn parse_function_signature(
        &mut self,
        is_expression: bool,
        is_associated: bool,
        allow_generics: bool,
    ) -> Result<
        (
            String,
            Vec<AstNode>,
            Vec<AstNode>,
            Option<BoxedAstNode>,
            Option<ReferenceKind>,
        ),
        BoxedError,
    > {
        self.consume(TokenKind::Keyword(KeywordKind::Fn))?;

        let name = if !is_expression {
            self.consume(TokenKind::Identifier)?.get_value().to_string()
        } else {
            String::new()
        };

        let generic_parameters = if allow_generics {
            self.parse_generic_parameter_list()?
        } else {
            vec![]
        };

        let (parameters, instance) = if is_associated {
            self.parse_associated_function_parameter_list()?
        } else {
            (self.parse_function_parameter_list()?, None)
        };

        let mut return_type = None;
        if self.match_token(TokenKind::Colon) {
            return_type = Some(boxed!(self.parse_type()?));
        }

        Ok((name, generic_parameters, parameters, return_type, instance))
    }

    fn parse_function_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(false, false, true)?;
            let body = Some(boxed!(parser.parse_block()?));

            Ok(AstNodeKind::Function {
                qualifier: None,
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body,
            })
        })
    }

    fn parse_function_expression(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(true, false, false)?;
            let body = Some(boxed!(parser.parse_block()?));

            Ok(AstNodeKind::Function {
                qualifier: None,
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body,
            })
        })
    }

    fn parse_parameter(
        &mut self,
        allow_this: bool,
        is_first: bool,
    ) -> Result<(AstNode, Option<ReferenceKind>), BoxedError> {
        let mut self_kind: Option<ReferenceKind> = None;

        let node = self.spanned_node(|parser| {
            if allow_this && is_first {
                let current_token_kind = parser.peek().get_token_kind();
                if current_token_kind == TokenKind::Operator(Operation::BitwiseAnd) {
                    let next_token_is_mut = parser.tokens.get(parser.current + 1).map_or(false, |t| {
                        t.get_token_kind() == TokenKind::Keyword(KeywordKind::Mut)
                    });
                    let next_token_is_this = parser.tokens.get(parser.current + 1).map_or(false, |t| {
                        t.get_token_kind() == TokenKind::Keyword(KeywordKind::This)
                    });
                    let third_token_is_this = next_token_is_mut
                        && parser.tokens.get(parser.current + 2).map_or(false, |t| {
                            t.get_token_kind() == TokenKind::Keyword(KeywordKind::This)
                        });

                    if next_token_is_this || third_token_is_this {
                        parser.advance();

                        let (_, kind) = if parser.match_token(TokenKind::Keyword(KeywordKind::Mut)) {
                            (Operation::MutableAddressOf, ReferenceKind::MutableReference)
                        } else {
                            (Operation::ImmutableAddressOf, ReferenceKind::Reference)
                        };

                        parser.consume(TokenKind::Keyword(KeywordKind::This))?;
                        self_kind = Some(kind);

                        let type_annotation =
                            boxed!(parser.spanned_node(|_| Ok(AstNodeKind::SelfType(kind)))?);
                        return Ok(AstNodeKind::FunctionParameter {
                            name: "this".to_string(),
                            type_annotation,
                            initializer: None,
                            mutable: false,
                        });
                    }
                } else if current_token_kind == TokenKind::Keyword(KeywordKind::This) {
                    parser.advance();
                    self_kind = Some(ReferenceKind::Value);

                    let type_annotation =
                        boxed!(parser.spanned_node(|_| Ok(AstNodeKind::SelfType(ReferenceKind::Value)))?);
                    return Ok(AstNodeKind::FunctionParameter {
                        name: "this".to_string(),
                        type_annotation,
                        initializer: None,
                        mutable: false,
                    });
                }
            }

            let mutable = parser.match_token(TokenKind::Keyword(KeywordKind::Mut));
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Colon)?;
            let type_annotation = boxed!(parser.parse_type()?);
            let mut initializer = None;

            if parser.match_token(TokenKind::Operator(Operation::Assign)) {
                initializer = Some(boxed!(parser.parse_expression()?));
            }

            Ok(AstNodeKind::FunctionParameter {
                name,
                type_annotation,
                initializer,
                mutable,
            })
        })?;

        Ok((node, self_kind))
    }

    fn parse_function_parameter_list(&mut self) -> Result<Vec<AstNode>, BoxedError> {
        let mut parameters = vec![];

        self.consume(TokenKind::OpenParenthesis)?;
        if self.peek().get_token_kind() == TokenKind::CloseParenthesis {
            self.consume(TokenKind::CloseParenthesis)?;
            return Ok(parameters);
        }

        let mut first = true;
        loop {
            let (param, _) = self.parse_parameter(false, first)?;
            parameters.push(param);
            first = false;

            if self.peek().get_token_kind() == TokenKind::CloseParenthesis {
                break;
            } else {
                self.consume(TokenKind::Comma)?;
            }
        }

        self.consume(TokenKind::CloseParenthesis)?;
        Ok(parameters)
    }

    fn parse_associated_function_parameter_list(
        &mut self,
    ) -> Result<(Vec<AstNode>, Option<ReferenceKind>), BoxedError> {
        let mut parameters = vec![];
        let mut instance_kind: Option<ReferenceKind> = None;

        self.consume(TokenKind::OpenParenthesis)?;

        let mut first = true;
        while self.peek().get_token_kind() != TokenKind::CloseParenthesis {
            let (param, self_kind) = self.parse_parameter(true, first)?;
            if self_kind.is_some() {
                instance_kind = self_kind;
            }
            parameters.push(param);
            first = false;

            if self.peek().get_token_kind() == TokenKind::Comma {
                self.consume(TokenKind::Comma)?;
            } else {
                break;
            }
        }

        self.consume(TokenKind::CloseParenthesis)?;
        Ok((parameters, instance_kind))
    }

    fn parse_generic_parameter_list(&mut self) -> Result<Vec<AstNode>, BoxedError> {
        let mut parameters = vec![];

        if self.peek().get_token_kind() != TokenKind::OpenBracket {
            return Ok(parameters);
        }

        self.consume(TokenKind::OpenBracket)?;
        loop {
            let node = self.spanned_node(|parser| {
                let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
                let mut constraints = vec![];

                if parser.peek().get_token_kind() == TokenKind::Colon {
                    parser.advance();

                    loop {
                        constraints.push(parser.consume(TokenKind::Identifier)?.get_value().to_string());
                        if parser.peek().get_token_kind() != TokenKind::Operator(Operation::Plus) {
                            break;
                        }

                        parser.advance();
                    }
                }

                Ok(AstNodeKind::GenericParameter { name, constraints })
            })?;

            parameters.push(node);

            if self.peek().get_token_kind() == TokenKind::Comma {
                self.consume(TokenKind::Comma)?;
            } else {
                break;
            }
        }
        self.consume(TokenKind::CloseBracket)?;

        Ok(parameters)
    }

    fn parse_generic_types_list(&mut self) -> Result<Vec<AstNode>, BoxedError> {
        let mut types = vec![];

        if self.peek().get_token_kind() != TokenKind::OpenBracket {
            return Ok(types);
        }

        self.consume(TokenKind::OpenBracket)?;
        loop {
            let node = self.parse_type()?;
            types.push(node);

            if self.peek().get_token_kind() == TokenKind::Comma {
                self.consume(TokenKind::Comma)?;
            } else {
                break;
            }
        }
        self.consume(TokenKind::CloseBracket)?;

        Ok(types)
    }

    fn parse_selection_statements(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let condition = boxed!(parser.parse_expression()?);
            let then_branch = boxed!(parser.parse_block()?);
            let mut else_if_branches = vec![];

            let mut else_branch = None;

            while parser.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::Else) {
                parser.advance();

                if parser.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::If) {
                    parser.advance();
                    let condition = boxed!(parser.parse_expression()?);
                    let then_branch = boxed!(parser.parse_block()?);

                    else_if_branches.push((condition, then_branch));
                } else {
                    else_branch = Some(boxed!(parser.parse_block()?));
                }
            }

            Ok(AstNodeKind::IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            })
        })
    }

    fn parse_while_loop(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let condition = boxed!(parser.parse_expression()?);
            let body = boxed!(parser.parse_block()?);

            Ok(AstNodeKind::WhileLoop { body, condition })
        })
    }

    fn parse_for_loop(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            parser.consume(TokenKind::OpenParenthesis)?;

            let initializer = if parser.peek().get_token_kind() == TokenKind::Semicolon {
                parser.consume(TokenKind::Semicolon)?;
                None
            } else {
                let init = match parser.peek().get_token_kind() {
                    TokenKind::Keyword(KeywordKind::Let) => parser.parse_variable_declaration(true),
                    TokenKind::Keyword(KeywordKind::Const) => parser.parse_variable_declaration(false),
                    _ => parser.parse_expression_statement(),
                }?;
                Some(boxed!(init))
            };

            let condition = if parser.peek().get_token_kind() == TokenKind::Semicolon {
                parser.consume(TokenKind::Semicolon)?;
                None
            } else {
                let cond = parser.parse_expression()?;
                parser.consume(TokenKind::Semicolon)?;
                Some(boxed!(cond))
            };

            let increment = if parser.peek().get_token_kind() == TokenKind::CloseParenthesis {
                None
            } else {
                Some(boxed!(parser.parse_expression()?))
            };

            parser.consume(TokenKind::CloseParenthesis)?;
            let body = boxed!(parser.parse_block()?);

            Ok(AstNodeKind::ForLoop {
                initializer,
                condition,
                increment,
                body,
            })
        })
    }

    fn parse_return_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let expression = if parser.peek().get_token_kind() != TokenKind::Semicolon {
                Some(boxed!(parser.parse_expression_statement()?))
            } else {
                parser.advance();
                None
            };

            Ok(AstNodeKind::Return(expression))
        })
    }

    fn parse_continue_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::Continue)
        })
    }

    fn parse_break_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::Break)
        })
    }

    fn parse_struct_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let generic_parameters = parser.parse_generic_parameter_list()?;
            let mut fields = vec![];

            parser.consume(TokenKind::OpenBrace)?;
            while parser.peek().get_token_kind() != TokenKind::CloseBrace {
                fields.push(parser.parse_struct_field()?);
            }
            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::StructDeclaration {
                name,
                generic_parameters,
                fields,
            })
        })
    }

    fn parse_struct_field(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let qualifier_token = parser.advance().clone();
            let qualifier = match qualifier_token.get_token_kind() {
                TokenKind::Keyword(KeywordKind::Public) => QualifierKind::Public,
                TokenKind::Keyword(KeywordKind::Private) => QualifierKind::Private,
                _ => {
                    parser.back();
                    QualifierKind::Public
                }
            };

            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Colon)?;
            let type_annotation = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::StructField {
                qualifier,
                name,
                type_annotation,
            })
        })
    }

    fn parse_impl_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let generic_parameters = parser.parse_generic_parameter_list()?;

            let (type_node, trait_node) = {
                let first = parser.parse_type()?;
                if parser.peek().get_token_kind() == TokenKind::Keyword(KeywordKind::For) {
                    parser.advance();
                    let second = parser.parse_type()?;

                    (boxed!(second), Some(boxed!(first)))
                } else {
                    (boxed!(first), None)
                }
            };

            parser.consume(TokenKind::OpenBrace)?;

            let mut associated_constants = vec![];
            let mut associated_functions = vec![];
            let mut associated_types = vec![];

            while parser.peek().get_token_kind() != TokenKind::CloseBrace {
                let qualifier = match parser.peek().get_token_kind() {
                    TokenKind::Keyword(KeywordKind::Public) => {
                        parser.advance();
                        QualifierKind::Public
                    }
                    TokenKind::Keyword(KeywordKind::Private) => {
                        parser.advance();
                        QualifierKind::Private
                    }
                    _ => QualifierKind::Public,
                };

                match parser.peek().get_token_kind() {
                    TokenKind::Keyword(KeywordKind::Const) => {
                        associated_constants.push(parser.parse_associated_constant_declaration(qualifier)?)
                    }
                    TokenKind::Keyword(KeywordKind::Fn) => {
                        associated_functions.push(parser.parse_associated_function(qualifier)?)
                    }
                    TokenKind::Keyword(KeywordKind::Type) => {
                        associated_types.push(parser.parse_associated_type_declaration(qualifier)?)
                    }
                    kind => {
                        let span = parser.previous().get_span();
                        return Err(parser.generate_error(
                            ErrorKind::UnexpectedToken(
                                parser.peek().get_value().to_string(),
                                format!("{}", kind),
                                "an associated function, type, or constant".to_string(),
                            ),
                            span,
                        ));
                    }
                }
            }

            parser.advance();

            Ok(AstNodeKind::ImplDeclaration {
                generic_parameters,
                type_reference: type_node,
                trait_node,
                associated_constants,
                associated_functions,
                associated_types,
            })
        })
    }

    fn parse_associated_constant_declaration(
        &mut self,
        qualifier: QualifierKind,
    ) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let variable_declaration = parser.parse_variable_declaration(false)?;

            let (name, type_annotation, initializer) = match variable_declaration.kind {
                AstNodeKind::VariableDeclaration {
                    name,
                    type_annotation,
                    initializer,
                    ..
                } => (name, type_annotation, initializer),
                _ => unreachable!(),
            };

            let initializer = initializer.ok_or(
                parser.generate_error(ErrorKind::UninitializedConstant, parser.previous().get_span()),
            )?;

            Ok(AstNodeKind::AssociatedConstant {
                qualifier,
                name,
                type_annotation,
                initializer,
            })
        })
    }

    fn parse_associated_function(&mut self, qualifier: QualifierKind) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(false, true, true)?;
            let body = Some(boxed!(parser.parse_block()?));

            Ok(AstNodeKind::Function {
                qualifier: Some(qualifier),
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body,
            })
        })
    }

    fn parse_associated_type_declaration(&mut self, qualifier: QualifierKind) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Operator(Operation::Assign))?;
            let value = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::AssociatedType {
                name,
                value,
                qualifier,
            })
        })
    }

    fn parse_enum_statement(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let mut variants = IndexMap::new();

            parser.consume(TokenKind::OpenBrace)?;
            loop {
                let variant = parser.parse_enum_variant()?;
                let AstNodeKind::EnumVariant(name) = &variant.kind else {
                    unreachable!();
                };

                if parser.peek().get_token_kind() == TokenKind::Operator(Operation::Assign) {
                    parser.advance();
                    variants.insert(name.clone(), (variant, Some(parser.parse_expression()?)));
                } else {
                    variants.insert(name.clone(), (variant, None));
                }

                if parser.peek().get_token_kind() == TokenKind::CloseBrace {
                    break;
                } else {
                    parser.consume(TokenKind::Comma)?;
                }
            }
            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::EnumDeclaration { name, variants })
        })
    }

    fn parse_enum_variant(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let variant_name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            Ok(AstNodeKind::EnumVariant(variant_name))
        })
    }

    fn parse_trait_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();

            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let generic_parameters = parser.parse_generic_parameter_list()?;

            let mut signatures = vec![];
            let mut constants = vec![];
            let mut types = vec![];

            parser.consume(TokenKind::OpenBrace)?;
            while parser.peek().get_token_kind() != TokenKind::CloseBrace {
                match parser.peek().get_token_kind() {
                    TokenKind::Keyword(KeywordKind::Const) => constants.push(parser.parse_trait_constant()?),
                    TokenKind::Keyword(KeywordKind::Fn) => {
                        signatures.push(parser.parse_trait_method_signature()?)
                    }
                    TokenKind::Keyword(KeywordKind::Type) => types.push(parser.parse_trait_type()?),
                    kind => {
                        let span = parser.previous().get_span();
                        return Err(parser.generate_error(
                            ErrorKind::UnexpectedToken(
                                parser.peek().get_value().to_string(),
                                format!("{}", kind),
                                "a function signature, type, or constant".to_string(),
                            ),
                            span,
                        ));
                    }
                }
            }

            parser.consume(TokenKind::CloseBrace)?;

            Ok(AstNodeKind::TraitDeclaration {
                name,
                generic_parameters,
                signatures,
                constants,
                types,
            })
        })
    }

    fn parse_trait_constant(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.consume(TokenKind::Keyword(KeywordKind::Const))?;
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Colon)?;
            let type_annotation = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::TraitConstant {
                name,
                type_annotation,
            })
        })
    }

    fn parse_trait_method_signature(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            let (name, generic_parameters, parameters, return_type, instance) =
                parser.parse_function_signature(false, true, true)?;
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::Function {
                qualifier: None,
                name,
                generic_parameters,
                parameters,
                return_type,
                instance,
                body: None,
            })
        })
    }

    fn parse_trait_type(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.consume(TokenKind::Keyword(KeywordKind::Type))?;
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::TraitType(name))
        })
    }

    fn parse_type_declaration(&mut self) -> Result<AstNode, BoxedError> {
        self.spanned_node(|parser| {
            parser.advance();
            let name = parser.consume(TokenKind::Identifier)?.get_value().to_string();
            let generic_parameters = parser.parse_generic_parameter_list()?;
            parser.consume(TokenKind::Operator(Operation::Assign))?;
            let value = boxed!(parser.parse_type()?);
            parser.consume(TokenKind::Semicolon)?;

            Ok(AstNodeKind::TypeDeclaration {
                name,
                generic_parameters,
                value,
            })
        })
    }
}


// middle/semantic_analyzer.rs
// middle/semantic_analyzer.rs
use crate::{
    frontend::ast::AstNode,
    utils::{error::*, kind::*},
};
use colored::*;
use std::{
    collections::{HashMap, VecDeque},
    rc::Rc,
};
use strum::IntoEnumIterator;

pub type ScopeId = usize;
pub type ValueNameId = usize;
pub type TypeNameId = usize;
pub type ValueSymbolId = usize;
pub type TypeSymbolId = usize;

/// A lookup table that maps Strings to numbers.
#[derive(Default, Debug)]
pub struct NameInterner {
    map: HashMap<String, usize>,
    vec: Vec<String>,
}

impl NameInterner {
    pub fn new() -> Self {
        Self::default()
    }

    /// Generates a unique ID for a string.
    pub fn intern(&mut self, s: &str) -> usize {
        if let Some(&id) = self.map.get(s) {
            return id;
        }

        let id = self.vec.len();
        self.map.insert(s.to_string(), id);
        self.vec.push(s.to_string());

        id
    }

    /// Finds a string given an id.
    pub fn lookup(&self, id: usize) -> &str {
        &self.vec[id]
    }

    pub fn get_id(&self, s: &str) -> Option<usize> {
        self.map.get(s).copied()
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ValueSymbolKind {
    Variable,
    Function(ScopeId),
    StructField,
    EnumVariant,
}

#[derive(Debug, Clone, Copy, PartialEq, strum_macros::EnumIter, strum_macros::Display)]
pub enum PrimitiveKind {
    Int,
    Float,
    Bool,
    String,
    Char,
    Void,
    Never
}

impl PrimitiveKind {
    pub fn to_symbol_str(&self) -> &'static str {
        match self {
            PrimitiveKind::Int => INT_TYPE,
            PrimitiveKind::Float => FLOAT_TYPE,
            PrimitiveKind::Bool => BOOL_TYPE,
            PrimitiveKind::String => STRING_TYPE,
            PrimitiveKind::Char => CHAR_TYPE,
            PrimitiveKind::Void => VOID_TYPE,
            PrimitiveKind::Never => NEVER_TYPE
        }
    }
}

#[derive(Debug, Clone)]
pub struct InherentImpl {
    pub scope_id: ScopeId,
    pub specialization: Vec<TypeSymbolId>,
    pub generic_params: Vec<TypeSymbolId>,
}

#[derive(Debug, Clone)]
pub struct TraitImpl {
    pub impl_scope_id: ScopeId,
    pub impl_generic_params: Vec<TypeSymbolId>,
    pub trait_generic_specialization: Vec<TypeSymbolId>,
    pub type_specialization: Vec<TypeSymbolId>,
}

#[derive(Debug, Clone)]
pub enum TypeSymbolKind {
    Primitive(PrimitiveKind),
    Enum((ScopeId, Vec<InherentImpl>)),
    Struct((ScopeId, Vec<InherentImpl>)),
    Trait(ScopeId),
    TypeAlias((Option<ScopeId>, Option<Type>)),
    FunctionSignature {
        params: Vec<Type>,
        return_type: Type,
        instance: Option<ReferenceKind>,
    },
    Generic(Vec<TypeSymbolId>),
    UnificationVariable(TypeSymbolId),
}

#[derive(Debug, Clone, PartialEq)]
pub enum ScopeKind {
    Root,
    Function,
    Block,
    Enum,
    Struct,
    Impl,
    Trait,
    Type,
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    Base { symbol: TypeSymbolId, args: Vec<Type> },
    Reference(Box<Type>),
    MutableReference(Box<Type>),
}

impl Type {
    pub fn new_base(symbol: TypeSymbolId) -> Self {
        Type::Base { symbol, args: vec![] }
    }

    pub fn is_base(&self) -> bool {
        matches!(self, Type::Base { .. })
    }

    pub fn get_base_symbol(&self) -> TypeSymbolId {
        match self {
            Type::Base { symbol, .. } => *symbol,
            Type::Reference(inner) | Type::MutableReference(inner) => inner.get_base_symbol(),
        }
    }
}

#[derive(Debug, Clone)]
pub struct ValueSymbol {
    pub id: ValueSymbolId,
    pub name_id: ValueNameId,
    pub kind: ValueSymbolKind,
    pub mutable: bool,
    pub span: Option<Span>,
    pub qualifier: QualifierKind,
    pub scope_id: ScopeId,
    pub type_id: Option<Type>,
}

#[derive(Debug, Clone)]
pub struct TypeSymbol {
    pub id: TypeSymbolId,
    pub name_id: TypeNameId,
    pub kind: TypeSymbolKind,
    pub generic_parameters: Vec<TypeSymbolId>,
    pub qualifier: QualifierKind,
    pub scope_id: ScopeId,
    pub span: Option<Span>,
}

impl TypeSymbol {
    pub fn unify(&self, other: &TypeSymbol) -> Option<TypeSymbolId> {
        if self.id == other.id {
            return Some(self.id);
        }

        match (&self.kind, &other.kind) {
            (_, TypeSymbolKind::Primitive(PrimitiveKind::Never)) => Some(self.id),
            (TypeSymbolKind::Primitive(PrimitiveKind::Never), _) => Some(other.id),

            (TypeSymbolKind::Primitive(PrimitiveKind::Int), TypeSymbolKind::Enum(_)) => Some(self.id),
            (TypeSymbolKind::Enum(_), TypeSymbolKind::Primitive(PrimitiveKind::Int)) => Some(other.id),

            _ => None
        }
    }
}

#[derive(Debug)]
pub struct Scope {
    pub values: HashMap<ValueNameId, ValueSymbolId>,
    pub types: HashMap<TypeNameId, TypeSymbolId>,
    pub kind: ScopeKind,
    pub parent: Option<ScopeId>,
    pub id: ScopeId,
    pub receiver_kind: Option<ReferenceKind>,
}

pub struct SymbolTable {
    pub value_symbols: HashMap<ValueSymbolId, ValueSymbol>,
    pub type_symbols: HashMap<TypeSymbolId, TypeSymbol>,
    value_names: NameInterner,
    type_names: NameInterner,

    pub default_trait_impl_scopes: HashMap<(TypeSymbolId, TypeSymbolId), ScopeId>,

    pub scopes: HashMap<ScopeId, Scope>,

    lines: Rc<Vec<String>>,
    current_scope_id: ScopeId,
    next_scope_id: ScopeId,
    next_value_symbol_id: ValueSymbolId,
    next_type_symbol_id: TypeSymbolId,

    real_starting_scope: ScopeId,
}

impl SymbolTable {
    pub fn new(lines: Rc<Vec<String>>) -> Self {
        let mut table = SymbolTable {
            value_symbols: HashMap::new(),
            type_symbols: HashMap::new(),
            value_names: NameInterner::new(),
            type_names: NameInterner::new(),
            default_trait_impl_scopes: HashMap::new(),
            scopes: HashMap::new(),
            lines: lines.clone(),
            current_scope_id: 0,
            next_scope_id: 0,
            next_value_symbol_id: 0,
            next_type_symbol_id: 0,
            real_starting_scope: 0,
        };

        let root_scope_id = table.get_next_scope_id();
        let root_scope = Scope {
            values: HashMap::new(),
            types: HashMap::new(),
            parent: None,
            id: root_scope_id,
            kind: ScopeKind::Root,
            receiver_kind: None,
        };
        table.scopes.insert(root_scope_id, root_scope);

        for ty in PrimitiveKind::iter() {
            table
                .add_type_symbol(
                    ty.to_symbol_str(),
                    TypeSymbolKind::Primitive(ty),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
        }

        let init_scope_id = table.get_next_scope_id();
        let init_scope = Scope {
            values: HashMap::new(),
            types: HashMap::new(),
            parent: Some(root_scope_id),
            id: init_scope_id,
            kind: ScopeKind::Block,
            receiver_kind: None,
        };

        table.scopes.insert(init_scope_id, init_scope);

        table.current_scope_id = init_scope_id;
        table.real_starting_scope = init_scope_id;

        table
    }

    pub fn populate_with_defaults(&mut self, trait_registry: &mut TraitRegistry) {
        let old_scope = self.current_scope_id;
        self.current_scope_id = 0;

        // TRAITS //
        for op in Operation::iter() {
            let Some((trait_name, is_binary)) = op.to_trait_data() else {
                continue;
            };
            let is_unary = !is_binary;

            let fn_name = trait_name
                .chars()
                .enumerate()
                .map(|(i, c)| {
                    if i != 0 && c.is_uppercase() {
                        format!("_{}", c.to_lowercase())
                    } else {
                        c.to_lowercase().to_string()
                    }
                })
                .collect::<String>();

            let trait_scope_id = self.enter_scope(ScopeKind::Trait);

            let self_type_id = self
                .add_type_symbol(
                    "Self",
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
            let output_type_id = self
                .add_type_symbol(
                    "Output",
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();

            let trait_generics = if is_unary { vec![] } else { vec!["Rhs"] };
            let trait_generic_ids: Vec<TypeSymbolId> = trait_generics
                .iter()
                .map(|&name| {
                    self.add_type_symbol(
                        name,
                        TypeSymbolKind::Generic(vec![]),
                        vec![],
                        QualifierKind::Public,
                        None,
                    )
                    .unwrap()
                })
                .collect();

            let mut params = vec![Type::new_base(self_type_id)];
            if !is_unary {
                params.push(Type::new_base(trait_generic_ids[0]));
            }

            self.add_type_symbol(
                &fn_name,
                TypeSymbolKind::FunctionSignature {
                    params,
                    return_type: Type::new_base(output_type_id),
                    instance: Some(ReferenceKind::Value),
                },
                vec![],
                QualifierKind::Public,
                None,
            )
            .unwrap();

            self.exit_scope();

            let trait_id = self
                .add_type_symbol(
                    &trait_name,
                    TypeSymbolKind::Trait(trait_scope_id),
                    trait_generic_ids.clone(),
                    QualifierKind::Public,
                    None,
                )
                .unwrap();

            trait_registry.default_traits.insert(trait_name.clone(), trait_id);

            // DEFAULT IMPLS //
            for primitive in PrimitiveKind::iter() {
                let Some(return_type) = op.to_default_trait_return_type(primitive) else {
                    continue;
                };
                let output_id = self.find_type_symbol(return_type.to_symbol_str()).unwrap().id;
                let self_id = self.find_type_symbol(primitive.to_symbol_str()).unwrap().id;

                let impl_scope_id = self.enter_scope(ScopeKind::Impl);

                let trait_specialization = if is_unary { vec![] } else { vec![self_id] };
                trait_registry.register(
                    trait_id,
                    self_id,
                    TraitImpl {
                        impl_scope_id,
                        impl_generic_params: vec![],
                        trait_generic_specialization: trait_specialization,
                        type_specialization: vec![],
                    },
                );

                self.add_type_symbol(
                    "Self",
                    TypeSymbolKind::TypeAlias((None, Some(Type::new_base(self_id)))),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
                self.add_type_symbol(
                    "Output",
                    TypeSymbolKind::TypeAlias((None, Some(Type::new_base(output_id)))),
                    vec![],
                    QualifierKind::Public,
                    None,
                )
                .unwrap();
                if !is_unary {
                    self.add_type_symbol(
                        trait_generics[0],
                        TypeSymbolKind::TypeAlias((None, Some(Type::new_base(self_id)))),
                        vec![],
                        QualifierKind::Public,
                        None,
                    )
                    .unwrap();
                }

                let func_scope_id = self.enter_scope(ScopeKind::Function);
                self.add_value_symbol(
                    "this",
                    ValueSymbolKind::Variable,
                    false,
                    QualifierKind::Public,
                    Some(Type::new_base(self_id)),
                    None,
                )
                .unwrap();
                if !is_unary {
                    self.add_value_symbol(
                        "other",
                        ValueSymbolKind::Variable,
                        false,
                        QualifierKind::Public,
                        Some(Type::new_base(self_id)),
                        None,
                    )
                    .unwrap();
                }

                let concrete_sig_params = if is_unary {
                    vec![Type::new_base(self_id)]
                } else {
                    vec![Type::new_base(self_id), Type::new_base(self_id)]
                };
                let concrete_sig_id = self
                    .add_type_symbol(
                        &fn_name,
                        TypeSymbolKind::FunctionSignature {
                            params: concrete_sig_params,
                            return_type: Type::new_base(output_id),
                            instance: Some(ReferenceKind::Value),
                        },
                        vec![],
                        QualifierKind::Public,
                        None,
                    )
                    .unwrap();

                self.add_value_symbol(
                    &fn_name,
                    ValueSymbolKind::Function(func_scope_id),
                    false,
                    QualifierKind::Public,
                    Some(Type::new_base(concrete_sig_id)),
                    None,
                )
                .unwrap();

                self.exit_scope(); // function scope
                self.exit_scope(); // impl scope
            }
        }

        self.current_scope_id = old_scope;
    }

    pub fn add_value_symbol(
        &mut self,
        name: &str,
        kind: ValueSymbolKind,
        mutable: bool,
        qualifier: QualifierKind,
        type_id: Option<Type>,
        span: Option<Span>,
    ) -> Result<ValueSymbolId, BoxedError> {
        let name_id = self.value_names.intern(name);
        let scope_id = self.current_scope_id;

        if let Some(existing_id) = self.scopes[&scope_id].values.get(&name_id) {
            let existing_symbol = &self.value_symbols[existing_id];
            let err = self.create_redeclaration_error(name.to_string(), existing_symbol.span, span);
            return Err(err);
        }

        let id = self.next_value_symbol_id;
        self.next_value_symbol_id += 1;
        let symbol = ValueSymbol {
            id,
            name_id,
            kind,
            mutable,
            qualifier,
            type_id,
            span,
            scope_id,
        };
        self.value_symbols.insert(id, symbol);
        self.scopes.get_mut(&scope_id).unwrap().values.insert(name_id, id);

        Ok(id)
    }

    pub fn add_type_symbol(
        &mut self,
        name: &str,
        kind: TypeSymbolKind,
        generic_parameters: Vec<TypeSymbolId>,
        qualifier: QualifierKind,
        span: Option<Span>,
    ) -> Result<TypeSymbolId, BoxedError> {
        let name_id = self.type_names.intern(name);
        let scope_id = self.current_scope_id;

        if let Some(existing_id) = self.scopes[&scope_id].types.get(&name_id) {
            let existing_symbol = &self.type_symbols[existing_id];
            let err = self.create_redeclaration_error(name.to_string(), existing_symbol.span, span);
            return Err(err);
        }

        let id = self.next_type_symbol_id;
        self.next_type_symbol_id += 1;
        let symbol = TypeSymbol {
            id,
            name_id,
            kind,
            generic_parameters,
            qualifier,
            span,
            scope_id,
        };
        self.type_symbols.insert(id, symbol);
        self.scopes.get_mut(&scope_id).unwrap().types.insert(name_id, id);

        Ok(id)
    }

    pub fn find_value_symbol(&self, name: &str) -> Option<&ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_mut(&mut self, name: &str) -> Option<&mut ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol(&self, name: &str) -> Option<&TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol_mut(&mut self, name: &str) -> Option<&mut TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(self.current_scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_from_scope(&self, scope_id: ScopeId, name: &str) -> Option<&ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_from_scope_mut(
        &mut self,
        scope_id: ScopeId,
        name: &str,
    ) -> Option<&mut ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.values.get(&name_id) {
                return self.value_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol_from_scope(&self, scope_id: ScopeId, name: &str) -> Option<&TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_type_symbol_from_scope_mut(
        &mut self,
        scope_id: ScopeId,
        name: &str,
    ) -> Option<&mut TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let mut scope_id = Some(scope_id);

        while let Some(id) = scope_id {
            let scope = &self.scopes[&id];
            if let Some(symbol_id) = scope.types.get(&name_id) {
                return self.type_symbols.get_mut(symbol_id);
            }

            scope_id = scope.parent;
        }

        None
    }

    pub fn find_value_symbol_in_scope(&self, name: &str, scope_id: ScopeId) -> Option<&ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.values.get(&name_id)?;

        self.value_symbols.get(symbol_id)
    }

    pub fn find_type_symbol_in_scope(&self, name: &str, scope_id: ScopeId) -> Option<&TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.types.get(&name_id)?;

        self.type_symbols.get(symbol_id)
    }

    pub fn find_value_symbol_in_scope_mut(
        &mut self,
        name: &str,
        scope_id: ScopeId,
    ) -> Option<&mut ValueSymbol> {
        let name_id = self.value_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.values.get(&name_id)?;
        self.value_symbols.get_mut(symbol_id)
    }

    pub fn find_type_symbol_in_scope_mut(
        &mut self,
        name: &str,
        scope_id: ScopeId,
    ) -> Option<&mut TypeSymbol> {
        let name_id = self.type_names.get_id(name)?;
        let symbol_id = self.scopes.get(&scope_id)?.types.get(&name_id)?;
        self.type_symbols.get_mut(symbol_id)
    }

    pub fn get_value_symbol(&self, id: ValueSymbolId) -> Option<&ValueSymbol> {
        self.value_symbols.get(&id)
    }
    pub fn get_value_symbol_mut(&mut self, id: ValueSymbolId) -> Option<&mut ValueSymbol> {
        self.value_symbols.get_mut(&id)
    }
    pub fn get_type_symbol(&self, id: TypeSymbolId) -> Option<&TypeSymbol> {
        self.type_symbols.get(&id)
    }
    pub fn get_type_symbol_mut(&mut self, id: TypeSymbolId) -> Option<&mut TypeSymbol> {
        self.type_symbols.get_mut(&id)
    }
    pub fn get_value_name(&self, id: ValueNameId) -> &str {
        self.value_names.lookup(id)
    }
    pub fn get_type_name(&self, id: TypeNameId) -> &str {
        self.type_names.lookup(id)
    }

    pub fn get_current_scope_id(&self) -> ScopeId {
        self.current_scope_id
    }

    pub fn get_next_scope_id(&mut self) -> ScopeId {
        let new_id = self.next_scope_id;
        self.next_scope_id += 1;
        new_id
    }

    pub fn enter_scope(&mut self, kind: ScopeKind) -> ScopeId {
        let parent_id = self.current_scope_id;
        let new_id = self.get_next_scope_id();

        let new_scope = Scope {
            values: HashMap::new(),
            types: HashMap::new(),
            parent: Some(parent_id),
            id: new_id,
            kind,
            receiver_kind: None,
        };

        self.scopes.insert(new_id, new_scope);
        self.current_scope_id = new_id;
        new_id
    }

    pub fn exit_scope(&mut self) {
        if let Some(parent_id) = self.current_scope().parent {
            self.current_scope_id = parent_id;
        } else {
            panic!("Tried to exit global scope");
        }
    }

    pub fn current_scope_mut(&mut self) -> &mut Scope {
        self.scopes
            .get_mut(&self.current_scope_id)
            .expect("Scope should exist")
    }
    pub fn current_scope(&self) -> &Scope {
        self.scopes
            .get(&self.current_scope_id)
            .expect("Scope should exist")
    }
    pub fn get_scope_mut(&mut self, scope_id: ScopeId) -> Option<&mut Scope> {
        self.scopes.get_mut(&scope_id)
    }
    pub fn get_scope(&self, scope_id: ScopeId) -> Option<&Scope> {
        self.scopes.get(&scope_id)
    }

    fn create_redeclaration_error(
        &self,
        name: String,
        span1: Option<Span>,
        span2: Option<Span>,
    ) -> BoxedError {
        match (span1, span2) {
            (Some(s1), Some(s2)) => Error::from_multiple_errors(
                ErrorKind::AlreadyDeclared(name),
                s2,
                Span::get_all_lines(self.lines.clone(), &[s1, s2]),
            ),
            (Some(s), None) | (None, Some(s)) => Error::from_one_error(
                ErrorKind::AlreadyDeclared(name),
                s,
                (self.lines[s.start_pos.line - 1].clone(), s.start_pos.line),
            ),
            (None, None) => Error::new(ErrorKind::AlreadyDeclared(name)),
        }
    }
}

#[derive(Default)]
pub struct TraitRegistry {
    pub register: HashMap<TypeSymbolId, HashMap<TypeSymbolId, Vec<TraitImpl>>>,
    pub default_traits: HashMap<String, TypeSymbolId>,
}

impl TraitRegistry {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn register(&mut self, trait_id: TypeSymbolId, type_id: TypeSymbolId, implementation: TraitImpl) {
        self.register
            .entry(trait_id)
            .or_default()
            .entry(type_id)
            .or_default()
            .push(implementation);
    }

    pub fn get_default_trait(&self, name: &String) -> TypeSymbolId {
        *self.default_traits.get(name).unwrap()
    }
}

/// A constraint imposed onto a metavariable.
#[derive(Debug, Clone)]
pub enum Constraint {
    /// Two types are equal.
    Equality(Type, Type),
    /// A type denotes a function call on an instance.
    MethodCall(Type, Type, Vec<Type>, Type),
    /// A type denotes a function pointer.
    FunctionSignature(Type, Vec<Type>, Type),
    /// A type denotes the result of an operation that
    /// is trait overloadable.
    Operation(Type, Type, Type, Option<Type>),
    /// A type denotes the value of a member on an instance variable.
    InstanceMemberAccess(Type, Type, String),
    /// A type denotes a static member of a type, like an enum variant.
    StaticMemberAccess(Type, Type, String),
}

/// Additional information about a constraint.
#[derive(Debug, Clone, Copy)]
pub struct ConstraintInfo {
    pub span: Span,
    pub scope_id: ScopeId,
}

#[derive(Default)]
pub struct UnificationContext {
    next_id: TypeSymbolId,
    pub substitutions: HashMap<TypeSymbolId, Type>,
    pub constraints: VecDeque<(Constraint, ConstraintInfo)>,
}

impl UnificationContext {
    fn get_next_uv_id(&mut self) -> TypeSymbolId {
        let old = self.next_id;
        self.next_id += 1;
        old
    }

    pub fn generate_uv_type(&mut self, symbol_table: &mut SymbolTable, span: Span) -> Type {
        let id = self.get_next_uv_id();

        let symbol = symbol_table
            .add_type_symbol(
                &format!("#uv_{}", id),
                TypeSymbolKind::UnificationVariable(id),
                vec![],
                QualifierKind::Private,
                Some(span),
            )
            .unwrap();

        Type::Base { symbol, args: vec![] }
    }

    pub fn register_constraint(&mut self, constraint: Constraint, info: ConstraintInfo) {
        self.constraints.push_back((constraint, info));
    }
}

pub struct SemanticAnalyzer {
    pub symbol_table: SymbolTable,
    pub builtin_types: Vec<TypeSymbolId>,
    pub trait_registry: TraitRegistry,
    pub unification_context: UnificationContext,
    // TODO: Find better place to put this.
    pub current_return_type: Option<Type>,
    errors: Vec<Error>,
    lines: Rc<Vec<String>>,
}

impl SemanticAnalyzer {
    pub fn new(lines: Rc<Vec<String>>) -> SemanticAnalyzer {
        let mut symbol_table = SymbolTable::new(lines.clone());
        let mut trait_registry = TraitRegistry::new();

        symbol_table.populate_with_defaults(&mut trait_registry);

        let builtin_types: Vec<TypeSymbolId> = PrimitiveKind::iter()
            .map(|k| symbol_table.find_type_symbol(k.to_symbol_str()).unwrap().id)
            .collect();

        SemanticAnalyzer {
            trait_registry,
            symbol_table,
            builtin_types,
            unification_context: UnificationContext::default(),
            current_return_type: None,
            errors: vec![],
            lines,
        }
    }

    pub fn create_error(&self, kind: ErrorKind, primary_span: Span, spans: &[Span]) -> BoxedError {
        let lines = Span::get_all_lines(self.lines.clone(), spans);
        Error::from_multiple_errors(kind, primary_span, lines)
    }

    pub fn analyze(&mut self, mut program: AstNode) -> Result<AstNode, Vec<Error>> {
        macro_rules! pass {
            ($self:ident, $method:ident, $program:expr) => {{
                let errors = $self.$method(&mut $program);
                if !errors.is_empty() {
                    return Err(errors);
                }
            }};
        }

        /* PASSES
         * 0: Collects all declared symbols (variables, functions, structs, traits, etc.) into value and type bins.
         * 1: Associates generic parameters with their trait constraints.
         * 2: Appends inherent impl scopes to structs/enums and registers trait implementations.
         * 3: Attributes symbols with unification variables (unresolved type symbols).
         * 4: Collects constraints on unification symbols.
         * 5: Resolves unification variables via a unification algorithm.
         * 6: Miscellaneous grammar checks (ex. error on use of `break` outside of loop).
         */

        pass!(self, symbol_collector_pass, &mut program);
        pass!(self, generic_constraints_pass, &mut program);
        pass!(self, impl_collector_pass, &mut program);
        pass!(self, uv_collector_pass, &mut program);
        pass!(self, unification_pass, &mut program);

        Ok(program)
    }
}

impl std::fmt::Display for InherentImpl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "InherentImpl(scope_id: {}, specialization: {:?}, generic_params: {:?})",
            self.scope_id, self.specialization, self.generic_params
        )
    }
}

impl std::fmt::Display for TraitImpl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TraitImpl(impl_scope_id: {:?}, impl_generic_params: {:?}, trait_generic_specialization: {:?}, type_specialization: {:?})", 
            self.impl_scope_id, self.impl_generic_params, self.trait_generic_specialization, self.type_specialization)
    }
}

impl std::fmt::Display for ValueSymbolKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let colored = match self {
            ValueSymbolKind::Variable => "Variable".green(),
            ValueSymbolKind::Function(scope_id) => format!("Function({})", scope_id).blue(),
            ValueSymbolKind::StructField => "StructField".yellow(),
            ValueSymbolKind::EnumVariant => "EnumVariant".yellow(),
        };
        write!(f, "{}", colored)
    }
}

impl SymbolTable {
    pub fn display_value_symbol<'a>(&'a self, symbol: &'a ValueSymbol) -> impl std::fmt::Display + 'a {
        struct Displayer<'a> {
            symbol: &'a ValueSymbol,
            table: &'a SymbolTable,
        }
        impl std::fmt::Display for Displayer<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let name = self.table.get_value_name(self.symbol.name_id);
                write!(f, "{}", name.cyan().bold())?;
                write!(f, " ({})", self.symbol.kind)?;
                if self.symbol.mutable {
                    write!(f, " {}", "mut".red())?;
                }
                write!(f, " {}", self.symbol.qualifier)?;
                Ok(())
            }
        }
        Displayer { symbol, table: self }
    }

    // TODO: Make display_type_symbol more robust.
    pub fn display_type_symbol<'a>(&'a self, symbol: &'a TypeSymbol) -> impl std::fmt::Display + 'a {
        struct Displayer<'a> {
            symbol: &'a TypeSymbol,
            table: &'a SymbolTable,
        }
        impl std::fmt::Display for Displayer<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let name = self.table.get_type_name(self.symbol.name_id);
                let type_variant = match &self.symbol.kind {
                    TypeSymbolKind::Struct((id, scopes)) => format!("Struct({}, {:?})", id, scopes).blue(),
                    TypeSymbolKind::Trait(id) => format!("Trait({})", id).cyan(),
                    TypeSymbolKind::Enum((id, scopes)) => format!("Enum({}, {:?})", id, scopes).blue(),
                    TypeSymbolKind::TypeAlias(id) => format!("TypeAlias({:?})", id).white(),
                    TypeSymbolKind::Primitive(k) => format!("Builtin({})", k).green(),
                    TypeSymbolKind::FunctionSignature {
                        params, return_type, ..
                    } => {
                        let params_str = params
                            .iter()
                            .map(|p_ty| self.table.display_type(p_ty))
                            .collect::<Vec<_>>()
                            .join(", ");
                        format!("fn({}): {}", params_str, self.table.display_type(return_type)).blue()
                    }
                    TypeSymbolKind::Generic(constraints) => format!("Generic({:?})", constraints).white(),
                    TypeSymbolKind::UnificationVariable(id) => format!("UnificationVariable({})", id).red(),
                };
                write!(f, "[{}] {}", type_variant, name.cyan().bold())?;
                if !self.symbol.generic_parameters.is_empty() {
                    let params = self
                        .symbol
                        .generic_parameters
                        .iter()
                        .map(|id| self.table.get_type_name(self.table.type_symbols[id].name_id))
                        .collect::<Vec<_>>()
                        .join(", ");
                    write!(f, "<{}>", params)?;
                }
                Ok(())
            }
        }

        Displayer { symbol, table: self }
    }

    pub fn display_type<'a>(&'a self, ty: &'a Type) -> String {
        match ty {
            Type::Base { symbol, args } => {
                let type_symbol = &self.type_symbols[symbol];
                match &type_symbol.kind {
                    TypeSymbolKind::FunctionSignature {
                        params,
                        return_type,
                        ..
                    } => {
                        let generic_params_str = if !type_symbol.generic_parameters.is_empty() {
                            let params_list = type_symbol
                                .generic_parameters
                                .iter()
                                .map(|p_id| {
                                    self.get_type_name(self.get_type_symbol(*p_id).unwrap().name_id)
                                })
                                .collect::<Vec<_>>()
                                .join(", ");
                            format!("<{}>", params_list)
                        } else {
                            "".to_string()
                        };

                        let params_str = params
                            .iter()
                            .map(|p_ty| self.display_type(p_ty))
                            .collect::<Vec<_>>()
                            .join(", ");

                        let is_null_return = if let Type::Base {
                            symbol: ret_symbol, ..
                        } = &return_type
                        {
                            if let Some(symbol) = self.get_type_symbol(*ret_symbol) {
                                matches!(symbol.kind, TypeSymbolKind::Primitive(PrimitiveKind::Void))
                            } else {
                                false
                            }
                        } else {
                            false
                        };

                        if is_null_return {
                            format!("fn{}({})", generic_params_str, params_str)
                        } else {
                            format!(
                                "fn{}({}) -> {}",
                                generic_params_str,
                                params_str,
                                self.display_type(return_type)
                            )
                        }
                    }
                    _ => {
                        let base_name = self.get_type_name(type_symbol.name_id);
                        if args.is_empty() {
                            base_name.to_string()
                        } else {
                            let arg_str = args
                                .iter()
                                .map(|arg| self.display_type(arg))
                                .collect::<Vec<_>>()
                                .join(", ");
                            format!("{}<{}>", base_name, arg_str)
                        }
                    }
                }
            }
            Type::Reference(inner) => format!("&{}", self.display_type(inner)),
            Type::MutableReference(inner) => format!("&mut {}", self.display_type(inner)),
        }
    }

    fn display_scope(
        &self,
        scope_id: ScopeId,
        indent: usize,
        f: &mut std::fmt::Formatter,
    ) -> std::fmt::Result {
        let scope = self.scopes.get(&scope_id).unwrap();
        for symbol_id in scope.values.values() {
            let symbol = &self.value_symbols[symbol_id];
            writeln!(
                f,
                "{:indent$}[Value({})] {}",
                "",
                symbol_id,
                self.display_value_symbol(symbol),
                indent = indent
            )?;
        }
        for symbol_id in scope.types.values() {
            let symbol = &self.type_symbols[symbol_id];
            writeln!(
                f,
                "{:indent$}[Type({})] {}",
                "",
                symbol_id,
                self.display_type_symbol(symbol),
                indent = indent
            )?;
        }
        let mut child_scope_ids: Vec<ScopeId> = self
            .scopes
            .values()
            .filter(|s| s.parent == Some(scope_id))
            .map(|s| s.id)
            .collect();
        child_scope_ids.sort();
        for child_id in child_scope_ids {
            writeln!(f, "{:indent$}{{ (Scope({}))", "", child_id, indent = indent)?;
            self.display_scope(child_id, indent + 4, f)?;
            writeln!(f, "{:indent$}}}", "", indent = indent)?;
        }
        Ok(())
    }
}

impl std::fmt::Display for SymbolTable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "--- User Scope ({}) ---", self.real_starting_scope)?;
        self.display_scope(self.real_starting_scope, 0, f)
    }
}

impl TraitRegistry {
    pub fn display<'a>(&'a self, symbol_table: &'a SymbolTable) -> impl std::fmt::Display + 'a {
        struct Displayer<'a> {
            registry: &'a TraitRegistry,
            table: &'a SymbolTable,
        }
        impl std::fmt::Display for Displayer<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                for (trait_id, impls) in &self.registry.register {
                    let trait_symbol = &self.table.type_symbols[trait_id];
                    let trait_name = self.table.get_type_name(trait_symbol.name_id);

                    if self.registry.default_traits.contains_key(trait_name) {
                        continue;
                    }

                    writeln!(
                        f,
                        "{}",
                        format!("[Trait({})] {}", trait_id, trait_name).underline()
                    )?;
                    for (type_id, impl_details) in impls {
                        let type_symbol = &self.table.type_symbols[type_id];
                        let type_name = self.table.get_type_name(type_symbol.name_id);
                        write!(f, "  for [Type({})] {}: ", type_id, type_name)?;
                        for (i, impl_detail) in impl_details.iter().enumerate() {
                            if i > 0 {
                                write!(f, ", ")?;
                            }
                            write!(f, "{:?}", impl_detail)?;
                        }
                        writeln!(f)?;
                    }
                }
                Ok(())
            }
        }
        Displayer {
            registry: self,
            table: symbol_table,
        }
    }
}

impl Constraint {
    fn fmt<'a>(&'a self, table: &'a SymbolTable) -> impl std::fmt::Display + 'a {
        struct C<'a> {
            c: &'a Constraint,
            t: &'a SymbolTable,
        }
        impl std::fmt::Display for C<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                use Constraint::*;
                match self.c {
                    Equality(lhs, rhs) => write!(
                        f,
                        "{} {} {}",
                        self.t.display_type(lhs).yellow(),
                        "=".blue(),
                        self.t.display_type(rhs).yellow()
                    ),
                    MethodCall(instance, callee, ps, r) => {
                        let ps_str = ps
                            .iter()
                            .map(|p| self.t.display_type(p))
                            .collect::<Vec<_>>()
                            .join(", ");
                        write!(
                            f,
                            "({}).call({}) -> {} where callee is {}",
                            self.t.display_type(instance).yellow(),
                            ps_str,
                            self.t.display_type(r),
                            self.t.display_type(callee).cyan()
                        )
                    },
                    FunctionSignature(callee, ps, r) => {
                        let ps_str = ps
                            .iter()
                            .map(|p| self.t.display_type(p))
                            .collect::<Vec<_>>()
                            .join(", ");
                        write!(
                            f,
                            "{} {} fn({}) -> {}",
                            self.t.display_type(callee).yellow(),
                            "=".blue(),
                            ps_str,
                            self.t.display_type(r)
                        )
                    }
                    Operation(result, trait_ty, lhs, rhs) => {
                        let op_str = if let Some(r) = rhs {
                            format!("op({}, {})", self.t.display_type(lhs), self.t.display_type(r))
                        } else {
                            format!("op({})", self.t.display_type(lhs))
                        };

                        write!(
                            f,
                            "{} = {} where {}: {}",
                            self.t.display_type(result).yellow(),
                            op_str,
                            self.t.display_type(lhs),
                            self.t.display_type(trait_ty).cyan()
                        )
                    }
                    InstanceMemberAccess(result, base, m) => write!(
                        f,
                        "{} = {}.{}",
                        self.t.display_type(result).yellow(),
                        self.t.display_type(base),
                        m.green()
                    ),
                    StaticMemberAccess(result, base, m) => write!(
                        f,
                        "{} = {}::{}",
                        self.t.display_type(result).yellow(),
                        self.t.display_type(base).bright_blue(),
                        m.green()
                    ),
                }
            }
        }
        C { c: self, t: table }
    }
}

impl UnificationContext {
    pub fn display<'a>(&'a self, table: &'a SymbolTable) -> impl std::fmt::Display + 'a {
        use colored::*;

        struct D<'a> {
            ctx: &'a UnificationContext,
            tbl: &'a SymbolTable,
        }
        
        impl std::fmt::Display for D<'_> {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                if self.ctx.substitutions.is_empty() {
                    writeln!(f, "{}", "* Substitutions: (none)".dimmed())?;
                } else {
                    writeln!(f, "* {}", "Substitutions:".bold())?;
                    let mut subs: Vec<_> = self.ctx.substitutions.iter().collect();
                    subs.sort_by_key(|(uv, _)| *uv);
                    for (uv_symbol_id, sym) in subs {
                        let uv_name = self.tbl.get_type_name(self.tbl.get_type_symbol(*uv_symbol_id).unwrap().name_id);
                        let lhs = uv_name.red().bold();
                        let rhs = self.tbl.display_type(sym).green();
                        writeln!(f, "    {} {} {}", lhs, "->".blue(), rhs)?;
                    }
                }

               let unresolved_uvs: Vec<&TypeSymbol> = self.tbl.type_symbols
                    .values()
                    .filter(|symbol| {
                        if let TypeSymbolKind::UnificationVariable(_) = symbol.kind {
                            !self.ctx.substitutions.contains_key(&symbol.id)
                        } else {
                            false
                        }
                    })
                    .collect();

                if unresolved_uvs.is_empty() {
                    writeln!(f, "{}", "* Unresolved UVs: (none)".dimmed())?;
                } else {
                    let mut uv_names: Vec<String> = unresolved_uvs
                        .iter()
                        .map(|s| self.tbl.get_type_name(s.name_id).red().to_string())
                        .collect();
                    uv_names.sort();
                    let list = uv_names.join(", ");
                    writeln!(f, "* {} {}", "Unresolved UVs:".bold(), list)?;
                }

                // --- constraints ------------------------------------------------------------
                if self.ctx.constraints.is_empty() {
                    writeln!(f, "{}", "* Constraints: (none)".dimmed())
                } else {
                    writeln!(f, "* {}", "Constraints:".bold())?;
                    for (i, c) in self.ctx.constraints.iter().enumerate() {
                        writeln!(f, "    {}) {}", i + 1, c.0.fmt(self.tbl))?;
                    }
                    Ok(())
                }
            }
        }

        D {
            ctx: self,
            tbl: table,
        }
    }
}

impl std::fmt::Display for SemanticAnalyzer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "{}", "Symbol Table:".bold().underline())?;
        writeln!(f, "{}", self.symbol_table)?;
        writeln!(f, "\n{}", "Trait Registry:".bold().underline())?;
        writeln!(f, "{}", self.trait_registry.display(&self.symbol_table))?;
        writeln!(f, "\n{}", "Unification Context:".bold().underline())?;
        writeln!(f, "{}", self.unification_context.display(&self.symbol_table))?;

        Ok(())
    }
}

impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Type::Base { symbol, args } => {
                let base_name = format!("TypeSymbol({})", symbol);
                if args.is_empty() {
                    write!(f, "{}", base_name)
                } else {
                    let arg_str = args
                        .iter()
                        .map(|arg| format!("{}", arg))
                        .collect::<Vec<_>>()
                        .join(", ");
                    write!(f, "{}<{}>", base_name, arg_str)
                }
            }
            Type::Reference(inner) => write!(f, "&{}", inner),
            Type::MutableReference(inner) => write!(f, "&mut {}", inner),
        }
    }
}

// middle/symbols.rs
use super::semantic_analyzer::{ScopeKind, SemanticAnalyzer, ValueSymbolKind};
use crate::{
    frontend::ast::{AstNode, AstNodeKind, BoxedAstNode},
    middle::semantic_analyzer::{
        InherentImpl, PrimitiveKind, TraitImpl, Type, TypeSymbolId, TypeSymbolKind, ValueSymbolId,
    },
    utils::{
        error::*,
        kind::{QualifierKind, Span},
    },
};
use indexmap::IndexMap;

impl SemanticAnalyzer {
    pub fn symbol_collector_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        program.scope_id = Some(self.symbol_table.get_current_scope_id());

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.symbol_collector_check_node(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn symbol_collector_check_node(
        &mut self,
        node: &mut AstNode,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        node.scope_id = Some(self.symbol_table.get_current_scope_id());

        use AstNodeKind::*;

        let declared_symbol_opt = match &mut node.kind {
            VariableDeclaration {
                name,
                mutable,
                type_annotation,
                initializer,
            } => self.collect_variable_symbol(name, *mutable, type_annotation, initializer, node.span),
            Function { .. } => self.collect_function_item_symbols(node),
            StructDeclaration {
                name,
                fields,
                generic_parameters,
            } => self.collect_struct_symbols(name, fields, generic_parameters, node.span),
            ImplDeclaration { .. } => Ok((None, None)),
            EnumDeclaration { name, variants } => self.collect_enum_symbols(name, variants, node.span),
            TraitDeclaration {
                name,
                generic_parameters,
                constants,
                types,
                signatures,
            } => {
                self.collect_trait_symbols(name, generic_parameters, constants, types, signatures, node.span)
            }
            TypeDeclaration {
                name,
                generic_parameters,
                ..
            } => self.collect_type_symbols(name, generic_parameters, node.span),
            Block(_) => self.collect_block_symbols(node),
            _ => {
                for child in node.children_mut() {
                    self.symbol_collector_check_node(child)?;
                }

                Ok((None, None))
            }
        };

        if let Ok((value_id_opt, ref type_id_opt)) = declared_symbol_opt {
            node.value_id = value_id_opt;
            node.type_id = type_id_opt.clone();
        }

        declared_symbol_opt
    }

    fn collect_variable_symbol(
        &mut self,
        name: &str,
        mutable: bool,
        type_annotation: &mut Option<BoxedAstNode>,
        initializer: &mut Option<BoxedAstNode>,
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        self.collect_optional_node(type_annotation)?;
        self.collect_optional_node(initializer)?;

        let value_id = self.symbol_table.add_value_symbol(
            name,
            ValueSymbolKind::Variable,
            mutable,
            QualifierKind::Public,
            None,
            Some(span),
        )?;

        Ok((Some(value_id), None))
    }

    fn collect_function_item_symbols(
        &mut self,
        node: &mut AstNode,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let (is_declaration, qualifier, name, generic_parameters, parameters, return_type, body, instance) =
            if let AstNodeKind::Function {
                qualifier,
                name,
                generic_parameters,
                parameters,
                return_type,
                body,
                instance,
            } = &mut node.kind
            {
                (
                    !name.is_empty(),
                    *qualifier,
                    name.clone(),
                    generic_parameters,
                    parameters,
                    return_type,
                    body,
                    instance,
                )
            } else {
                unreachable!();
            };

        let scope_id = self.symbol_table.enter_scope(ScopeKind::Function);
        node.scope_id = Some(scope_id);

        let scope = self.symbol_table.get_scope_mut(scope_id).unwrap();
        scope.receiver_kind = *instance;

        self.collect_generic_parameters(generic_parameters)?;
        self.collect_function_parameters(parameters)?;
        self.collect_optional_node(return_type)?;

        if let Some(b) = body {
            self.symbol_collector_check_node(b)?;
        }

        self.symbol_table.exit_scope();

        if is_declaration {
            let value_id = self.symbol_table.add_value_symbol(
                &name,
                ValueSymbolKind::Function(scope_id),
                false,
                qualifier.unwrap_or(QualifierKind::Public),
                None,
                Some(node.span),
            )?;
            Ok((Some(value_id), None))
        } else {
            Ok((None, None))
        }
    }

    fn collect_struct_symbols(
        &mut self,
        name: &str,
        fields: &mut [AstNode],
        generic_parameters: &mut [AstNode],
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let scope_id = self.symbol_table.enter_scope(ScopeKind::Struct);

        let generic_param_ids = self.collect_generic_parameters(generic_parameters)?;
        for field in fields {
            self.symbol_collector_check_node(field)?;
            if let AstNodeKind::StructField { qualifier, name, .. } = &field.kind {
                let field_id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::StructField,
                    false,
                    *qualifier,
                    None,
                    Some(field.span),
                )?;
                field.value_id = Some(field_id);
            }
        }

        self.symbol_table.exit_scope();

        let type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::Struct((scope_id, vec![])),
            generic_param_ids,
            QualifierKind::Public,
            Some(span),
        )?;

        Ok((None, Some(Type::new_base(type_id))))
    }

    fn collect_enum_symbols(
        &mut self,
        name: &str,
        variants: &mut IndexMap<String, (AstNode, Option<AstNode>)>,
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let scope_id = self.symbol_table.enter_scope(ScopeKind::Enum);

        for (variant_name, (variant_node, _)) in variants {
            self.symbol_collector_check_node(variant_node)?;
            let variant_id = self.symbol_table.add_value_symbol(
                variant_name,
                ValueSymbolKind::EnumVariant,
                false,
                QualifierKind::Public,
                None,
                Some(variant_node.span),
            )?;
            variant_node.value_id = Some(variant_id);
        }

        self.symbol_table.exit_scope();
        let type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::Enum((scope_id, vec![])),
            vec![],
            QualifierKind::Public,
            Some(span),
        )?;

        Ok((None, Some(Type::new_base(type_id))))
    }

    fn collect_trait_symbols(
        &mut self,
        name: &mut str,
        generic_parameters: &mut [AstNode],
        constants: &mut [AstNode],
        types: &mut [AstNode],
        signatures: &mut [AstNode],
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let trait_scope_id = self.symbol_table.enter_scope(ScopeKind::Trait);

        let generic_param_ids = self.collect_generic_parameters(generic_parameters)?;
        self.symbol_table.add_type_symbol(
            "Self",
            TypeSymbolKind::TypeAlias((None, None)),
            vec![],
            QualifierKind::Public,
            None,
        )?;

        for const_node in constants {
            self.symbol_collector_check_node(const_node)?;
            if let AstNodeKind::TraitConstant { name, .. } = &const_node.kind {
                let const_id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Variable,
                    false,
                    QualifierKind::Public,
                    None,
                    Some(const_node.span),
                )?;
                const_node.value_id = Some(const_id);
            }
        }

        for type_node in types {
            self.symbol_collector_check_node(type_node)?;
            if let AstNodeKind::TraitType(name) = &type_node.kind {
                let type_id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    QualifierKind::Public,
                    Some(type_node.span),
                )?;
                type_node.type_id = Some(Type::new_base(type_id));
            }
        }

        for signature in signatures.iter_mut() {
            self.symbol_collector_check_node(signature)?;
            if let AstNodeKind::Function {
                name,
                generic_parameters,
                instance,
                ..
            } = &mut signature.kind
            {
                let sig_generic_param_ids = self.collect_generic_parameters(generic_parameters)?;

                let sig_type_id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::FunctionSignature {
                        params: vec![],
                        return_type: Type::new_base(self.builtin_types[PrimitiveKind::Void as usize]),
                        instance: *instance,
                    },
                    sig_generic_param_ids,
                    QualifierKind::Public,
                    Some(signature.span),
                )?;

                signature.type_id = Some(Type::new_base(sig_type_id));
            }
        }

        self.symbol_table.exit_scope();

        let trait_type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::Trait(trait_scope_id),
            generic_param_ids,
            QualifierKind::Public,
            Some(span),
        )?;
        Ok((None, Some(Type::new_base(trait_type_id))))
    }

    fn collect_generic_parameters(
        &mut self,
        params: &mut [AstNode],
    ) -> Result<Vec<TypeSymbolId>, BoxedError> {
        let mut ids = vec![];
        for param in params {
            self.symbol_collector_check_node(param)?;
            if let AstNodeKind::GenericParameter { name, .. } = &param.kind {
                let id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::Generic(vec![]),
                    vec![],
                    QualifierKind::Public,
                    Some(param.span),
                )?;
                param.type_id = Some(Type::new_base(id));
                ids.push(id);
            }
        }
        Ok(ids)
    }

    fn collect_function_parameters(
        &mut self,
        params: &mut [AstNode],
    ) -> Result<Vec<ValueSymbolId>, BoxedError> {
        let mut ids = vec![];
        for param in params {
            self.symbol_collector_check_node(param)?;
            if let AstNodeKind::FunctionParameter { name, mutable, .. } = &param.kind {
                let id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Variable,
                    *mutable,
                    QualifierKind::Public,
                    None,
                    Some(param.span),
                )?;
                param.value_id = Some(id);
                ids.push(id);
            }
        }
        Ok(ids)
    }

    fn collect_block_symbols(
        &mut self,
        node: &mut AstNode,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let scope_id = self.symbol_table.enter_scope(ScopeKind::Block);
        node.scope_id = Some(scope_id);

        if let AstNodeKind::Block(statements) = &mut node.kind {
            for statement in statements {
                self.symbol_collector_check_node(statement)?;
            }
        }

        self.symbol_table.exit_scope();
        Ok((None, None))
    }

    fn collect_type_symbols(
        &mut self,
        name: &str,
        generic_parameters: &mut [AstNode],
        span: Span,
    ) -> Result<(Option<ValueSymbolId>, Option<Type>), BoxedError> {
        let (scope_id, generics) = if !generic_parameters.is_empty() {
            let scope_id = self.symbol_table.enter_scope(ScopeKind::Type);
            let generics = self.collect_generic_parameters(generic_parameters)?;
            self.symbol_table.exit_scope();

            (Some(scope_id), generics)
        } else {
            (None, vec![])
        };

        let type_id = self.symbol_table.add_type_symbol(
            name,
            TypeSymbolKind::TypeAlias((scope_id, None)),
            generics,
            QualifierKind::Public,
            Some(span),
        )?;
        Ok((None, Some(Type::new_base(type_id))))
    }

    fn collect_optional_node(&mut self, node: &mut Option<BoxedAstNode>) -> Result<(), BoxedError> {
        if let Some(n) = node {
            self.symbol_collector_check_node(n)?;
        }
        Ok(())
    }
}

impl SemanticAnalyzer {
    pub fn generic_constraints_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.generic_constraints_check_node(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn generic_constraints_check_node(&mut self, statement: &mut AstNode) -> Result<(), BoxedError> {
        match &statement.kind {
            AstNodeKind::GenericParameter { .. } => self.collect_generic_constraint(statement),
            _ => {
                for node in statement.children_mut() {
                    self.generic_constraints_check_node(node)?;
                }

                Ok(())
            }
        }
    }

    fn collect_generic_constraint(&mut self, node: &mut AstNode) -> Result<(), BoxedError> {
        node.scope_id = Some(self.symbol_table.get_current_scope_id());

        if node.type_id.is_none() {
            return Ok(());
        }

        let AstNodeKind::GenericParameter { constraints, .. } = &mut node.kind else {
            unreachable!();
        };
        let mut trait_ids = vec![];

        for constraint in constraints.iter() {
            let type_symbol = self.symbol_table.find_type_symbol(constraint).ok_or_else(|| {
                self.create_error(
                    ErrorKind::UnknownIdentifier(constraint.clone()),
                    node.span,
                    &[node.span],
                )
            })?;

            if !matches!(type_symbol.kind, TypeSymbolKind::Trait(_)) {
                return Err(self.create_error(
                    ErrorKind::InvalidConstraint(constraint.clone()),
                    node.span,
                    &[node.span],
                ));
            }

            trait_ids.push(type_symbol.id);
        }

        let type_symbol = self
            .symbol_table
            .get_type_symbol_mut(node.type_id.as_ref().unwrap().get_base_symbol())
            .unwrap();
        if let TypeSymbolKind::Generic(constraints) = &mut type_symbol.kind {
            *constraints = trait_ids;
        }

        Ok(())
    }
}

impl SemanticAnalyzer {
    pub fn impl_collector_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.impl_collector_check_node(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn impl_collector_check_node(&mut self, statement: &mut AstNode) -> Result<(), BoxedError> {
        match &statement.kind {
            AstNodeKind::ImplDeclaration { .. } => self.collect_and_register_impl_block(statement),
            _ => {
                for node in statement.children_mut() {
                    self.impl_collector_check_node(node)?;
                }

                Ok(())
            }
        }
    }

    fn collect_and_register_impl_block(&mut self, node: &mut AstNode) -> Result<(), BoxedError> {
        let (
            associated_constants,
            associated_types,
            associated_functions,
            impl_generics,
            type_reference,
            trait_node,
        ) = match &mut node.kind {
            AstNodeKind::ImplDeclaration {
                associated_constants,
                associated_types,
                associated_functions,
                generic_parameters,
                type_reference,
                trait_node,
            } => (
                associated_constants,
                associated_types,
                associated_functions,
                generic_parameters,
                type_reference,
                trait_node,
            ),
            _ => return Ok(()),
        };

        let impl_scope_id = self.symbol_table.enter_scope(ScopeKind::Impl);
        let impl_generic_param_ids = self.collect_generic_parameters(impl_generics)?;
        for generic in impl_generics.iter_mut() {
            self.collect_generic_constraint(generic)?;
        }

        node.scope_id = Some(impl_scope_id);
        type_reference.scope_id = Some(impl_scope_id);

        if let Some(trait_node) = trait_node {
            trait_node.scope_id = Some(impl_scope_id);

            let (trait_id, trait_generic_specialization) = self.resolve_type_ref_from_ast(trait_node)?;
            let (implementing_type_id, type_specialization) =
                self.resolve_type_ref_from_ast(type_reference)?;

            self.symbol_table.add_type_symbol(
                "Self",
                TypeSymbolKind::TypeAlias((None, Some(Type::new_base(implementing_type_id)))),
                vec![],
                QualifierKind::Public,
                None,
            )?;

            self.collect_impl_body_symbols(associated_constants, associated_types, associated_functions)?;

            let trait_impl = TraitImpl {
                impl_scope_id,
                impl_generic_params: impl_generic_param_ids,
                trait_generic_specialization,
                type_specialization,
            };

            self.trait_registry
                .register(trait_id, implementing_type_id, trait_impl);
        } else {
            let (base_type_id, specialization) = self.resolve_type_ref_from_ast(type_reference)?;

            let base_type_symbol = self.symbol_table.get_type_symbol(base_type_id).unwrap();
            let aliased_type_id = base_type_symbol.id;
            self.symbol_table.add_type_symbol(
                "Self",
                TypeSymbolKind::TypeAlias((None, Some(Type::new_base(aliased_type_id)))),
                vec![],
                QualifierKind::Public,
                None,
            )?;

            self.collect_impl_body_symbols(associated_constants, associated_types, associated_functions)?;

            let impl_block = InherentImpl {
                scope_id: impl_scope_id,
                specialization,
                generic_params: impl_generic_param_ids,
            };

            let invalid_impl_error = self.create_error(
                ErrorKind::InvalidImpl(Some(
                    self.symbol_table
                        .get_type_name(self.symbol_table.get_type_symbol(base_type_id).unwrap().name_id)
                        .to_string(),
                )),
                type_reference.span,
                &[type_reference.span],
            );
            let base_type_symbol_mut = self.symbol_table.get_type_symbol_mut(base_type_id).unwrap();

            match &mut base_type_symbol_mut.kind {
                TypeSymbolKind::Struct((_, impls)) | TypeSymbolKind::Enum((_, impls)) => {
                    impls.push(impl_block);
                }
                _ => return Err(invalid_impl_error),
            }
        }

        self.symbol_table.exit_scope();
        Ok(())
    }

    fn collect_impl_body_symbols(
        &mut self,
        associated_constants: &mut [AstNode],
        associated_types: &mut [AstNode],
        associated_functions: &mut [AstNode],
    ) -> Result<(), BoxedError> {
        for func_node in associated_functions {
            if let AstNodeKind::Function {
                qualifier,
                name,
                generic_parameters,
                parameters,
                body,
                instance,
                return_type
            } = &mut func_node.kind
            {
                let func_scope_id = self.symbol_table.enter_scope(ScopeKind::Function);
                func_node.scope_id = Some(func_scope_id);

                let scope = self.symbol_table.get_scope_mut(func_scope_id).unwrap();
                scope.receiver_kind = *instance;

                self.collect_generic_parameters(generic_parameters)?;
                for generic in generic_parameters.iter_mut() {
                    self.collect_generic_constraint(generic)?;
                }

                self.collect_function_parameters(parameters)?;
                self.symbol_collector_check_node(body.as_mut().unwrap())?;
                self.collect_optional_node(return_type)?;
                self.symbol_table.exit_scope();

                func_node.value_id = Some(self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Function(func_scope_id),
                    false,
                    qualifier.unwrap(),
                    None,
                    Some(func_node.span),
                )?);
            }
        }

        for const_node in associated_constants {
            const_node.scope_id = Some(self.symbol_table.get_current_scope_id());

            if let AstNodeKind::AssociatedConstant { qualifier, name, type_annotation, initializer } = &mut const_node.kind {
                let const_id = self.symbol_table.add_value_symbol(
                    name,
                    ValueSymbolKind::Variable,
                    false,
                    *qualifier,
                    None,
                    Some(const_node.span),
                )?;
                const_node.value_id = Some(const_id);

                self.collect_optional_node(type_annotation)?;
                self.symbol_collector_check_node(initializer)?;
            }
        }

        for type_node in associated_types {
            type_node.scope_id = Some(self.symbol_table.get_current_scope_id());

            if let AstNodeKind::AssociatedType { name, qualifier, value } = &mut type_node.kind {
                let type_id = self.symbol_table.add_type_symbol(
                    name,
                    TypeSymbolKind::TypeAlias((None, None)),
                    vec![],
                    *qualifier,
                    Some(type_node.span),
                )?;
                type_node.type_id = Some(Type::new_base(type_id));

                self.symbol_collector_check_node(value)?;
            }
        }

        Ok(())
    }

    fn find_type_by_name(&self, node: &AstNode) -> Result<TypeSymbolId, BoxedError> {
        let name = node
            .get_name()
            .ok_or_else(|| self.create_error(ErrorKind::ExpectedType, node.span, &[node.span]))?;

        let type_symbol = self.symbol_table.find_type_symbol(&name).ok_or_else(|| {
            self.create_error(
                ErrorKind::UnknownIdentifier(name.clone()),
                node.span,
                &[node.span],
            )
        })?;

        Ok(type_symbol.id)
    }

    fn resolve_type_ref_from_ast(
        &self,
        node: &AstNode,
    ) -> Result<(TypeSymbolId, Vec<TypeSymbolId>), BoxedError> {
        let (name, arg_nodes) = match &node.kind {
            AstNodeKind::TypeReference {
                type_name,
                generic_types,
                ..
            } => (type_name, generic_types),
            _ => return Err(self.create_error(ErrorKind::ExpectedType, node.span, &[node.span])),
        };

        let base_type_id = self
            .symbol_table
            .find_type_symbol(name)
            .ok_or_else(|| {
                self.create_error(
                    ErrorKind::UnknownIdentifier(name.clone()),
                    node.span,
                    &[node.span],
                )
            })?
            .id;

        let mut arg_ids = vec![];
        for arg_node in arg_nodes {
            let arg_id = self.resolve_type_ref_from_ast(arg_node)?.0;
            arg_ids.push(arg_id);
        }

        Ok((base_type_id, arg_ids))
    }
}


// middle/uv_collector.rs
// middle/uv_collector.rs
use crate::{
    boxed,
    frontend::ast::{AstNode, AstNodeKind, BoxedAstNode},
    middle::semantic_analyzer::{
        Constraint, ConstraintInfo, PrimitiveKind, ScopeId, ScopeKind, SemanticAnalyzer, Type, TypeSymbolId,
        TypeSymbolKind,
    },
    utils::{
        error::{BoxedError, Error, ErrorKind},
        kind::{Operation, QualifierKind, ReferenceKind, Span},
    },
};

impl SemanticAnalyzer {
    fn get_primitive_type(&self, primitive: PrimitiveKind) -> TypeSymbolId {
        self.builtin_types[primitive as usize]
    }

    fn get_type_of_identifier(&self, scope_id: ScopeId, name: &str, span: Span) -> Result<Type, BoxedError> {
        match self.symbol_table.find_value_symbol_from_scope(scope_id, name) {
            Some(value_symbol) => match value_symbol.type_id.clone() {
                Some(type_id) => Ok(type_id),
                None => Err(self.create_error(ErrorKind::UnresolvedType(name.to_string()), span, &[span])),
            },
            None => Err(self.create_error(ErrorKind::UnknownIdentifier(name.to_string()), span, &[span])),
        }
    }

    fn collect_uv_unary_operation(
        &mut self,
        uv_id: TypeSymbolId,
        operator: &mut Operation,
        operand: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let uv_type = self.collect_uvs(operand)?;
        let result_uv = Type::new_base(uv_id);

        match operator.to_trait_data() {
            Some((trait_name, _)) => {
                self.unification_context.register_constraint(
                    Constraint::Operation(
                        result_uv,
                        Type::new_base(self.trait_registry.get_default_trait(&trait_name)),
                        uv_type,
                        None,
                    ),
                    info,
                );
            }
            None => match operator {
                Operation::Dereference => self.unification_context.register_constraint(
                    Constraint::Equality(uv_type, Type::Reference(Box::new(result_uv))),
                    info,
                ),
                Operation::ImmutableAddressOf => self.unification_context.register_constraint(
                    Constraint::Equality(result_uv, Type::Reference(boxed!(uv_type))),
                    info,
                ),
                Operation::MutableAddressOf => self.unification_context.register_constraint(
                    Constraint::Equality(result_uv, Type::MutableReference(boxed!(uv_type))),
                    info,
                ),
                _ => unreachable!(),
            },
        }

        Ok(())
    }

    fn collect_uv_binary_operation(
        &mut self,
        uv_id: TypeSymbolId,
        left: &mut BoxedAstNode,
        right: &mut BoxedAstNode,
        operator: &mut Operation,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let left_type = self.collect_uvs(left)?;
        let right_type = self.collect_uvs(right)?;
        let result_uv = Type::new_base(uv_id);

        match operator.to_trait_data() {
            Some((trait_name, _)) => {
                self.unification_context.register_constraint(
                    Constraint::Operation(
                        result_uv,
                        Type::Base {
                            symbol: self.trait_registry.get_default_trait(&trait_name),
                            args: vec![right_type.clone()],
                        },
                        left_type,
                        Some(right_type),
                    ),
                    info,
                );
            }
            None => match operator {
                Operation::Assign => {
                    self.unification_context
                        .register_constraint(Constraint::Equality(left_type, right_type), info);

                    self.unification_context.register_constraint(
                        Constraint::Equality(
                            result_uv,
                            Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                        ),
                        info,
                    );
                }
                _ => unreachable!(),
            },
        }

        Ok(())
    }

    fn collect_uv_conditional_operation(
        &mut self,
        uv_id: TypeSymbolId,
        left: &mut BoxedAstNode,
        right: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let left_type = self.collect_uvs(left)?;
        let right_type = self.collect_uvs(right)?;
        let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));

        self.unification_context
            .register_constraint(Constraint::Equality(left_type, bool_type.clone()), info);
        self.unification_context
            .register_constraint(Constraint::Equality(right_type, bool_type.clone()), info);
        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), bool_type),
            info,
        );

        Ok(())
    }

    fn collect_uv_variable_declaration(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let AstNodeKind::VariableDeclaration {
            type_annotation,
            initializer,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let init_type = if let Some(init) = initializer {
            Some(self.collect_uvs(init)?)
        } else {
            None
        };

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        if let Some(annot) = type_annotation {
            let annot_type = self.collect_uvs(annot)?;

            if let Some(init_type) = init_type {
                self.unification_context
                    .register_constraint(Constraint::Equality(annot_type.clone(), init_type), info);
            }

            self.unification_context
                .register_constraint(Constraint::Equality(symbol_uv.clone(), annot_type), info);
        } else if let Some(init_type) = init_type {
            self.unification_context
                .register_constraint(Constraint::Equality(symbol_uv.clone(), init_type), info);
        } else {
            return Err(self.create_error(ErrorKind::BadVariableDeclaration, span, &[span]));
        }

        self.symbol_table
            .get_value_symbol_mut(node.value_id.unwrap())
            .unwrap()
            .type_id = Some(symbol_uv.clone());

        Ok(())
    }

    fn collect_uv_block(
        &mut self,
        uv_id: TypeSymbolId,
        statements: &mut [AstNode],
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let mut last_type = None;

        for stmt in statements.iter_mut() {
            last_type = Some(self.collect_uvs(stmt)?);
        }

        if let Some(last_type) = last_type {
            self.unification_context.register_constraint(
                Constraint::Equality(Type::new_base(uv_id), last_type),
                info,
            );
        }

        Ok(())
    }

    fn collect_uv_if_statement(
        &mut self,
        uv_id: TypeSymbolId,
        condition: &mut BoxedAstNode,
        then_branch: &mut BoxedAstNode,
        else_if_branches: &mut [(BoxedAstNode, BoxedAstNode)],
        else_branch: &mut Option<BoxedAstNode>,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let cond_type = self.collect_uvs(condition)?;
        let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));
        self.unification_context
            .register_constraint(Constraint::Equality(cond_type, bool_type.clone()), info);

        let then_type = self.collect_uvs(then_branch)?;
        let mut branch_types = vec![then_type.clone()];

        for (elif_cond, elif_branch) in else_if_branches.iter_mut() {
            let elif_cond_type = self.collect_uvs(elif_cond)?;
            self.unification_context
                .register_constraint(Constraint::Equality(elif_cond_type, bool_type.clone()), info);
            let elif_type = self.collect_uvs(elif_branch)?;
            branch_types.push(elif_type);
        }

        if let Some(else_node) = else_branch {
            let else_type = self.collect_uvs(else_node)?;
            branch_types.push(else_type);
        }

        for branch_type in &branch_types {
            self.unification_context.register_constraint(
                Constraint::Equality(Type::new_base(uv_id), branch_type.clone()),
                info,
            );
        }

        Ok(())
    }

    fn collect_uv_while_loop(
        &mut self,
        uv_id: TypeSymbolId,
        condition: &mut BoxedAstNode,
        body: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let cond_type = self.collect_uvs(condition)?;
        let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));
        self.unification_context
            .register_constraint(Constraint::Equality(cond_type, bool_type), info);

        self.collect_uvs(body)?;

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        Ok(())
    }

    fn collect_uv_for_loop(
        &mut self,
        uv_id: TypeSymbolId,
        initializer: &mut Option<BoxedAstNode>,
        condition: &mut Option<BoxedAstNode>,
        increment: &mut Option<BoxedAstNode>,
        body: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        if let Some(init) = initializer {
            self.collect_uvs(init)?;
        }

        if let Some(cond) = condition {
            let cond_type = self.collect_uvs(cond)?;
            let bool_type = Type::new_base(self.get_primitive_type(PrimitiveKind::Bool));
            self.unification_context
                .register_constraint(Constraint::Equality(cond_type, bool_type), info);
        }

        if let Some(inc) = increment {
            self.collect_uvs(inc)?;
        }

        self.collect_uvs(body)?;

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        Ok(())
    }

    fn collect_uv_return(
        &mut self,
        uv_id: TypeSymbolId,
        opt_expr: &mut Option<BoxedAstNode>,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Never)),
            ),
            info,
        );

        let Some(expected_return_type) = self.current_return_type.clone() else {
             return Err(self.create_error(ErrorKind::InvalidReturn, info.span, &[info.span]));
        };

        let value_type = if let Some(expr) = opt_expr {
            self.collect_uvs(expr)?
        } else {
            Type::new_base(self.get_primitive_type(PrimitiveKind::Void))
        };
        
        self.unification_context.register_constraint(
            Constraint::Equality(expected_return_type, value_type),
            info,
        );

        Ok(())
    }

    fn collect_uv_function(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let AstNodeKind::Function {
            name,
            generic_parameters,
            parameters,
            return_type,
            instance,
            body,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        let is_declaration = !name.is_empty();

        let symbol_uv_opt = if is_declaration {
            let uv = self
                .unification_context
                .generate_uv_type(&mut self.symbol_table, span);

            self.symbol_table
                .get_value_symbol_mut(node.value_id.unwrap())
                .unwrap()
                .type_id = Some(uv.clone());

            Some(uv)
        } else {
            None
        };

        let generic_types: Vec<TypeSymbolId> = generic_parameters
            .iter_mut()
            .map(|p| self.collect_uvs(p).map(|t| t.get_base_symbol()))
            .collect::<Result<_, _>>()?;

        for param_node in parameters.iter_mut() {
            self.collect_uvs(param_node)?;
        }

        let param_types: Vec<Type> = parameters
            .iter()
            .map(|p| {
                self.symbol_table
                    .get_value_symbol(p.value_id.unwrap())
                    .unwrap()
                    .type_id
                    .clone()
                    .unwrap()
            })
            .collect();

        let return_type_val = if let Some(rt_node) = return_type {
            self.collect_uvs(rt_node)?
        } else {
            Type::new_base(self.get_primitive_type(PrimitiveKind::Void))
        };

        let old_return_type = self.current_return_type.clone();
        self.current_return_type = Some(return_type_val.clone());

        if let Some(body_node) = body {
            self.collect_uvs(body_node)?;
        }

        self.current_return_type = old_return_type;

        let fn_sig_type_id = self.symbol_table.add_type_symbol(
            &format!("#fn_sig_{}", uv_id),
            TypeSymbolKind::FunctionSignature {
                params: param_types,
                return_type: return_type_val,
                instance: *instance,
            },
            generic_types,
            QualifierKind::Private,
            Some(span),
        )?;

        let fn_sig_type = Type::new_base(fn_sig_type_id);

        if is_declaration {
            self.unification_context.register_constraint(
                Constraint::Equality(
                    Type::new_base(uv_id),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                ),
                info,
            );

            self.unification_context
                .register_constraint(Constraint::Equality(symbol_uv_opt.unwrap(), fn_sig_type), info);
        } else {
            self.unification_context
                .register_constraint(Constraint::Equality(Type::new_base(uv_id), fn_sig_type), info);
        }

        Ok(())
    }

    fn collect_uv_function_parameter(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let AstNodeKind::FunctionParameter {
            type_annotation,
            initializer,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let annotation_type = self.collect_uvs(type_annotation)?;

        if let Some(init_node) = initializer {
            let init_type = self.collect_uvs(init_node)?;
            self.unification_context
                .register_constraint(Constraint::Equality(init_type, annotation_type.clone()), info);
        }

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        self.unification_context
            .register_constraint(Constraint::Equality(symbol_uv.clone(), annotation_type), info);

        self.symbol_table
            .get_value_symbol_mut(node.value_id.unwrap())
            .unwrap()
            .type_id = Some(symbol_uv);

        Ok(())
    }

    fn collect_uv_function_pointer(
        &mut self,
        uv_id: TypeSymbolId,
        params: &mut [AstNode],
        return_type_node: &mut Option<BoxedAstNode>,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let param_types: Vec<Type> = params
            .iter_mut()
            .map(|p| self.collect_uvs(p))
            .collect::<Result<_, _>>()?;

        let return_type = if let Some(rt_node) = return_type_node {
            self.collect_uvs(rt_node)?
        } else {
            Type::new_base(self.get_primitive_type(PrimitiveKind::Void))
        };

        let fn_ptr_sig_id = self.symbol_table.add_type_symbol(
            &format!("#fn_ptr_sig_{}", uv_id),
            TypeSymbolKind::FunctionSignature {
                params: param_types,
                return_type,
                instance: None,
            },
            vec![],
            QualifierKind::Private,
            Some(span),
        )?;

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), Type::new_base(fn_ptr_sig_id)),
            info,
        );

        Ok(())
    }

    fn collect_uv_struct_literal(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        name: &str,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let Some(symbol) = self.symbol_table.find_type_symbol_from_scope(scope_id, name) else {
            return Err(self.create_error(ErrorKind::UnknownIdentifier(name.to_owned()), span, &[span]));
        };

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), Type::new_base(symbol.id)),
            info,
        );

        Ok(())
    }

    fn collect_uv_associated_const(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let AstNodeKind::AssociatedConstant {
            type_annotation,
            initializer,
            ..
        } = &mut node.kind
        else {
            unreachable!();
        };

        let init_type = self.collect_uvs(initializer)?;

        if let Some(annot) = type_annotation {
            let annot_type = self.collect_uvs(annot)?;

            self.unification_context
                .register_constraint(Constraint::Equality(annot_type, init_type.clone()), info);
        }

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        self.unification_context
            .register_constraint(Constraint::Equality(symbol_uv.clone(), init_type), info);

        self.symbol_table
            .get_value_symbol_mut(node.value_id.unwrap())
            .unwrap()
            .type_id = Some(symbol_uv.clone());

        Ok(())
    }

    fn collect_uv_type_reference(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        type_name: &str,
        generic_types: &mut [AstNode],
        reference_kind: &mut ReferenceKind,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let symbol = self
            .symbol_table
            .find_type_symbol_from_scope(scope_id, type_name)
            .ok_or_else(|| {
                self.create_error(ErrorKind::UnknownIdentifier(type_name.to_owned()), span, &[span])
            })?
            .id;

        let args: Vec<Type> = generic_types
            .iter_mut()
            .map(|generic_type| self.collect_uvs(generic_type))
            .collect::<Result<Vec<_>, _>>()?;

        let base_symbol = Type::Base { symbol, args };

        let constraint = match reference_kind {
            ReferenceKind::Value => base_symbol,
            ReferenceKind::Reference => Type::Reference(boxed!(base_symbol)),
            ReferenceKind::MutableReference => Type::MutableReference(boxed!(base_symbol)),
        };

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), constraint),
            info,
        );

        Ok(())
    }

    fn collect_uv_type_declaration(
        &mut self,
        uv_id: TypeSymbolId,
        node: &mut AstNode,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let initializer_type = if let AstNodeKind::AssociatedType { value, .. } = &mut node.kind {
            self.collect_uvs(value)?
        } else if let AstNodeKind::TypeDeclaration { value, .. } = &mut node.kind {
            self.collect_uvs(value)?
        } else {
            unreachable!();
        };

        let symbol_uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        self.unification_context
            .register_constraint(Constraint::Equality(symbol_uv.clone(), initializer_type), info);

        let type_symbol = self
            .symbol_table
            .get_type_symbol_mut(node.type_id.as_mut().unwrap().get_base_symbol())
            .unwrap();

        let TypeSymbolKind::TypeAlias((_, alias)) = &mut type_symbol.kind else {
            unreachable!();
        };
        *alias = Some(symbol_uv);

        Ok(())
    }

    fn collect_uv_self_value(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let mut function_scope = self.symbol_table.get_scope(scope_id).unwrap();
        while function_scope.kind != ScopeKind::Function {
            match function_scope.parent {
                Some(parent_id) => function_scope = self.symbol_table.get_scope(parent_id).unwrap(),
                None => {
                    return Err(self.create_error(
                        ErrorKind::InvalidThis("outside of a function"),
                        span,
                        &[span],
                    ))
                }
            }
        }

        let receiver_kind = match function_scope.receiver_kind {
            Some(kind) => kind,
            None => {
                return Err(self.create_error(
                    ErrorKind::InvalidThis("in a static method without a 'this' parameter"),
                    span,
                    &[span],
                ))
            }
        };

        let impl_scope = match function_scope.parent {
            Some(parent_id) => self.symbol_table.get_scope(parent_id).unwrap(),
            None => {
                return Err(self.create_error(
                    ErrorKind::InvalidThis("outside of an impl block"),
                    span,
                    &[span],
                ))
            }
        };

        if impl_scope.kind != ScopeKind::Impl {
            return Err(self.create_error(ErrorKind::InvalidThis("outside of an impl block"), span, &[span]));
        }

        let TypeSymbolKind::TypeAlias((_, Some(self_type))) = &self
            .symbol_table
            .find_type_symbol_from_scope(impl_scope.id, "Self")
            .ok_or_else(|| self.create_error(ErrorKind::SelfOutsideImpl, span, &[span]))?
            .kind
        else {
            unreachable!();
        };

        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                match receiver_kind {
                    ReferenceKind::Value => self_type.clone(),
                    ReferenceKind::Reference => Type::Reference(Box::new(self_type.clone())),
                    ReferenceKind::MutableReference => Type::MutableReference(Box::new(self_type.clone())),
                },
            ),
            info,
        );

        Ok(())
    }

    fn collect_uv_self_type(
        &mut self,
        uv_id: TypeSymbolId,
        scope_id: ScopeId,
        reference_kind: ReferenceKind,
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let self_symbol = self
            .symbol_table
            .find_type_symbol_from_scope(scope_id, "Self")
            .ok_or_else(|| self.create_error(ErrorKind::SelfOutsideImpl, span, &[span]))?;

        if let TypeSymbolKind::TypeAlias((_, Some(concrete_type))) = &self_symbol.kind {
            self.unification_context.register_constraint(
                Constraint::Equality(
                    Type::new_base(uv_id),
                    match reference_kind {
                        ReferenceKind::Value => concrete_type.clone(),
                        ReferenceKind::Reference => Type::Reference(boxed!(concrete_type.clone())),
                        ReferenceKind::MutableReference => {
                            Type::MutableReference(boxed!(concrete_type.clone()))
                        }
                    },
                ),
                info,
            );
        }

        Ok(())
    }

    fn collect_uv_field_access(
        &mut self,
        uv_id: TypeSymbolId,
        left: &mut BoxedAstNode,
        right: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let right_name = right
            .get_name()
            .ok_or_else(|| self.create_error(ErrorKind::ExpectedIdentifier, right.span, &[right.span]))?;

        if let AstNodeKind::Identifier(left_name) = &left.kind {
            if let Some(type_symbol) = self
                .symbol_table
                .find_type_symbol_from_scope(left.scope_id.unwrap(), left_name)
            {
                let static_type = Type::new_base(type_symbol.id);
                left.type_id = Some(static_type.clone());

                self.unification_context.register_constraint(
                    Constraint::StaticMemberAccess(Type::new_base(uv_id), static_type, right_name),
                    info,
                );

                return Ok(());
            }
        }

        let left_type = self.collect_uvs(left)?;

        self.unification_context.register_constraint(
            Constraint::InstanceMemberAccess(Type::new_base(uv_id), left_type, right_name),
            info,
        );

        Ok(())
    }

    fn collect_uv_function_call(
        &mut self,
        uv_id: TypeSymbolId,
        function_node: &mut BoxedAstNode,
        arguments: &mut [AstNode],
        span: Span,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let function_type = self.collect_uvs(function_node)?;

        let argument_types: Vec<Type> = arguments
            .iter_mut()
            .map(|arg| self.collect_uvs(arg))
            .collect::<Result<_, _>>()?;

        let return_uv_type = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, span);

        let mut is_method_call = false;
        if let AstNodeKind::FieldAccess { left, .. } = &mut function_node.kind {
            if let AstNodeKind::Identifier(left_name) = &left.kind {
                if self
                    .symbol_table
                    .find_type_symbol_from_scope(left.scope_id.unwrap(), left_name)
                    .is_none()
                {
                    is_method_call = true;

                    let instance_type = left
                        .type_id
                        .clone()
                        .expect("instance in method call should have a type");

                    self.unification_context.register_constraint(
                        Constraint::MethodCall(
                            instance_type,
                            function_type.clone(),
                            argument_types.clone(),
                            return_uv_type.clone(),
                        ),
                        info,
                    );
                }
            }
        }

        if !is_method_call {
            self.unification_context.register_constraint(
                Constraint::FunctionSignature(function_type, argument_types, return_uv_type.clone()),
                info,
            );
        }

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), return_uv_type),
            info,
        );

        Ok(())
    }

    fn collect_uv_struct_field(
        &mut self,
        uv_id: TypeSymbolId,
        name: &str,
        type_annotation: &mut BoxedAstNode,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        self.unification_context.register_constraint(
            Constraint::Equality(
                Type::new_base(uv_id),
                Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
            ),
            info,
        );

        let annotation_type = self.collect_uvs(type_annotation)?;
        self.symbol_table
            .find_value_symbol_in_scope_mut(name, info.scope_id)
            .unwrap()
            .type_id = Some(annotation_type);

        Ok(())
    }

    fn collect_uv_enum_variant(
        &mut self,
        uv_id: TypeSymbolId,
        info: ConstraintInfo,
    ) -> Result<(), BoxedError> {
        let enum_scope = self.symbol_table.get_scope(info.scope_id).unwrap();
        let enum_parent_scope = self
            .symbol_table
            .get_scope(enum_scope.parent.unwrap())
            .unwrap();

        let enum_type_symbol = enum_parent_scope
            .types
            .values()
            .find_map(|type_id| {
                let symbol = self.symbol_table.get_type_symbol(*type_id).unwrap();
                if let TypeSymbolKind::Enum((scope, _)) = symbol.kind {
                    if scope == info.scope_id {
                        return Some(symbol);
                    }
                }
                None
            })
            .unwrap();

        let enum_type = Type::new_base(enum_type_symbol.id);

        self.unification_context.register_constraint(
            Constraint::Equality(Type::new_base(uv_id), enum_type.clone()),
            info,
        );

        Ok(())
    }
}

impl SemanticAnalyzer {
    pub fn uv_collector_pass(&mut self, program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];

        if let AstNodeKind::Program(statements) = &mut program.kind {
            for statement in statements {
                if let Err(err) = self.collect_uvs(statement) {
                    errors.push(*err);
                }
            }
        } else {
            unreachable!();
        }

        errors
    }

    fn collect_uvs(&mut self, expr: &mut AstNode) -> Result<Type, BoxedError> {
        use AstNodeKind::*;

        let uv = self
            .unification_context
            .generate_uv_type(&mut self.symbol_table, expr.span);
        let uv_id = uv.get_base_symbol();

        let info = ConstraintInfo {
            span: expr.span,
            scope_id: expr.scope_id.unwrap_or_else(|| panic!("scope_id should exist on node, especially this one: {} \n{:?}", expr, expr)),
        };

        match &mut expr.kind {
            IntegerLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Int)),
                ),
                info,
            ),
            FloatLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Float)),
                ),
                info,
            ),
            BooleanLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Bool)),
                ),
                info,
            ),
            StringLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::String)),
                ),
                info,
            ),
            CharLiteral(_) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Char)),
                ),
                info,
            ),
            Identifier(string) => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(),
                    self.get_type_of_identifier(expr.scope_id.unwrap(), string, expr.span)?,
                ),
                info,
            ),

            UnaryOperation { operator, operand } => {
                self.collect_uv_unary_operation(uv_id, operator, operand, info)?
            }
            BinaryOperation {
                left,
                right,
                operator,
            } => self.collect_uv_binary_operation(uv_id, left, right, operator, info)?,
            ConditionalOperation { left, right, .. } => {
                self.collect_uv_conditional_operation(uv_id, left, right, info)?
            }
            VariableDeclaration { .. } => {
                self.collect_uv_variable_declaration(uv_id, expr, expr.span, info)?
            }
            Block(statements) => self.collect_uv_block(uv_id, statements, info)?,
            IfStatement {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => self.collect_uv_if_statement(
                uv_id,
                condition,
                then_branch,
                else_if_branches,
                else_branch,
                info,
            )?,
            WhileLoop { condition, body } => self.collect_uv_while_loop(uv_id, condition, body, info)?,
            ForLoop {
                initializer,
                condition,
                increment,
                body,
            } => self.collect_uv_for_loop(uv_id, initializer, condition, increment, body, info)?,
            Return(opt_expr) => self.collect_uv_return(uv_id, opt_expr, info)?,
            Function { .. } => self.collect_uv_function(uv_id, expr, expr.span, info)?,
            FunctionPointer { params, return_type } => {
                self.collect_uv_function_pointer(uv_id, params, return_type, expr.span, info)?
            }
            FunctionParameter { .. } => self.collect_uv_function_parameter(uv_id, expr, expr.span, info)?,
            StructLiteral { name, .. } => {
                self.collect_uv_struct_literal(uv_id, expr.scope_id.unwrap(), name, expr.span, info)?
            }
            AssociatedConstant { .. } => self.collect_uv_associated_const(uv_id, expr, expr.span, info)?,
            SelfValue => self.collect_uv_self_value(uv_id, expr.scope_id.unwrap(), expr.span, info)?,
            SelfType(reference_kind) => {
                self.collect_uv_self_type(uv_id, expr.scope_id.unwrap(), *reference_kind, expr.span, info)?
            }
            FieldAccess { left, right } => self.collect_uv_field_access(uv_id, left, right, info)?,
            FunctionCall { function, arguments } => {
                self.collect_uv_function_call(uv_id, function, arguments, expr.span, info)?
            }
            TypeReference {
                type_name,
                generic_types,
                reference_kind,
            } => self.collect_uv_type_reference(
                uv_id,
                expr.scope_id.unwrap(),
                type_name,
                generic_types,
                reference_kind,
                expr.span,
                info,
            )?,
            AssociatedType { .. } | TypeDeclaration { .. } => self.collect_uv_type_declaration(uv_id, expr, expr.span, info)?,
            StructField { name, type_annotation, .. } => {
                self.collect_uv_struct_field(uv_id, name, type_annotation, info)?
            }
            EnumVariant(_) => self.collect_uv_enum_variant(uv_id, info)?,
            Break | Continue => self.unification_context.register_constraint(
                Constraint::Equality(
                    uv.clone(), 
                    Type::new_base(self.get_primitive_type(PrimitiveKind::Never))
                ),
                info
            ),
            StructDeclaration { .. }
            | EnumDeclaration { .. }
            | TraitDeclaration { .. }
            | ImplDeclaration { .. } => {
                self.unification_context.register_constraint(
                    Constraint::Equality(
                        uv.clone(),
                        Type::new_base(self.get_primitive_type(PrimitiveKind::Void)),
                    ),
                    info,
                );

                for child in expr.children_mut() {
                    self.collect_uvs(child)?;
                }
            }
            _ => {
                for child in expr.children_mut() {
                    self.collect_uvs(child)?;
                }
            }
        }

        expr.type_id = Some(uv.clone());

        Ok(uv)
    }
}

// middle/unification.rs
use std::collections::HashMap;

use crate::{
    frontend::ast::AstNode,
    middle::semantic_analyzer::{
        Constraint, ConstraintInfo, SemanticAnalyzer, Type, TypeSymbolId, TypeSymbolKind, ValueSymbolKind
    },
    utils::error::{BoxedError, Error, ErrorKind},
};

impl SemanticAnalyzer {
    fn is_uv(&self, symbol_id: TypeSymbolId) -> bool {
        matches!(
            self.symbol_table.get_type_symbol(symbol_id).unwrap().kind,
            TypeSymbolKind::UnificationVariable(_)
        )
    }
}

impl SemanticAnalyzer {
    /// Creates a substitution map from an impl's generic parameters to a concrete type's arguments.
    ///
    /// `impl<T, U> for MyStruct<T, U>` on `MyStruct<i32, bool>`
    /// returns a map `{ T -> i32, U -> bool }`.
    fn create_generic_substitution_map(
        &self,
        impl_generic_params: &[TypeSymbolId],
        concrete_args: &[Type],
    ) -> HashMap<TypeSymbolId, Type> {
        impl_generic_params
            .iter()
            .zip(concrete_args.iter())
            .map(|(param_id, concrete_type)| (*param_id, concrete_type.clone()))
            .collect()
    }

    /// Applies a substitution map to a type.
    fn apply_substitution(ty: &Type, substitutions: &HashMap<TypeSymbolId, Type>) -> Type {
        match ty {
            Type::Base { symbol, args } => {
                if let Some(substituted_type) = substitutions.get(symbol) {
                    if let Type::Base {
                        symbol: new_symbol,
                        args: new_args,
                    } = substituted_type
                    {
                        if new_args.is_empty() {
                            let final_args = args
                                .iter()
                                .map(|arg| Self::apply_substitution(arg, substitutions))
                                .collect();
                            return Type::Base {
                                symbol: *new_symbol,
                                args: final_args,
                            };
                        }
                    }
                    return substituted_type.clone();
                }

                let substituted_args = args
                    .iter()
                    .map(|arg| Self::apply_substitution(arg, substitutions))
                    .collect();
                Type::Base {
                    symbol: *symbol,
                    args: substituted_args,
                }
            }
            Type::Reference(inner) => {
                Type::Reference(Box::new(Self::apply_substitution(inner, substitutions)))
            }
            Type::MutableReference(inner) => Type::MutableReference(Box::new(
                Self::apply_substitution(inner, substitutions),
            )),
        }
    }

    /// Recursively resolves a type by applying substitutions for unification variables
    /// and expanding type aliases until a concrete type or a unification variable is reached.
    fn resolve_type(&self, ty: &Type) -> Type {
        let mut current_ty = Self::apply_substitution(ty, &self.unification_context.substitutions);

        loop {
            let Type::Base { symbol, args } = &current_ty else { break; };

            if self.is_uv(*symbol) {
                break;
            }

            let type_symbol = self.symbol_table.get_type_symbol(*symbol).unwrap();

            if let TypeSymbolKind::TypeAlias((_, Some(aliased_type))) = &type_symbol.kind {
                let substitutions = self.create_generic_substitution_map(
                    &type_symbol.generic_parameters,
                    args
                );

                let substituted_alias = Self::apply_substitution(aliased_type, &substitutions);
                current_ty = Self::apply_substitution(&substituted_alias, &self.unification_context.substitutions);
            } else {
                break;
            }
        }

        current_ty
    }

    /// Checks if a unification variable `uv_id` occurs within a type `ty`.
    /// https://en.wikipedia.org/wiki/Occurs_check
    fn occurs_check(&self, uv_id: TypeSymbolId, ty: &Type) -> bool {
        let resolved_ty = self.resolve_type(ty);

        match &resolved_ty {
            Type::Base { symbol, args } => {
                if *symbol == uv_id {
                    return true;
                }
                // No need to check substitutions here because resolve_type already did it.
                args.iter().any(|arg| self.occurs_check(uv_id, arg))
            }
            Type::Reference(inner) | Type::MutableReference(inner) => self.occurs_check(uv_id, inner),
        }
    }

    /// Unifies a metavariable with a type.
    fn unify_variable(
        &mut self,
        uv_id: TypeSymbolId,
        ty: Type,
        info: ConstraintInfo,
    ) -> Result<Type, BoxedError> {
        if self.occurs_check(uv_id, &ty) {
            return Err(self.type_mismatch_error(
                &Type::new_base(uv_id),
                &ty,
                info,
                Some("infinite type detected: a metavariable occurs within its own definition".to_string()),
            ));
        }

        self.unification_context.substitutions.insert(uv_id, ty.clone());
        Ok(ty)
    }

    /// Generates a mismatch error between types `t1` and `t2`.
    fn type_mismatch_error(
        &self,
        t1: &Type,
        t2: &Type,
        info: ConstraintInfo,
        specifics: Option<String>,
    ) -> BoxedError {
        self.create_error(
            ErrorKind::TypeMismatch(
                self.symbol_table.display_type(t1),
                self.symbol_table.display_type(t2),
                specifics,
            ),
            info.span,
            &[info.span],
        )
    }
}

impl SemanticAnalyzer {
    pub fn unification_pass(&mut self, _program: &mut AstNode) -> Vec<Error> {
        let mut errors = vec![];
        let mut constraints = std::mem::take(&mut self.unification_context.constraints);

        let mut iterations = 0;
        let limit = constraints.len() * 4 + 100;

        while let Some((constraint, info)) = constraints.pop_front() {
            if iterations > limit {
                // TODO: locate uvs that still have constraints attached
                break;
            }

            iterations += 1;

            match self.process_constraint(constraint.clone(), info) {
                Ok(success) if !success => constraints.push_back((constraint, info)),
                Err(e) => errors.push(*e),
                _ => (),
            }
        }

        errors
    }

    fn process_constraint(&mut self, constraint: Constraint, info: ConstraintInfo) -> Result<bool, BoxedError> {
        match constraint {
            Constraint::Equality(t1, t2) => {
                self.unify(t1, t2, info)?;
                Ok(true)
            },
            Constraint::FunctionSignature(callee_ty, params, return_ty) => {
                self.unify_function_signature(callee_ty, params, return_ty, info)
            },
            Constraint::MethodCall(instance_ty, callee_ty, params, return_ty) => {
                self.unify_method_call(instance_ty, callee_ty, params, return_ty, info)
            },
            Constraint::InstanceMemberAccess(result_ty, lhs_type, rhs_name) => {
                self.unify_instance_member_access(result_ty, lhs_type, rhs_name, info)
            },
            Constraint::StaticMemberAccess(result_ty, lhs_type, rhs_name) => {
                self.unify_static_member_access(result_ty, lhs_type, rhs_name, info)
            },
            // Constraint::Operation(uv_symbol_id, trait_type, lhs, rhs)
            // => self.unify_operation(uv_symbol_id, trait_type, lhs, rhs, info),
            _ => unreachable!(),
        }
    }

    fn unify(&mut self, t1: Type, t2: Type, info: ConstraintInfo) -> Result<Type, BoxedError> {
        let t1 = self.resolve_type(&t1);
        let t2 = self.resolve_type(&t2);

        match (t1.clone(), t2.clone()) {
            (t1, t2) if t1 == t2 => Ok(t1),

            (Type::Base { symbol: s, .. }, other) if self.is_uv(s) => self.unify_variable(s, other, info),
            (other, Type::Base { symbol: s, .. }) if self.is_uv(s) => self.unify_variable(s, other, info),

            (Type::Base { symbol: s1, args: a1 }, Type::Base { symbol: s2, args: a2 }) => {
                let type_sym_s1 = self.symbol_table.get_type_symbol(s1).unwrap();
                let type_sym_s2 = self.symbol_table.get_type_symbol(s2).unwrap();

                let resultant_symbol = type_sym_s1.unify(type_sym_s2)
                    .ok_or_else(|| self.type_mismatch_error(&t1, &t2, info, None))?;

                if a1.len() != a2.len() {
                    return Err(self.type_mismatch_error(&t1, &t2, info, Some(format!("expected {} generic arguments, but found {}", a1.len(), a2.len()))));
                }

                let mut unified_args = vec![];
                for (arg1, arg2) in a1.iter().zip(a2.iter()) {
                    unified_args.push(self.unify(arg1.clone(), arg2.clone(), info)?);
                }

                Ok(Type::Base {
                    symbol: resultant_symbol,
                    args: unified_args,
                })
            },
            (Type::Reference(inner1), Type::Reference(inner2)) => {
                let unified = self.unify(*inner1, *inner2, info)?;
                Ok(Type::Reference(Box::new(unified)))
            },
            (Type::MutableReference(inner1), Type::MutableReference(inner2)) => {
                let unified = self.unify(*inner1, *inner2, info)?;
                Ok(Type::MutableReference(Box::new(unified)))
            },

            (t1, t2) => Err(self.type_mismatch_error(&t1, &t2, info, None)),
        }
    }

    fn unify_function_signature(
        &mut self,
        callee_ty: Type,
        params: Vec<Type>,
        return_ty: Type,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let callee_ty = self.resolve_type(&callee_ty);

        match callee_ty.clone() {
            Type::Base { symbol, args } => {
                if self.is_uv(symbol) {
                    return Ok(false);
                }
                let callee_symbol = self.symbol_table.get_type_symbol(symbol).unwrap();

                if let TypeSymbolKind::FunctionSignature {
                    params: sig_params,
                    return_type: sig_return,
                    ..
                } = &callee_symbol.kind
                {
                    if params.len() != sig_params.len() {
                        return Err(self.create_error(
                            ErrorKind::ArityMismatch(sig_params.len(), params.len()),
                            info.span,
                            &[info.span],
                        ));
                    }
                    
                    let substitutions = self.create_generic_substitution_map(&callee_symbol.generic_parameters, &args);

                    let expected_params = sig_params.iter().map(|p| Self::apply_substitution(p, &substitutions)).collect::<Vec<_>>();
                    let expected_return = Self::apply_substitution(sig_return, &substitutions);

                    for (arg, expected) in params.iter().zip(expected_params.iter()) {
                        self.unify(arg.clone(), expected.clone(), info)?;
                    }

                    self.unify(return_ty, expected_return, info)?;
                    Ok(true)
                } else {
                    Err(self.create_error(
                        ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                        info.span,
                        &[info.span],
                    ))
                }
            }
            _ => Err(self.create_error(
                ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                info.span,
                &[info.span],
            )),
        }
    }

    fn unify_method_call(
        &mut self,
        instance_ty: Type,
        callee_ty: Type,
        params: Vec<Type>,
        return_ty: Type,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let callee_ty = self.resolve_type(&callee_ty);

        let (callee_symbol_id, callee_args) = match callee_ty.clone() {
            Type::Base { symbol, args } => {
                if self.is_uv(symbol) { return Ok(false); }
                (symbol, args)
            },
            _ => {
                return Err(self.create_error(
                    ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                    info.span,
                    &[info.span],
                ))
            }
        };

        let callee_symbol = self.symbol_table.get_type_symbol(callee_symbol_id).unwrap();

        if let TypeSymbolKind::FunctionSignature {
            params: expected_params_with_receiver,
            return_type: expected_return,
            instance: Some(_),
        } = callee_symbol.kind.clone()
        {
            if expected_params_with_receiver.is_empty() {
                panic!("This shouldn't happen. [1]");
            }

            let (expected_receiver_ty, expected_params) = expected_params_with_receiver.split_first().unwrap();

            if params.len() != expected_params.len() {
                return Err(self.create_error(
                    ErrorKind::ArityMismatch(expected_params.len(), params.len()),
                    info.span,
                    &[info.span],
                ));
            }

            let substitutions = self.create_generic_substitution_map(&callee_symbol.generic_parameters, &callee_args);
            let concrete_expected_params: Vec<Type> = expected_params.iter().map(|p| Self::apply_substitution(p, &substitutions)).collect();
            let concrete_receiver = Self::apply_substitution(expected_receiver_ty, &substitutions);
            let concrete_return = Self::apply_substitution(&expected_return, &substitutions);

            for (arg, expected) in params.iter().zip(concrete_expected_params.iter()) {
                self.unify(arg.clone(), expected.clone(), info)?;
            }

            self.unify_receiver(instance_ty, concrete_receiver, info)?;
            self.unify(return_ty, concrete_return, info)?;

            Ok(true)
        } else {
            Err(self.create_error(
                ErrorKind::NotCallable(self.symbol_table.display_type(&callee_ty)),
                info.span,
                &[info.span],
            ))
        }
    }

    fn unify_receiver(&mut self, passed: Type, expected: Type, info: ConstraintInfo) -> Result<Type, BoxedError> {
        let passed = self.resolve_type(&passed);
        let expected = self.resolve_type(&expected);

        if let Ok(unified) = self.unify(passed.clone(), expected.clone(), info) {
            return Ok(unified);
        }

        match (passed.clone(), expected.clone()) {
            (p @ Type::Base { .. }, e @ Type::Reference(_)) => {
                self.unify(Type::Reference(Box::new(p)), e, info)
            },
            (p @ Type::Base { .. }, e @ Type::MutableReference(_)) => {
                self.unify(Type::MutableReference(Box::new(p)), e, info)
            },
            (Type::Reference(p_inner), e @ Type::Base { .. }) => self.unify(*p_inner, e, info),
            (Type::MutableReference(p_inner), e @ Type::Base { .. }) => self.unify(*p_inner, e, info),
            (Type::MutableReference(p_inner), e @ Type::Reference(_)) => {
                self.unify(Type::Reference(p_inner), e, info)
            },
            _ => Err(self.type_mismatch_error(
                &passed,
                &expected,
                info,
                Some("receiver type mismatch".to_string()),
            )),
        }
    }

    fn unify_static_member_access(
        &mut self,
        result_ty: Type,
        lhs_type: Type,
        rhs_name: String,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let lhs_type = self.resolve_type(&lhs_type);
        let lhs_type_id = lhs_type.get_base_symbol();

        if self.is_uv(lhs_type_id) {
            return Ok(false);
        }

        let lhs_symbol = self.symbol_table.get_type_symbol(lhs_type_id).unwrap().clone();

        let (inherent_impls, enum_scope_id) = match &lhs_symbol.kind {
            TypeSymbolKind::Struct((_, impls)) => (impls.clone(), None),
            TypeSymbolKind::Enum((scope_id, impls)) => (impls.clone(), Some(*scope_id)),
            _ => {
                return Err(self.create_error(
                    ErrorKind::InvalidFieldAccess(self.symbol_table.display_type(&lhs_type)),
                    info.span,
                    &[info.span],
                ));
            }
        };

        for imp in &inherent_impls {
            if let Some(value_symbol) = self.symbol_table.find_value_symbol_in_scope(&rhs_name, imp.scope_id) {
                let symbol_type = self.resolve_type(value_symbol.type_id.as_ref().unwrap());
                match &value_symbol.kind {
                    ValueSymbolKind::Function(_) | ValueSymbolKind::Variable => {
                        self.unify(result_ty, symbol_type, info)?;
                        return Ok(true);
                    }
                    _ => {}
                }
            }
        }

        for imp in &inherent_impls {
            if let Some(assoc_type_symbol) = self.symbol_table.find_type_symbol_in_scope(&rhs_name, imp.scope_id)
            {
                let aliased_type = self.resolve_type(&Type::new_base(assoc_type_symbol.id));
                self.unify(result_ty, aliased_type, info)?;
                return Ok(true);
            }
        }

        if let Some(scope_id) = enum_scope_id {
            if self.symbol_table.find_value_symbol_in_scope(&rhs_name, scope_id).is_some() {
                self.unify(result_ty, lhs_type, info)?;
                return Ok(true);
            }
        }

        Err(self.create_error(
            ErrorKind::FieldNotFound(rhs_name, self.symbol_table.display_type(&lhs_type)),
            info.span,
            &[info.span],
        ))
    }

    fn unify_instance_member_access(
        &mut self,
        result_ty: Type,
        lhs_type: Type,
        rhs_name: String,
        info: ConstraintInfo,
    ) -> Result<bool, BoxedError> {
        let lhs_type = self.resolve_type(&lhs_type);

        let base_lhs_type = match &lhs_type {
            Type::Reference(inner) | Type::MutableReference(inner) => (**inner).clone(),
            _ => lhs_type.clone(),
        };

        let (base_symbol_id, concrete_args) = match &base_lhs_type {
            Type::Base { symbol, args } => (*symbol, args.clone()),
            _ => {
                return Err(self.create_error(
                    ErrorKind::InvalidFieldAccess(self.symbol_table.display_type(&lhs_type)),
                    info.span,
                    &[info.span],
                ));
            }
        };

        if self.is_uv(base_symbol_id) {
            return Ok(false);
        }

        let lhs_symbol = self.symbol_table.get_type_symbol(base_symbol_id).unwrap().clone();

        let (struct_scope_id, inherent_impls) = match &lhs_symbol.kind {
            TypeSymbolKind::Struct((scope_id, impls)) => (Some(*scope_id), impls.clone()),
            TypeSymbolKind::Enum((_, impls)) => (None, impls.clone()),
            _ => {
                return Err(self.create_error(
                    ErrorKind::InvalidFieldAccess(self.symbol_table.display_type(&lhs_type)),
                    info.span,
                    &[info.span],
                ));
            }
        };

        if let Some(scope_id) = struct_scope_id {
            if let Some(field_symbol) = self.symbol_table.find_value_symbol_from_scope(scope_id, &rhs_name)
            {
                let substitutions =
                    self.create_generic_substitution_map(&lhs_symbol.generic_parameters, &concrete_args);
                let concrete_field_type =
                    Self::apply_substitution(field_symbol.type_id.as_ref().unwrap(), &substitutions);
                self.unify(result_ty, concrete_field_type, info)?;
                return Ok(true);
            }
        }

        for imp in &inherent_impls {
            // TODO: Match against specific specializations.

            if let Some(value_symbol) = self.symbol_table.find_value_symbol_in_scope(&rhs_name, imp.scope_id)
            {
                if let ValueSymbolKind::Function(_) = value_symbol.kind {
                    let symbol_type = self.resolve_type(value_symbol.type_id.as_ref().unwrap());
                    let fn_sig_id = symbol_type.get_base_symbol();
                    let fn_sig_symbol = self.symbol_table.get_type_symbol(fn_sig_id).unwrap();

                    if let TypeSymbolKind::FunctionSignature {
                        instance: Some(_), ..
                    } = fn_sig_symbol.kind
                    {
                        let mut substitutions = self.create_generic_substitution_map(
                            &lhs_symbol.generic_parameters,
                            &concrete_args,
                        );
                        let impl_substitutions =
                            self.create_generic_substitution_map(&imp.generic_params, &concrete_args); // Assuming direct mapping for simplicity
                        substitutions.extend(impl_substitutions);

                        let concrete_fn_type = Self::apply_substitution(&symbol_type, &substitutions);
                        self.unify(result_ty, concrete_fn_type, info)?;
                        return Ok(true);
                    }
                }
            }
        }

        Err(self.create_error(
            ErrorKind::FieldNotFound(rhs_name, self.symbol_table.display_type(&lhs_type)),
            info.span,
            &[info.span],
        ))
    }
}

// utils/error.rs
use colored::Colorize;

use crate::boxed;

use super::kind::Span;

#[derive(Debug, Clone)]
pub enum ErrorKind {
    UnrecognizedSymbol(String),
    UnexpectedEOF,
    InvalidDigit(String),
    InvalidEscapeSequence(String),
    UnterminatedString,
    InvalidChar(String),
    UnterminatedChar,
    UnexpectedToken(String, String, String),
    UninitializedConstant,
    UnknownIdentifier(String),
    UnresolvedType(String),
    AlreadyDeclared(String),
    UnknownType,
    InvalidImpl(Option<String>),
    ExpectedType,
    InvalidConstraint(String),
    UnimplementedTrait(String, String),
    ConflictingTraitImpl(String, String),
    InvalidTraitImpl(String),
    ConflictingInherentImpl(String),
    InvalidDereference(String),
    ExpectedScopedItem,
    FieldNotFound(String, String),
    InvalidFieldAccess(String),
    IncorrectFieldAccessRhs,
    BadVariableDeclaration,
    SelfOutsideImpl,
    InvalidThis(&'static str),
    ExpectedIdentifier,
    TypeMismatch(String, String, Option<String>),
    NotCallable(String),
    ArityMismatch(usize, usize),
    InvalidReturn
}

impl ErrorKind {
    fn as_str(&self) -> String {
        match self {
            ErrorKind::UnrecognizedSymbol(symbol) => format!("unrecognized symbol {symbol}"),
            ErrorKind::UnexpectedEOF => "unexpected <eof> while parsing".to_string(),
            ErrorKind::InvalidDigit(digit) => format!("invalid digit {digit}"),
            ErrorKind::InvalidEscapeSequence(sequence) => {
                format!("invalid escape sequence {sequence}")
            }
            ErrorKind::UnterminatedString => "string left unterminated".to_string(),
            ErrorKind::InvalidChar(char) => format!("invalid char {char}"),
            ErrorKind::UnterminatedChar => "unterminated or degenerate char".to_string(),
            ErrorKind::UnexpectedToken(symbol, found, expected) => format!(
                "unexpected token: found \"{symbol}\" of type {found}, expected {expected}"
            ),
            ErrorKind::UninitializedConstant => "constant declared but no value assigned".to_string(),
            ErrorKind::UnknownIdentifier(name) => format!("could not find \"{name}\" in scope"),
            ErrorKind::UnresolvedType(name) => format!(
                "type for symbol \"{name}\" has not been determined by this line"
            ),
            ErrorKind::AlreadyDeclared(variable) => format!(
                "attempted to declare {variable}, but it already exists in scope"
            ),
            ErrorKind::UnknownType => "could not determine type of data by this line".to_string(),
            ErrorKind::InvalidImpl(type_ref) => format!(
                "cannot construct impl block for {}",
                type_ref.as_ref().map_or("an unnamed identifier", |v| v)
            ),
            ErrorKind::ExpectedType => "expected identifier to resolve to a type".to_string(),
            ErrorKind::InvalidConstraint(constraint) => format!(
                "expected constraint to be a trait, instead found \"{constraint}\""
            ),
            ErrorKind::UnimplementedTrait(tr, ty) => {
                format!("trait {tr} not implemented for type {ty}")
            }
            ErrorKind::ConflictingTraitImpl(tr, ty) => {
                format!("conflicting trait implementations for {tr} on type {ty}")
            }
            ErrorKind::InvalidTraitImpl(ty) => {
                format!("not all types in trait implemented, missing: {ty}")
            }
            ErrorKind::ConflictingInherentImpl(ty) => {
                format!("conflicting implementations for type {ty}")
            }
            ErrorKind::InvalidDereference(ty) => {
                format!("attempted to dereference non-pointer type {ty}")
            }
            ErrorKind::ExpectedScopedItem => "expected an item with a scope".to_string(),
            ErrorKind::FieldNotFound(field, type_name) => {
                format!("field \"{field}\" not found in type {type_name}")
            }
            ErrorKind::InvalidFieldAccess(type_name) => {
                format!("type {type_name} does not comprise fields")
            }
            ErrorKind::IncorrectFieldAccessRhs => "cannot access this field".to_string(),
            ErrorKind::BadVariableDeclaration => {
                "variable declaration must be annotated with a type or value".to_string()
            }
            ErrorKind::SelfOutsideImpl => "use of Self outside of an impl block".to_string(),
            ErrorKind::InvalidThis(place) => format!("found \"this\" {place}"),
            ErrorKind::ExpectedIdentifier => {
                "expected an identifier for the rhs of a field access operation".to_string()
            }
            ErrorKind::TypeMismatch(t1, t2, str) => {
                format!("types {t1} and {t2} are incompatible{}", match str {
                    Some(s) => format!(" [{s}]"),
                    None => "".to_string()
                })
            },
            ErrorKind::NotCallable(ty) => format!("{ty} is not callable"),
            ErrorKind::ArityMismatch(expected, given) => format!("expected {expected} arguments, got {given} arguments"),
            ErrorKind::InvalidReturn => "return statement found outside of function".to_string()
        }
    }
}

#[derive(Debug, Clone)]
pub struct Error {
    kind: ErrorKind,
    span: Span,
    source_lines: Vec<(String, usize)>,
}

pub type BoxedError = Box<Error>;

impl Error {
    pub fn new(kind: ErrorKind) -> BoxedError {
        boxed!(Error {
            kind,
            span: Span::default(),
            source_lines: vec![]
        })
    }

    pub fn from_one_error(kind: ErrorKind, span: Span, source_line: (String, usize)) -> BoxedError {
        boxed!(Error {
            kind,
            span,
            source_lines: vec![source_line]
        })
    }

    pub fn from_multiple_errors(
        kind: ErrorKind,
        span: Span,
        source_lines: Vec<(String, usize)>,
    ) -> BoxedError {
        boxed!(Error {
            kind,
            span,
            source_lines
        })
    }
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "[{}] {}", "error".red().bold(), self.kind.as_str())?;
        writeln!(
            f,
            "as found in [insert_file_here]:{}:{}",
            self.span.start_pos.line, self.span.start_pos.column
        )?;

        let mut used_numbers = vec![];
        for (content, number) in self.source_lines.iter() {
            if used_numbers.contains(number) {
                continue;
            } else {
                used_numbers.push(*number);
            }

            writeln!(f, "    {}", content)?;

            if *number == self.span.start_pos.line {
                writeln!(
                    f,
                    "    {}^{}^",
                    " ".repeat(self.span.start_pos.column - 1),
                    "^".repeat(
                        self.span
                            .end_pos
                            .column
                            .saturating_sub(self.span.start_pos.column)
                    )
                )?;
            }
        }

        Ok(())
    }
}

impl std::error::Error for Error {}


