import { print, println, panic, unreachable, read_line } from "stdlib/io.ps";
import { random } from "stdlib/math.ps";
import { INT_MIN } from "stdlib/consts.ps";
import { Vec } from "stdlib/vec.ps";

enum Cell { X = -1, O = 1, Empty = 0 }

impl Equivalence<Cell> for Cell {
    type Output = bool;
    fn equivalence(self, other: Self): bool {
        (self as int == Cell.X as int && other as int == Cell.X as int)
            || (self as int == Cell.O as int && other as int == Cell.O as int)
            || (self as int == Cell.Empty as int && other as int == Cell.Empty as int)
    }
}

impl NotEqual<Cell> for Cell {
    type Output = bool;
    fn not_equal(self, other: Self): bool {
        ![Self as Equivalence<Cell>].equivalence(self, other)
    }
}

impl Cell {
    fn to_symbol(self): str {
        if (self == Cell.X) { "X" }
        else if (self == Cell.O) { "O" }
        else { "." }
    }
}

enum Player { X = -1, O = 1 }

impl Equivalence<Player> for Player {
    type Output = bool;
    fn equivalence(self, other: Self): bool {
        (self as int == Player.X as int && other as int == Player.X as int)
            || (self as int == Player.O as int && other as int == Player.O as int)
    }
}

impl NotEqual<Player> for Player {
    type Output = bool;
    fn not_equal(self, other: Self): bool {
        ![Self as Equivalence<Player>].equivalence(self, other)
    }
}

impl Player {
    fn to_cell(self): Cell {
        if (self == Player.X) { Cell.X }
        else if (self == Player.O) { Cell.O }
        else { unreachable("") }
    }

    fn opponent(self): Self {
        if (self == Player.X) { Player.O }
        else if (self == Player.O) { Player.X }
        else { unreachable("") }
    }

    fn from_int(i: int): Self {
        if (i == -1) { Player.X }
        else if (i == 1) { Player.O }
        else { panic("tried to convert integer to player, but integer must be 1 or -1") }
    }
}

struct Board {
    cells: Vec<Cell>;
}

struct Vector3D {
    x1: int;
    x2: int;
    x3: int;
}

impl Board {
    fn new(): Self {
        let cells = [Vec<Cell>].from_capacity(9);
        for (let i = 0; i < 9; i += 1) {
            cells.push(Cell.Empty);
        }

        Self { cells }
    }

    fn print_board(self) {
        for (let r = 0; r < 3; r += 1) {
            for (let c = 0; c < 3; c += 1) {
                print(self.cells.get(r * 3 + c).to_symbol());
                print(" ");
            }

            println("");
        }

        println("");
    }

    fn is_full(self): bool {
        for (let r = 0; r < 3; r += 1) {
            for (let c = 0; c < 3; c += 1) {
                if (self.cells.get(r * 3 + c) == Cell.Empty) {
                    return false;
                };
            }
        }

        true
    }

    fn winner(self): int {
        let lines = [Vec<Vector3D>].from_capacity(8);
        lines.push(Vector3D { x1: 0, x2: 1, x3: 2 });
        lines.push(Vector3D { x1: 3, x2: 4, x3: 5 });
        lines.push(Vector3D { x1: 6, x2: 7, x3: 8 });
        lines.push(Vector3D { x1: 0, x2: 3, x3: 6 });
        lines.push(Vector3D { x1: 1, x2: 4, x3: 7 });
        lines.push(Vector3D { x1: 2, x2: 5, x3: 8 });
        lines.push(Vector3D { x1: 0, x2: 4, x3: 8 });
        lines.push(Vector3D { x1: 2, x2: 4, x3: 6 });

        for (let i = 0; i < lines.length(); i += 1) {
            let vector = lines.get(i);
            let a = self.cells.get(vector.x1); let b = self.cells.get(vector.x2); let c = self.cells.get(vector.x3);

            if ((a != Cell.Empty) && (a == b) && (b == c)) {
                return a as int;
            };
        }

        0
    }

    fn make_move(self, idx: int, player: Player) {
        self.cells.replace(idx, player.to_cell());
    }

    fn undo(self, idx: int) {
        self.cells.replace(idx, Cell.Empty);
    }

    fn available_moves(self): Vec<int> {
        let vec = [Vec<int>].from_capacity(9);
        
        for (let i = 0; i < 9; i += 1) {
            if (self.cells.get(i) == Cell.Empty) {
                vec.push(i);
            };
        }

        vec
    }
}

fn negamax(board: Board, player: Player): int {
    let potential_winner = board.winner();
    if (potential_winner != 0) {
        return if (potential_winner == player as int) { 1 } else { -1 };
    };

    if (board.is_full()) { return 0; };

    let best = INT_MIN + 1;
    let moves = board.available_moves();

    for (let i = 0; i < moves.length(); i += 1) {
        let move = moves.get(i);
        
        board.make_move(move, player);
        let score = -negamax(board, player.opponent());
        board.undo(move);

        if (score > best) {
            best = score;
            if (best == 1) {
                return best;
            }
        }
    }

    best
}

fn best_move(board: Board, player: Player): int {
    let best_score = INT_MIN + 1;
    let best_move = -1;

    let moves = board.available_moves();

    for (let i = 0; i < moves.length(); i += 1) {
        let move = moves.get(i);
        
        board.make_move(move, player);
        let score = -negamax(board, player.opponent());
        board.undo(move);

        if (score > best_score) {
            best_score = score;
            best_move = move;
        }
    }

    best_move
}

let board = Board.new();
let human = if (random() > 0.5) { Player.X } else { Player.O };
let engine = human.opponent();
let current = human;

print("You are ");
print(human.to_cell().to_symbol());
print("! The engine is ");
print(engine.to_cell().to_symbol());
println(".");

println("Board positions are:");
println("0 1 2\n3 4 5\n6 7 8\n");
board.print_board();

while (true) {
    let potential_winner = board.winner();
    if (potential_winner != 0) {
        print("Game over! Player ");
        print(Player.from_int(potential_winner).to_cell().to_symbol());
        print(" has won.");
        println("");
        break;
    };

    if (board.is_full()) {
        println("Game over! Draw.");
        break;
    };

    if (current == human) {
        while (true) {
            print("Enter your move (0-8): ");
            
            let input = read_line().trim();
            let move = if (input == "0") { 0 }
                else if (input == "1") { 1 }
                else if (input == "2") { 2 }
                else if (input == "3") { 3 }
                else if (input == "4") { 4 }
                else if (input == "5") { 5 }
                else if (input == "6") { 6 }
                else if (input == "7") { 7 }
                else if (input == "8") { 8 }
                else { 9 };
            
            let c = board.cells.get(8);

            if (move < 9 && (board.cells.get(move) == Cell.Empty)) {
                board.make_move(move, human);
                break;
            };

            println("Invalid move. Try again.");
        }
    } else {
        let move = best_move(board, engine);
        print("Engine plays move ");
        print(move);
        println("!");

        board.make_move(move, engine);
    };

    board.print_board();
    current = current.opponent();
}