## VARIABLE DECLARATION ##
    let a = "Hello, world!"; # implicit types should be fine
    let b: int = 5;
    const c: float = 3.0;
    let d; # maybe dont allow for no expr, or store null and dont allow access until declared

## FUNCTION DECLARATION ##
    fn name() {}
    fn name(x: int) {}
    fn name(x: int, y: int): int {}
    fn name(x: int = 3, y: int): float {}

## BLOCKS ##
    {
        let x: int = 5;
    } 
    # maybe let blocks resolve to an expr?

## LOOPS ##
    # While Loop
    while (0) {}

    # For Loop
    for (int i = 0; i < 5; ++i) { .. }

    int j = 0;
    for (;j < 5; ++j) { .. }

    for (;;) { .. }

## CONTROL FLOW ##
    while (true) {
        break;
    }

    for (let i = 0; i < 5; ++i) {
        continue;
    }

    fn add(a: int, b: int = 0): int {
        return a + b;
    }

    fn panic(message: string) {
        throw message;
    }

## STRUCTS ##
    struct User {
        public x: int;
        private y: int;
    }

    let x = User {
        x: 3,
        y: 4
    };

## IMPLEMENTATIONS ##
    impl User {
        public const TYPE = "user";
        
        public fn new(x: int, y: int = 0) {
            return User { x, y };
        }

        public fn check_permissions(this) {}
    }

## FIELD/METHOD ACCESS##
    let type = User.TYPE;
    let user = User.new(3, 4);
    user.check_permissions();
    user.x = 3;

    fn add() {}
    add();

## ENUMS ##
    enum Level {
        Easy,
        Medium,
        Hard = 7
    }

    let level = Level.Hard;

## TRAITS ##
    enum Species {
        Dog,
        Cat,
        UE2020
    }

    trait TAnimal {
        fn get_species(this): Species;
        fn speak(this);
        fn interact(this, other: Self): Self;
    }

    struct Animal {
        private species: Species;
    }

    impl TAnimal for Animal {
        fn get_species(this): Species {
            return this.species;
        }

        fn speak(this) {}

        fn interact(this, other: Animal): Animal {
            return this;
        }
    }

    impl Animal {
        public fn new(species: Species): Animal {
            return Animal { species };
        }
    }

## GENERICS ##
    trait TAddable {
        fn add(this, other: Self): Self;
    }

    trait TSubbable {
        fn sub(this, other: Self): Self;
    }

    impl TAddable for int {
        fn add(this, other: Self): Self {
            return this + other;
        }
    }

    impl TSubbable for int {
        fn sub(this, other: Self): Self {
            return this - other;
        }
    }

    fn identity[T](x: T): T {
        return x;
    }

    fn generic_pair[A: TAddable + TSubbable, B: TAddable + TSubbable](a: A, b: B) {}

    let identity_value = identity(5);
    generic_pair(5, "3");

    struct Vector2D[T: TAddable] {
        public x: T;
        public y: T;
    }

    impl[T: TAddable, U] Vector2D[T] {
        public fn add(this, vector: Vector2D[T]): Vector2D[T] {
            return Vector2D {
                x: this.x.add(other.x),
                y: this.y.add(other.y)
            };
        }

        public fn random_method[U](x: U) {}
    }

    impl Vector2D[string] {
        public fn merge(this): string {
            return this.x + this.y;
        }
    }

    let vector1: Vector2D[int] = Vector2D { x: 3, y: 3 };
    let resultant = vector1.add(Vector2D { x: 4, y: 4 });
    vector1.random_method("hi");

    let vector2 = Vector2D { x: "Hello", y: "world" };
    let merged = vector2.merge();
    
    # let vector3 = Vector2D { x: 1, y: "3" } <-- compile error

## SCOPED TYPES ##
    type Integer = int;
    let x: Integer = 2;

    struct Box[T] {
        public value: T;
    }

    type StringBox = Box[string];
    let box: StringBox = Box { value: "hi" };

## REFERENCES ##
    let integer = 3;
    
    {
        let immutable_ref = &integer;
    }
    # reference dropped here, prevents UB

    let mutable_ref = &mut integer;
    while (*mutable_ref != 0) {
        *mutable_ref--;
    }

    struct Box {
        public value: int;
    }

    impl Box {
        public fn increment(&mut this) {
            this.value++;
        }
    }

    let box = Box { value: 5 };
    box.increment();
    let value = box.value; # 6

## FUNCTION SIGNATURE AS TYPE ##
    type Callback = fn();