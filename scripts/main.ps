struct Vector2D {
    public x: int;
    public y: int;
}

impl Vector2D {
    public const ZERO: Vector2D = Vector2D { x: 0, y: 0 };

    public fn new(x: int, y: int): Vector2D {
        return Vector2D { x, y };
    }

    public fn do_nothing(this) {}
}

let vector = Vector.new(3, 4).do_nothing();
vector.x;

## TEST 0: EXPRESSIONS
# !(-a++ + ~b-- * (c ** d % e / f) - g) &= ((h += i) *= (j -= k) ^= (l /= m %= n)) >> o << p | q & r ^ s && t || u > v >= w < x <= y == z = aa;

## TEST 1: VAR DECL
# let x: int = 5 + 3 * 2 - 4 + 7 % 2;

## TEST 2: FUNCTIONS
# fn z() {}
#
# fn add(x: int = 0, y: int = 0): int {
#     let x: int = 5;
#     let y: int = 7;
# }

## TEST 3: BLOCKS
# {
#     let x: int = 5;
# }

## TEST 4: IF CHAINS
# if (1 + 1 == 2) {
#     let x = 5;
# } else if (1 + 1 == 3) {
#     let x = 4;
# } else {
#     let x = 3;
# }

## TEST 5: LOOPS
# while (false || x == 10) {
#     let x = 4;
# }
#
# for (let i = 0; i < 10; ++i) {}
#
# let j = 0;
# for (;j < 10; ++j) {}
#
# for (;;) {}

## TEST 6: CONTROL FLOW
# while (true) {
#     break;
# }
# 
# for (let i = 0; i < 5; ++i) {
#     continue;
# }
# 
# fn add(a: int, b: int = 0): int {
#     return a + b;
# }
# 
# fn panic(message: string) {
#     throw message;
# }

## TEST 7: STRUCTS
# struct X {
#     public x: int;
#     private y: int;
# }

# let x_struct = X {
#     x: 4,
#     y: 3 + 2 % 4 - 1
# };

# let x = 4;
# let y = 5;

# let y_struct = X {
#     x,
#     y
# };

## TEST 8: IMPLEMENTATIONS
# struct Vector2D {
#     public x: int;
#     public y: int;
# }

# impl Vector2D {
#     public const ZERO: Vector2D = Vector2D { x: 0, y: 0 };
# 
#     public fn new(x: int, y: int): Vector2D {
#         return Vector2D { x, y };
#     }
# 
#     public fn do_nothing(this) {}
# }