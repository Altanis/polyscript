// generics need to be constrained to traits properly
// memory safety (reference counting)

/*trait Entity {
    type TickOutput;
    fn tick(&mut self): Self.TickOutput;
}

struct Tank {}
struct Square {}

impl Entity for Tank {
    type TickOutput = int;
    fn tick(&mut self): int { 4 }
}

impl Entity for Square {
    type TickOutput = char;
    fn tick(&mut self): char { '4' }
}

fn tick<T: Entity>(x: T): [T as Entity].TickOutput {
    x.tick()
}*/

struct Iterable {}

trait Iterator {
    type Item;

    fn next(&self): Self.Item;
}

impl Iterator for Iterable {
    type Item = char;

    fn next(&self): Self.Item {
        return '3';
    }
}

fn next<I: Iterator>(x: &I): [I as Iterator].Item {
    return x.next();
}

let iterator = Iterable {};
let x: char = next(&iterator);