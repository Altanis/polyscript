struct S<T> {x:T;}
fn identity<X>(x: S<X>): S<X> { x }
let ident: S<int> = identity(S { x: 1 });

struct Type<A> {
    x: A;
}

impl<U> Type<U> {
    fn test(&this, other: &Self) {}
}

let s1 = Type { x: 3 };
let s2 = Type { x: 4 };
let s3 = Type { x: '5' };

s1.test(&s2);

struct Vector3D<T, U> {
    x: T;
    y: U;
    z: float;
}

impl<T, U> Vector3D<T, U> {
    fn operation(&this, other: &Self): int {
        return 0;
    }
}

impl Vector3D<int, float> {
    fn default(): Self {
        return Vector3D { x: 0, y: 0.0, z: 0.0 };
    }
}

impl Vector3D<float, float> {
    fn test(&this) {

    }
}

let v4: Vector3D<int, float> = [Vector3D<int, float>].default();
let v5: Vector3D<int, float> = [Vector3D<int, float>].default();

let resultant: int = v4.operation(&v5);

let v6 = Vector3D { x: 0.0, y: 0.0, z: 1.0 };
v6.test();

struct Point<T> {
    x: T;
}

impl Point<int> {
    const precise: bool = false;
    type Implementor = int;

    fn default(): Self {
        Point { x: 1 }
    }
}

impl Point<float> {
    const precise: bool = true;
    type Implementor = float;

    fn default(): Self {
        Point { x: 1.0 }
    }
}

let val = [Point<int>].precise;
let val2: [Point<float>].Implementor = 3.0;

let p1: Point<int> = [Point<int>].default();
let p2: Point<float> = [Point<float>].default();

let x: float = 5.0;
let y: &float = &x;

struct Vector2D {
    x: float;
    y: float;
}

impl Vector2D {
    fn default(): Self {
        return Vector2D {
            x: 0.0,
            y: 0.0
        };
    }

    fn take_this(this) {}
    fn take_ref_this(&this) {}
    fn take_mut_ref_this(&mut this) {}
}

let v1 = Vector2D.default();
v1.take_this();
v1.take_ref_this();
v1.take_mut_ref_this();

enum Difficulty {
    Easy,
    Medium,
    Hard
}

impl Difficulty {
    const LEVELS: int = 3;
    type ReturnTy = int;

    fn default_difficulty(): Self {
        return Difficulty.Easy;
    }

    fn get_levels(&this): Self.ReturnTy {
        return Self.LEVELS;
    }
}


let difficulty = Difficulty.default_difficulty();
let levels = Difficulty.LEVELS;
let levels_alias = difficulty.get_levels();

trait Animal {
    type SpeechEmission;

    fn speak(&this): Self.SpeechEmission;
}

struct Dog {}
struct Cat {}

impl Animal for Dog {
    type SpeechEmission = char;
    fn speak(&this): Self.SpeechEmission {
        return 'b';
    }
}

impl Animal for Cat {
    type SpeechEmission = string;
    fn speak(&this): Self.SpeechEmission {
        return "meow";
    }
}

impl Dog {
    type SpeechEmission = float;
}

let dog = Dog {};
let cat = Cat {};

let emission1: [Dog as Animal].SpeechEmission = dog.speak();