// multiple references
// refine escape analysis + emit errors
// can assign things void value (i.e. let x = (fn() {})() compiles when it shouldnt)
// builder doesn't handle iife ( (fn() {})() )
// [Scalar<int>].new("%") works for some reason
// compiler thinks let num = (Scalar { x: 4 }).get_num(); is static access
// separate strings from primitives
// memory safety (reference counting)
// real compiler that takes file input + import/export system
// stdlib
// arrays + vectors + Indexable trait

fn modifies_ref(r: &mut int) {
    *r = 1;
}

fn test15() {
    let q15 = 700;
    modifies_ref(&mut q15);
}

fn test16(cond: bool): &int {
    let a16: int = 800;
    let b16: int = 801;
    if (cond) {
        return &a16;
    } else {
        return &b16;
    }
}