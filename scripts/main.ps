// generics need to be constrained to traits properly
// memory safety (reference counting)

/*fn identity<T>(x: T): T {
    return x;
}

let y = identity(3);
let z = identity("3");*/

// bug: ptr is passed to identity instead of actual int

trait Entity {
    type TickOutput;
    fn tick(&mut self): Self.TickOutput;
}

struct Tank {}
struct Square {}

impl Entity for Tank {
    type TickOutput = int;
    fn tick(&mut self): int { 4 }
}

impl Entity for Square {
    type TickOutput = char;
    fn tick(&mut self): char { '4' }
}

fn tick<T: Entity>(x: T): [T as Entity].TickOutput {
    x.tick()
}

let tank = Tank {};
let square = Square {};

let fruit1: int = tick(tank);
let fruit2: char = tick(square);

/*trait Entity {
    type TickOutput;
    fn tick(&mut self): Self.TickOutput;
}

struct Tank {}
struct Square {}

impl Entity for Tank {
    type TickOutput = int;
    fn tick(&mut self): int { 4 }
}

impl Entity for Square {
    type TickOutput = char;
    fn tick(&mut self): char { '4' }
}

fn tick<T: Entity>(x: T) {
    x.tick();
    3; // fix how returns work
}

let tank = Tank {};
let square = Square {};

tick(tank);
tick(square);*/