// generics need to be constrained to traits properly
// memory safety (reference counting)

struct Point<T> {
    x: T;
}

impl Point<int> {
    const precise: bool = false;
    type Implementor = int;

    fn default(): Self {
        Point { x: 1 }
    }
}

impl Point<float> {
    const precise: bool = true;
    type Implementor = float;

    fn default(): Self {
        Point { x: 1.0 }
    }
}

let p1: Point<int> = [Point<int>].default();