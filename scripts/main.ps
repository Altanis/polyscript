// ToString for floats

// string methods: insert(idx, char), remove(idx) -> char, clear(), is_empty() -> bool
// contains(substring: String) -> bool, starts/ends_with(prefix: String) -> bool, index_of(char)
// slice(start, end) -> String, split(delimiter) -> Vec<String>
// to_uppercase() -> String, to_lowercase() -> String, trim() -> String
// join(Vec<String>, separator: String) -> String, repeat(int) -> String
// +, +=, ==, !=, <, <=, >=, >, 

// assignment in enum value position
// nan and infinite for floats
// handle integer overflow
// math stdlib
// hashmap stdlib
// file i/o?
// proof of concept

// escape analysis for immediates
// private field and public fn of same name throws err
// default traits such as Drop, Clone, Default, ToString
// maybe add prelude system

/*import { ref, deref, print_char, eprint } from "@intrinsics";

struct Data<T> {
    private data: int;
}

impl<T> Data<T> {
    public fn from_char(c: T): Self {
        Self { data: ref(c) }
    }

    public fn get(self): T {
        eprint("Pre");
        deref(self.data as T)
    }
}

let s = [Data<char>].from_char('H');
print_char(s.get());*/

import { ref, deref, print_char, eprint, calloc, memcpy } from "@intrinsics";

struct Data<T> {
    private ptr: int;
}

impl<T> Data<T> {
    public fn new(c: T): Self {
        let size = sizeof T;
        let ptr = calloc(1, size);
        memcpy(ptr, ref(c), size);

        Self { ptr }
    }

    public fn get(self): T {
        deref(self.ptr as T)
    }
}

let s = [Data<char>].new('w');
print_char(s.get());
print_char('\n');