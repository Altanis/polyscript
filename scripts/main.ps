// ToString for floats

// string methods: insert(idx, char), remove(idx) -> char, clear(), is_empty() -> bool
// contains(substring: String) -> bool, starts/ends_with(prefix: String) -> bool, index_of(char)
// slice(start, end) -> String, split(delimiter) -> Vec<String>
// to_uppercase() -> String, to_lowercase() -> String, trim() -> String
// join(Vec<String>, separator: String) -> String, repeat(int) -> String
// +, +=, ==, !=, <, <=, >=, >, 

// assignment in enum value position
// nan and infinite for floats
// handle integer overflow
// math stdlib
// hashmap stdlib
// file i/o?
// proof of concept

// escape analysis for immediates
// private field and public fn of same name throws err
// default traits such as Drop, Clone, Default, ToString
// maybe add prelude system

import { print_char, eprint_char } from "@intrinsics";
import { strlen, strget } from "@intrinsics";
import { calloc, realloc, memcpy, memmove, free, decref, print_char, eprint, print_int, endproc, endproc, drop, strlen, strget, ref, deref } from "@intrinsics";

// Constant pointing to 0x0 for NULL.
const nullptr: int = 0x0;

// A struct representing a vector, a contiguous, resizable array that holds elements of the same type.
struct Vec<T> {
    // The current size of the vector.
    private size: int;
    // How many elements the vector has reserved for storage.
    private capacity: int;
    // The size of 1 element.
    private element_size: int;
    // A pointer to the actual data in the vector.
    private data: int;
}

impl<T> Vec<T> {
    // Constructs a new vector. This function does not reserve any memory for the vector.
    public fn new(): Self {
        Self {
            size: 0,
            capacity: 0,
            element_size: sizeof T,
            data: nullptr
        }
    }

    // Constructs a new vector with space for `n` elements.
    public fn from_capacity(n: int): Self {
        Self {
            size: 0,
            capacity: n,
            element_size: sizeof T,
            data: if (n == 0) { nullptr } else { calloc(n, sizeof T) }
        }
    }

    // Adjusts the capacity of the vector. 
    // * Returns `true` if successful, `false` otherwise.
    // * This function returns false if `new_capacity` is less than or equal to the current capacity.
    public fn reserve(self, new_capacity: int): bool {
        if (new_capacity <= self.capacity) { return false; };

        let bytes = self.element_size * new_capacity;
        let new_data = realloc(self.data, bytes);
        if (new_data == nullptr) { return false; };

        self.data = new_data;
        self.capacity = new_capacity;

        true
    }

    // Pushes an element to the end of a vector.
    public fn push(self, element: T) {
        if (self.size + 1 > self.capacity && !self.reserve(if (self.capacity == 0) { 1 } else { self.capacity * 2 })) {
            eprint("oom: couldn't reserve memory for vector\n");
            endproc(1);
        };

        let dst = self.data + self.size * self.element_size;
        memcpy(dst, ref(element), self.element_size);
        self.size += 1;
    }

    // Replaces the element at index `idx` with `element`.
    // * Returns true if successful, false otherwise.
    // * This function returns false if `idx` is out of the bounds of the allocated vector.
    // * The replaced element is dropped.
    public fn replace(self, idx: int, element: T): bool {
        if (idx < 0 || idx >= self.size) {
            return false;
        };

        let dst = self.data + idx * self.element_size;

        if #IS_REFCOUNTED#{T} {
            decref(dst);
        } else {
            drop(deref(dst as T));
        };

        memcpy(dst, ref(element), self.element_size);
        true
    }

    // Gets the element at index `idx`.
    // * Panics if `idx` is out of bounds.
    public fn get(self, idx: int): T {
        if (idx < 0 || idx >= self.size) {
            eprint("oob access in vector\n");
            endproc(1);
        };

        deref((self.data + idx * self.element_size) as T)
    }

    // Removes the element at index `idx`.
    // * Returns true if successful, false otherwise.
    // * This function returns false if `idx` is out of the bounds of the allocated vector.
    // * The removed element is dropped.
    public fn remove(self, idx: int): bool {
        if (idx < 0 || idx >= self.size) {
            return false;
        };

        let dst = self.data + idx * self.element_size;

        if #IS_REFCOUNTED#{T} {
            decref(dst);
        } else {
            drop(deref(dst as T));
        };

        let src = self.data + (idx + 1) * self.element_size;
        let size = self.element_size * (self.size - idx - 1);

        if (size > 0) { memmove(dst, src, size); };
        self.size -= 1;

        true
    }

    // Clears the vector.
    // * All elements in the vector are dropped.
    public fn clear(self) {
        while (self.size > 0) {
            let last = self.size - 1;
            let dst = self.data + last * self.element_size;

            if #IS_REFCOUNTED#{T} {
                decref(dst);
            } else {
                drop(deref(dst as T));
            };

            self.size = last;
        }
    }

    // Gets the length of the vector.
    public fn length(self): int {
        self.size
    }
}

impl<T> Drop for Vec<T> {
    fn drop(self) {
        if (self.capacity != 0) {
            self.clear();
            free(self.data);

            self.size = 0;
            self.capacity = 0;
            self.data = nullptr;
        }
    }
}

impl<T: Clone> Clone for Vec<T> {
    fn clone(self): Self {
        let vec: Vec<T> = [Vec<T>].new();
        vec.reserve(self.size);

        for (let i = 0; i < self.size; i += 1) {
            let element: T = self.get(i);
            vec.push([T as Clone].clone(element));
        }
        
        return vec;
    }
}

// A structure representing a mutable, extensible String.
struct String {
    // The internal representation of the string, in characters.
    private chars: Vec<char>;
}

impl String {
    // Constructs a new string. This function does not reserve any memory for the string.
    public fn new(): Self {
        Self { chars: [Vec<char>].new() }
    }

    // Constructs a new string with space for `n` elements.
    public fn from_capacity(n: int): Self {
        Self { chars: [Vec<char>].from_capacity(n) }
    }
    
    // Constructs a new string from a constant str `s`.
    public fn from_str(s: str): Self {
        let len = strlen(s);
        let chars = [Vec<char>].from_capacity(len);

        for (let i = 0; i < len; i += 1) {
            chars.push(strget(s, i));
        }

        Self { chars }
    }

    // Constructs a new string from a character `c`.
    public fn from_char(c: char): Self {
        let chars = [Vec<char>].from_capacity(1);
        chars.push(c);

        Self { chars }
    }

    // Gets the length of the string.
    public fn length(self): int {
        self.chars.length()
    }

    // Gets the `i`-th character in the string.
    public fn get(self, i: int): char {
        self.chars.get(i)
    }

    // Pushes a character `c` to the end of the string.
    public fn push(self, c: char) {
        self.chars.push(c);
    }

    // Pushes a string `s` to the end of the string.
    public fn push_string(self, s: String) {
        for (let i = 0; i < s.length(); i += 1) {
            self.chars.push(s.get(i));
        }
    }
}

impl Clone for String {
    fn clone(self): Self {
        String { chars: [Vec<char> as Clone].clone(self.chars) }
    }
}

impl Add<char> for String {
    type Output = String;
    fn add(self, other: char): String {
        let string = [String as Clone].clone(self);
        string.push(other);
        string
    }
}

impl Add<String> for String {
    type Output = String;
    fn add(self, other: String): String {
        let string = [String as Clone].clone(self);
        string.push_string(other);
        string
    }
}

impl AddAssign<char> for String {
    fn add_assign(self, other: char) {
        self.push(other);
    }
}

impl AddAssign<String> for String {
    fn add_assign(self, other: String) {
        self.push_string(other);
    }
}

trait ToString {
    fn to_string(self): String;
}

impl ToString for int {
    fn to_string(self): String {
        if (self == 0) { return String.from_str("0"); };

        let n = self;
        let negative = false;
        if (n < 0) {
            negative = true;
            n = 0 - n;
        };

        let digits = [Vec<char>].new();

        while (n > 0) {
            let d = (n % 10) as char;
            digits.push(('0' as int + d as int) as char);
            n /= 10;
        }

        if (negative) {
            digits.push('-');
        };

        let chars = [Vec<char>].from_capacity(digits.length());
        for (let i = digits.length() - 1; i >= 0; i -= 1) {
            chars.push(digits.get(i));
        }

        String { chars }
    }
}

impl ToString for float {
    fn to_string(self): String {
        let n = self;

        // TODO: nan, inf, -inf

        let negative = n < 0.0;
        if (negative) {
            n = 0.0 - n;
        };

        let int_part = n as int;
        let s = [int as ToString].to_string(int_part);

        let frac = n - int_part as float;
        if (frac > 0.0) {
            s.push('.');
            for (let i = 0; i < 17; i += 1) {
                frac *= 10.0;
                let digit = frac as int;
                s.push(('0' as int + digit) as char);
                frac -= digit as float;
            }
        } else {
            s.push('.');
            s.push('0');
        };

        if (negative) {
            let with_sign = String.from_str("-");
            with_sign.push_string(s);
            return with_sign;
        };

        s
    }
}

impl ToString for str {
    fn to_string(self): String {
        String.from_str(self)
    }
}

impl ToString for char {
    fn to_string(self): String {
        String.from_char(self)
    }
}

impl ToString for bool {
    fn to_string(self): String {
        if (self) {
            String.from_str("true")
        } else {
            String.from_str("false")
        }
    }
}

impl ToString for String {
    fn to_string(self): String {
        self
    }
}

fn print<T: ToString>(data: T) {
    let string = [T as ToString].to_string(data);
    for (let i = 0; i < string.length(); i += 1) {
        print_char(string.get(i));
    }
}

fn println<T: ToString>(data: T) {
    print(data);
    print_char('\n');
}

let r = String.from_str("Hello ");
let s = String.from_str("world.");
r += s;
println(r);