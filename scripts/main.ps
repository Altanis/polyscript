// <T: Add<T>> no work properly
// [Scalar<int>].new("%") works for some reason
// can assign things void value (i.e. let x = (fn() {})() compiles when it shouldnt)
// generics need to be constrained to traits properly
// memory safety (reference counting)


struct Scalar<T> {
    x: T;
}

trait Numeric<T> {
    fn get_number(&self): T;
}

impl<T> Scalar<T> {
    fn new(x: T): Self {
        Scalar { x }
    }

    fn get_num(&self): T {
        self.x
    }
}

impl<T> Numeric<T> for Scalar<T> {
    fn get_number(&self): T {
        self.x
    }
}

let scalar = [Scalar<int>].new(4);
let num = scalar.get_num();
let num2 = scalar.get_number();


fn identity1<T>(x: T): T { x }
fn identity2<T>(x: Scalar<T>): Scalar<T> { x }

let clone = identity1([Scalar<char>].new('5'));
let clone2 = identity2(Scalar { x: true });