struct S<T> {x:T;}
fn identity<X>(x: S<X>): S<X> { x }
let x : S<int> = identity(S{x:1});

struct Type<A> {
    x: A;
}

impl<U> Type<U> {
    fn test(&self, other: &Self) {}
}

let v1 = Type { x: 3 };
let v2 = Type { x: 4 };
let v3 = Type { x: '5' };

v1.test(&v2);
// error: incompatible types U = char and U = int
// v1.test(&v3);

struct Vector3D<T, U> {
    x: T;
    y: U;
    z: float;
}

impl<T, U> Vector3D<T, U> {
    fn operation(&self, other: &Self): int {
        return 0;
    }
}

impl Vector3D<int, float> {
    fn default(): Self {
        return Vector3D { x: 0, y: 0.0, z: 0.0 };
    }
}

impl Vector3D<float, float> {
    fn test(&self) {

    }
}

let v4: Vector3D<int, float> = [Vector3D<int, float>].default();
let v5: Vector3D<int, float> = [Vector3D<int, float>].default();

let resultant: int = v4.operation(&v5);

let v6 = Vector3D { x: 0.0, y: 0.0, z: 1.0 };
v6.test();