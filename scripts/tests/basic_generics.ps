struct Type[A] {
    x: A;
}

impl[U] Type[U] {
    fn test(&this, other: &Self) {}
}

let v1 = Type { x: 3 };
let v2 = Type { x: 4 };
let v3 = Type { x: '5' };

v1.test(&v2);
// error: incompatible types U = char and U = int
// v1.test(&v3);

struct Vector3D[T, U] {
    x: T;
    y: U;
    z: float;
}

impl[T, U] Vector3D[T, U] {
    fn operation(&this, other: &Self): int {
        return 0;
    }
}

impl Vector3D[int, float] {
    fn default(): Self {
        return Vector3D { x: 0, y: 0.0, z: 0.0 };
    }
}

impl Vector3D[float, float] {
    fn test(&this) {

    }
}

let v1: Vector3D[int, float] = Vector3D.default();
let v2: Vector3D[int, float] = Vector3D.default();

let resultant: int = v1.operation(&v2);

let v3 = Vector3D { x: 0.0, y: 0.0, z: 1.0 };
v3.test();