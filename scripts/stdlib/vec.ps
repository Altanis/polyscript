import { calloc, realloc, memcpy, memmove, free, incref, eprint, exit } from "@intrinsics";

// Constant pointing to 0x0 for NULL.
const nullptr: int = 0x0;

// A struct representing a vector, a contiguous, resizable array that holds elements of the same type.
struct Vec<T> {
    // The current size of the vector.
    private size: int;
    // How many elements the vector has reserved for storage.
    private capacity: int;
    // The size of 1 element.
    private element_size: int;
    // A pointer to the actual data in the vector.
    private data: int;
}

impl<T> Drop for Vec<T> {
    // Drops the vector
    fn drop(&mut self) {
        if (self.capacity != 0) {
            self.clear();
            free(self.data);

            self.size = 0;
            self.capacity = 0;
            self.data = nullptr;
        }
    }
}

impl<T: Clone> Clone for Vec<T> {
    fn clone(&self): Self {
        let vec: Vec<T> = [Vec<T>].from_size(self.capacity);

        for (let i = 0; i < self.size; i += 1) {
            let element: &T = self.get(i);
            vec.push([T as Clone].clone(element));
        }

        vec
    }
}

impl<T> Vec<T> {
    // Constructs a new vector. This function does not reserve any memory for the vector.
    public fn new(): Self {
        Self {
            size: 0,
            capacity: 0,
            element_size: sizeof T,
            data: nullptr
        }
    }

    // Constructs a new vector with space for `n` elements.
    public fn from_size(n: int): Self {
        Self {
            size: n,
            capacity: n,
            element_size: sizeof T,
            data: if n == 0 { nullptr } else { calloc(n, sizeof T) }
        }
    }

    // Adjusts the capacity of the vector. 
    // * Returns `true` if successful, `false` otherwise.
    // * This function returns false if `new_capacity` is less than or equal to the current capacity.
    public fn reserve(&mut self, new_capacity: int): bool {
        if (new_capacity <= self.capacity) return false;

        let bytes = self.element_size * new_capacity;
        let new_data = realloc(self.data, bytes);
        if (new_data == nullptr) return false;

        self.data = new_data;
        self.capacity = new_capacity;

        true
    }

    // Pushes an element to the end of a vector.
    public fn push(&mut self, element: &T) {
        if (self.size + 1 > self.capacity) {
            self.reserve(if self.capacity == 0 { 1 } else { self.capacity * 2 });
        }

        let dst = self.data + self.capacity * self.element_size;
        memcpy(dst, element, self.element_size);
        self.size += 1;
    }

    // Replaces the element at index `idx` with `element`.
    // * Returns true if successful, false otherwise.
    // * This function returns false if `idx` is out of the bounds of the allocated vector.
    // * The replaced element is dropped.
    public fn replace(&self, idx: int, element: &T): bool {
        if (idx < 0 || idx + 1 > self.size) {
            return false;
        }

        let dst = self.data + idx * self.element_size;
        [T as Drop].drop(dst as &mut T);
        memcpy(dst, element, self.element_size);

        true
    }

    // Gets the element at index `idx`.
    // * Panics if `idx` is out of bounds.
    public fn get(&self, idx: int): &T {
        if (idx < 0 || idx + 1 > self.size) {
            eprint("oob access in vector\n");
            exit(1);
        }

        (self.data + idx * self.element_size) as &T;
    }

    // Removes the element at index `idx`.
    // * Returns true if successful, false otherwise.
    // * This function returns false if `idx` is out of the bounds of the allocated vector.
    // * The replaced element is dropped.
    public fn remove(&mut self, idx: int): bool {
        if (idx < 0 || idx + 1 > self.size) {
            return false;
        }

        let dst = self.data + idx * self.element_size;
        [T as Drop].drop(dst as &mut T);
        let src = self.data + idx * (self.element_size + 1);
        let size = self.element_size * (self.size - idx - 1);

        memmove(dst, src, size);
        self.size -= 1;

        true
    }

    // Clears the vector.
    // * All elements in the vector are dropped.
    public fn clear(&mut self) {
        while (self.size > 0) {
            self.remove(0);
        }
    }
}