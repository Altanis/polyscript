import { calloc, realloc, memcpy, memmove, free, decref, print_char, eprint, print_int, endproc, endproc, drop, strlen, strget, ref, deref } from "@intrinsics";

// Constant pointing to 0x0 for NULL.
const nullptr: int = 0x0;

// A struct representing a vector, a contiguous, resizable array that holds elements of the same type.
struct Vec<T> {
    // The current size of the vector.
    private size: int;
    // How many elements the vector has reserved for storage.
    private capacity: int;
    // The size of 1 element.
    private element_size: int;
    // A pointer to the actual data in the vector.
    private data: int;
}

impl<T> Vec<T> {
    // Constructs a new vector. This function does not reserve any memory for the vector.
    public fn new(): Self {
        Self {
            size: 0,
            capacity: 0,
            element_size: sizeof T,
            data: nullptr
        }
    }

    // Constructs a new vector with space for `n` elements.
    public fn from_capacity(n: int): Self {
        Self {
            size: 0,
            capacity: n,
            element_size: sizeof T,
            data: if (n == 0) { nullptr } else { calloc(n, sizeof T) }
        }
    }

    // Adjusts the capacity of the vector. 
    // * Returns `true` if successful, `false` otherwise.
    // * This function returns false if `new_capacity` is less than or equal to the current capacity.
    public fn reserve(self, new_capacity: int): bool {
        if (new_capacity <= self.capacity) { return false; };

        let bytes = self.element_size * new_capacity;
        let new_data = realloc(self.data, bytes);
        if (new_data == nullptr) { return false; };

        self.data = new_data;
        self.capacity = new_capacity;

        true
    }

    // Pushes an element to the end of a vector.
    public fn push(self, element: T) {
        if (self.size + 1 > self.capacity && !self.reserve(if (self.capacity == 0) { 1 } else { self.capacity * 2 })) {
            eprint("oom: couldn't reserve memory for vector\n");
            endproc(1);
        };

        let dst = self.data + self.size * self.element_size;
        memcpy(dst, ref(element), self.element_size);
        self.size += 1;
    }

    // Replaces the element at index `idx` with `element`.
    // * Returns true if successful, false otherwise.
    // * This function returns false if `idx` is out of the bounds of the allocated vector.
    // * The replaced element is dropped.
    public fn replace(self, idx: int, element: T): bool {
        if (idx < 0 || idx >= self.size) {
            return false;
        };

        let dst = self.data + idx * self.element_size;

        if #IS_REFCOUNTED#{T} {
            decref(dst);
        } else {
            drop(deref(dst as T));
        };

        memcpy(dst, ref(element), self.element_size);
        true
    }

    // Inserts an element at index `idx`.
    // * Returns true if successful, false otherwise.
    // * This function returns false if `idx` is out of the bounds of the allocated vector.
    public fn insert(self, idx: int, element: T): bool {
        if (idx < 0 || idx > self.size) {
            return false;
        };

        if (self.size + 1 > self.capacity && !self.reserve(if (self.capacity == 0) { 1 } else { self.capacity * 2 })) {
            eprint("oom: couldn't reserve memory for vector\n");
            endproc(1);
        };

        let dst = self.data + idx * self.element_size;
        let src = self.data + idx * self.element_size;
        let size = self.element_size * (self.size - idx);

        if (size > 0) { memmove(dst + self.element_size, src, size); };
        memcpy(dst, ref(element), self.element_size);

        self.size += 1;
        true
    }

    // Gets the element at index `idx`.
    // * Panics if `idx` is out of bounds.
    public fn get(self, idx: int): T {
        if (idx < 0 || idx >= self.size) {
            eprint("oob access in vector\n");
            endproc(1);
        };

        deref((self.data + idx * self.element_size) as T)
    }

    // Removes the element at index `idx`.
    // * Returns true if successful, false otherwise.
    // * This function returns false if `idx` is out of the bounds of the allocated vector.
    // * The removed element is dropped.
    public fn remove(self, idx: int): bool {
        if (idx < 0 || idx >= self.size) {
            return false;
        };

        let dst = self.data + idx * self.element_size;

        if #IS_REFCOUNTED#{T} {
            decref(dst);
        } else {
            drop(deref(dst as T));
        };

        let src = self.data + (idx + 1) * self.element_size;
        let size = self.element_size * (self.size - idx - 1);

        if (size > 0) { memmove(dst, src, size); };
        self.size -= 1;

        true
    }

    // Clears the vector.
    // * All elements in the vector are dropped.
    public fn clear(self) {
        while (self.size > 0) {
            let last = self.size - 1;
            let dst = self.data + last * self.element_size;

            if #IS_REFCOUNTED#{T} {
                decref(dst);
            } else {
                drop(deref(dst as T));
            };

            self.size = last;
        }
    }

    // Gets the length of the vector.
    public fn length(self): int {
        self.size
    }
}

impl<T> Drop for Vec<T> {
    fn drop(self) {
        if (self.capacity != 0) {
            self.clear();
            free(self.data);

            self.size = 0;
            self.capacity = 0;
            self.data = nullptr;
        }
    }
}

export { Vec };