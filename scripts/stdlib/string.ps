import { strlen, strget } from "@intrinsics";
import { Vec } from "stdlib/vec.ps";

// A structure representing a mutable, extensible String.
struct String {
    // The internal representation of the string, in characters.
    private chars: Vec<char>;
}

impl String {
    // Constructs a new string. This function does not reserve any memory for the string.
    public fn new(): Self {
        Self { chars: [Vec<char>].new() }
    }

    // Constructs a new string with space for `n` elements.
    public fn from_capacity(n: int): Self {
        Self { chars: [Vec<char>].from_capacity(n) }
    }
    
    // Constructs a new string from a constant str `s`.
    public fn from_str(s: str): Self {
        let len = strlen(s);
        let chars = [Vec<char>].from_capacity(len);

        for (let i = 0; i < len; i += 1) {
            chars.push(strget(s, i));
        }

        Self { chars }
    }

    // Constructs a new string from a character `c`.
    public fn from_char(c: char): Self {
        let chars = [Vec<char>].from_capacity(1);
        chars.push(c);

        Self { chars }
    }

    // Gets the length of the string.
    public fn length(self): int {
        self.chars.length()
    }

    // Gets the `i`-th character in the string.
    public fn get(self, i: int): char {
        self.chars.get(i)
    }

    // Pushes a character `c` to the end of the string.
    public fn push(self, c: char) {
        self.chars.push(c);
    }

    // Pushes a string `s` to the end of the string.
    public fn push_string(self, s: String) {
        for (let i = 0; i < s.length(); i += 1) {
            self.chars.push(s.get(i));
        }
    }

    // Inserts a character `c` at position `idx`.
    public fn insert(self, idx: int, c: char) {
        self.chars.insert(idx, c);
    }

    // Removes a character from a position `idx`.
    public fn remove(self, idx: int) {
        self.chars.remove(idx);
    }

    // Clears the string.
    public fn clear(self) {
        self.chars.clear();
    }

    // Checks if the string is empty.
    public fn is_empty(self): bool {
        self.length() == 0
    }

    // Checks if the string contains the given substring.
    public fn contains(self, substring: String): bool {
        if (substring.length() == 0) {
            return true;
        };

        if (substring.length() > self.length()) {
            return false;
        };

        for (let i = 0; i <= self.length() - substring.length(); i += 1) {
            let matched = true;
            for (let j = 0; j < substring.length(); j += 1) {
                if (self.get(i + j) != substring.get(j)) {
                    matched = false;
                    break;
                };
            }

            if (matched) {
                return true;
            };
        }

        return false;
    }

    // Checks if the string starts with the given prefix.
    public fn starts_with(self, prefix: String): bool {
        if (prefix.length() > self.length()) {
            return false;
        };

        for (let i = 0; i < prefix.length(); i += 1) {
            if (self.get(i) != prefix.get(i)) {
                return false;
            };
        }

        return true;
    }

    // Checks if the string ends with the given suffix.
    public fn ends_with(self, suffix: String): bool {
        if (suffix.length() > self.length()) {
            return false;
        };

        let offset = self.length() - suffix.length();
        for (let i = 0; i < suffix.length(); i += 1) {
            if (self.get(offset + i) != suffix.get(i)) {
                return false;
            };
        }

        return true;
    }

    // Finds the index of the given character, or -1 if not found.
    public fn index_of(self, c: char): int {
        for (let i = 0; i < self.length(); i += 1) {
            if (self.get(i) == c) {
                return i;
            };
        }

        return 0 - 1;
    }

    // Returns a slice of the string from start to end (exclusive).
    public fn slice(self, start: int, end: int): String {
        let result = String.new();
        for (let i = start; i < end && i < self.length(); i += 1) {
            result.push(self.get(i));
        }

        return result;
    }

    // Splits the string by the given delimiter character.
    public fn split(self, delimiter: char): Vec<String> {
        let parts = [Vec<String>].new();
        let current = String.new();

        for (let i = 0; i < self.length(); i += 1) {
            let ch = self.get(i);
            if (ch == delimiter) {
                parts.push(current);
                current = String.new();
            } else {
                current.push(ch);
            };
        }

        parts.push(current);
        return parts;
    }

    // Returns a new string with all characters converted to uppercase.
    public fn to_uppercase(self): String {
        let result = String.new();

        for (let i = 0; i < self.length(); i += 1) {
            let ch = self.get(i);
            if (ch >= 'a' && ch <= 'z') {
                result.push((ch as int - ('a' as int) + ('A' as int)) as char);
            } else {
                result.push(ch);
            };
        }

        return result;
    }

    // Returns a new string with all characters converted to lowercase.
    public fn to_lowercase(self): String {
        let result = String.new();

        for (let i = 0; i < self.length(); i += 1) {
            let ch = self.get(i);
            if (ch >= 'A' && ch <= 'Z') {
                result.push((ch as int - ('A' as int) + ('a' as int)) as char);
            } else {
                result.push(ch);
            };
        }

        return result;
    }

    // Trims leading and trailing whitespace.
    public fn trim(self): String {
        let start = 0;
        let end = self.length();

        while (start < end && self.get(start) <= ' ') {
            start += 1;
        }

        while (end > start && self.get(end - 1) <= ' ') {
            end -= 1;
        }

        return self.slice(start, end);
    }

    // Joins a vector of strings with a separator.
    public fn join(strings: Vec<String>, separator: String): String {
        let result = String.new();

        for (let i = 0; i < strings.length(); i += 1) {
            result.push_string(strings.get(i));
            if (i < strings.length() - 1) {
                result.push_string(separator);
            };
        }

        return result;
    }

    // Repeats the string n times.
    public fn repeat(self, n: int): String {
        let result = String.new();

        for (let i = 0; i < n; i += 1) {
            result.push_string(self);
        }

        return result;
    }
}

impl Add<char> for String {
    type Output = String;
    fn add(self, other: char): String {
        self.push(other);
        self
    }
}

impl Add<String> for String {
    type Output = String;
    fn add(self, other: String): String {
        self.push_string(other);
        self
    }
}

impl AddAssign<char> for String {
    fn add_assign(self, other: char) {
        self.push(other);
    }
}

impl AddAssign<String> for String {
    fn add_assign(self, other: String) {
        self.push_string(other);
    }
}

impl Equivalence<String> for String {
    type Output = bool;
    fn equivalence(self, other: String): bool {
        if (self.length() != other.length()) {
            return false;
        };

        for (let i = 0; i < self.length(); i += 1) {
            if (self.get(i) != other.get(i)) {
                return false;
            };
        }

        return true;
    }
}

impl Equivalence<str> for String {
    type Output = bool;
    fn equivalence(self, other: str): bool {
        let s = String.from_str(other);
        [String as Equivalence<String>].equivalence(self, s)
    }
}

impl NotEqual<String> for String {
    type Output = bool;
    fn not_equal(self, other: String): bool {
        !(self == other)
    }
}

impl GreaterThan<String> for String {
    type Output = bool;
    fn greater_than(self, other: String): bool {
        let min_len = if (self.length() < other.length()) { self.length() } else { other.length() };

        for (let i = 0; i < min_len; i += 1) {
            if (self.get(i) > other.get(i)) {
                return true;
            } else if (self.get(i) < other.get(i)) {
                return false;
            };
        }

        return self.length() > other.length();
    }
}

impl GreaterThanOrEqual<String> for String {
    type Output = bool;
    fn greater_than_or_equal(self, other: String): bool {
        self > other || self == other
    }
}

impl LessThan<String> for String {
    type Output = bool;
    fn less_than(self, other: String): bool {
        let min_len = if (self.length() < other.length()) { self.length() } else { other.length() };

        for (let i = 0; i < min_len; i += 1) {
            if (self.get(i) < other.get(i)) {
                return true;
            } else if (self.get(i) > other.get(i)) {
                return false;
            };
        }

        return self.length() < other.length();
    }
}

impl LessThanOrEqual<String> for String {
    type Output = bool;
    fn less_than_or_equal(self, other: String): bool {
        self < other || self == other
    }
}

impl Subtract<String> for String {
    type Output = String;

    fn subtract(self, other: String): String {
        if (other.length() == 0) {
            return self;
        };

        let i = 0;
        while (i <= self.length() - other.length()) {
            let matched = true;

            for (let j = 0; j < other.length(); j += 1) {
                if (self.get(i + j) != other.get(j)) {
                    matched = false;
                    break;
                };
            }

            if (matched) {
                let before = self.slice(0, i);
                let after = self.slice(i + other.length(), self.length());
                return before + after;
            };

            i += 1;
        }

        self
    }
}

trait ToString {
    fn to_string(self): String;
}

impl ToString for int {
    fn to_string(self): String {
        if (self == 0) { return String.from_str("0"); };

        let n = self;
        let negative = false;
        if (n < 0) {
            negative = true;
            n = 0 - n;
        };

        let digits = [Vec<char>].new();

        while (n > 0) {
            let d = (n % 10) as char;
            digits.push(('0' as int + d as int) as char);
            n /= 10;
        }

        if (negative) {
            digits.push('-');
        };

        let chars = [Vec<char>].from_capacity(digits.length());
        for (let i = digits.length() - 1; i >= 0; i -= 1) {
            chars.push(digits.get(i));
        }

        String { chars }
    }
}

impl ToString for float {
    fn to_string(self): String {
        let n = self;

        // TODO: nan, inf, -inf

        let negative = n < 0.0;
        if (negative) {
            n = 0.0 - n;
        };

        let int_part = n as int;
        let s = [int as ToString].to_string(int_part);

        let frac = n - int_part as float;
        if (frac > 0.0) {
            s.push('.');
            for (let i = 0; i < 17; i += 1) {
                frac *= 10.0;
                let digit = frac as int;
                s.push(('0' as int + digit) as char);
                frac -= digit as float;
            }
        } else {
            s.push('.');
            s.push('0');
        };

        if (negative) {
            let with_sign = String.from_str("-");
            with_sign.push_string(s);
            return with_sign;
        };

        s
    }
}

impl ToString for str {
    fn to_string(self): String {
        String.from_str(self)
    }
}

impl ToString for char {
    fn to_string(self): String {
        String.from_char(self)
    }
}

impl ToString for bool {
    fn to_string(self): String {
        if (self) {
            String.from_str("true")
        } else {
            String.from_str("false")
        }
    }
}

impl ToString for String {
    fn to_string(self): String {
        self
    }
}

export { String, ToString };