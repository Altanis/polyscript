import { strlen, strget } from "@intrinsics";
import { Vec } from "stdlib/vec.ps";

// A structure representing a mutable, extensible String.
struct String {
    // The internal representation of the string, in characters.
    private chars: Vec<char>;
}

impl String {
    // Constructs a new string. This function does not reserve any memory for the string.
    public fn new(): Self {
        Self { chars: [Vec<char>].new() }
    }

    // Constructs a new string with space for `n` elements.
    public fn from_capacity(n: int): Self {
        Self { chars: [Vec<char>].from_capacity(n) }
    }
    
    // Constructs a new string from a constant str `s`.
    public fn from_str(s: str): Self {
        let len = strlen(s);
        let chars = [Vec<char>].from_capacity(len);

        for (let i = 0; i < len; i += 1) {
            chars.push(strget(s, i));
        }

        Self { chars }
    }

    // Constructs a new string from a character `c`.
    public fn from_char(c: char): Self {
        let chars = [Vec<char>].from_capacity(1);
        chars.push(c);

        Self { chars }
    }

    // Gets the length of the string.
    public fn length(&self): int {
        self.chars.length()
    }

    // Gets the `i`-th character in the string.
    public fn get(&self, i: int): char {
        *self.chars.get(i)
    }

    // Pushes a character `c` to the end of the string.
    public fn push(&mut self, c: char) {
        self.chars.push(c);
    }

    // Pushes a string `s` to the end of the string.
    public fn push_string(&mut self, s: &String) {
        for (let i = 0; i < s.length(); i += 1) {
            self.chars.push(s.get(i));
        }
    }
}

impl Clone for String {
    fn clone(&self): Self {
        String { chars: [Vec<char> as Clone].clone(&self.chars) }
    }
}

impl Add<char> for String {
    type Output = String;
    fn add(self, other: char): String {
        let string = [String as Clone].clone(&self);
        string.push(other);
        string
    }
}

impl AddAssign<char> for String {
    fn add_assign(&mut self, other: char) {
        self.push(other);
    }
}

impl Add<String> for String {
    type Output = String;
    fn add(self, other: String): String {
        let string = [String as Clone].clone(&self);
        string.push_string(&other);
        string
    }
}

impl AddAssign<String> for String {
    fn add_assign(&mut self, other: String) {
        self.push_string(&other);
    }
}

trait ToString {
    fn to_string(&self): String;
}

impl ToString for int {
    fn to_string(&self): String {
        if (*self == 0) { return String.from_str("0"); };

        let n = *self;
        let negative = false;
        if (n < 0) {
            negative = true;
            n = -n;
        };

        let digits = [Vec<char>].new();

        while (n > 0) {
            let d = (n % 10) as char;
            digits.push(('0' as int + d as int) as char);
            n /= 10;
        }

        if (negative) {
            digits.push('-');
        };

        let chars = [Vec<char>].from_capacity(digits.length());
        for (let i = digits.length() - 1; i >= 0; i -= 1) {
            chars.push(*digits.get(i));
        }

        String { chars }
    }
}

/*impl ToString for float {
    fn to_string(&self): String {
        let mut n = *self;

        // TODO: nan, inf, -inf

        let negative = n < 0.0;
        if negative {
            n = -n;
        }

        let int_part = n as int;
        let s = [int as ToString].to_string(&int);

        let mut frac = n - int_part as float;
        if (frac > 0.0) {
            s.push('.');
            for (let i = 0; i < 6; i += 1) {
                frac *= 10.0;
                let digit = frac as int;
                s.push(('0' as int + digit) as char);
                frac -= digit as float;
            }
        }

        if negative {
            let with_sign = String::from_str("-");
            with_sign.push_str(&s);
            return with_sign;
        }

        s
    }
}*/

impl ToString for str {
    fn to_string(&self): String {
        String.from_str(*self)
    }
}

impl ToString for char {
    fn to_string(&self): String {
        String.from_char(*self)
    }
}

impl ToString for bool {
    fn to_string(&self): String {
        if (*self) {
            String.from_str("true")
        } else {
            String.from_str("false")
        }
    }
}

impl ToString for String {
    fn to_string(&self): String {
        *self
    }
}

export { String, ToString };