trait TAddable {
    fn add(self, other: Self): Self;
}

trait TSubbable {
    fn sub(self, other: Self): Self;
}

impl TAddable for int {
    fn add(self, other: Self): Self {
        return self + other;
    }
}

impl TSubbable for int {
    fn sub(self, other: Self): Self {
        return self - other;
    }
}

impl TAddable for float {
    fn add(self, other: Self): Self {
        return self + other;
    }
}

impl TSubbable for float {
    fn sub(self, other: Self): Self {
        return self - other;
    }
}

fn identity<T>(x: T): T {
    return x;
}

fn generic_pair<A: TAddable + TSubbable, B: TAddable + TSubbable>(a: A, b: B) {}

let identity_value = identity(5);
generic_pair(5, "3");

struct Vector2D<T: TAddable> {
    public x: T;
    public y: T;
}

let vector: Vector2D<int> = Vector2D { x: 3, y: 4 };

impl<T: TAddable> Vector2D<T> {
    public fn add(self, vector: Vector2D<T>): Vector2D<T> {
        return Vector2D {
            x: self.x.add(vector.x),
            y: self.y.add(vector.y)
        };
    }

    public fn random_method<V>(&self, x: V) {}
}

impl Vector2D<int> {
    public fn merge(self): int {
        return self.x + self.y;
    }
}

impl Vector2D<float> {
    public fn merge(self): float {
        return self.x + self.y;
    }
}

let vector1: Vector2D<float> = Vector2D { x: 3.0, y: 3.0 };
let resultant = vector1.add(Vector2D { x: 4.0, y: 4.0 });
vector1.random_method("hi");
let merged = vector1.merge();

// let vector3 = Vector2D { x: 1, y: "3" } <-- compile error






/*fn identity<T>(x: T): T {
    return x;
}

let y = identity(3);*/

// bug: ptr is passed to identity instead of actual int

/*trait Entity {
    type TickOutput;
    fn tick(&mut self): Self.TickOutput;
}

struct Tank {}
struct Square {}

impl Entity for Tank {
    type TickOutput = int;
    fn tick(&mut self): int { 4 }
}

impl Entity for Square {
    type TickOutput = char;
    fn tick(&mut self): char { '4' }
}

fn tick<T: Entity>(x: T): [T as Entity].TickOutput {
    x.tick()
}

let tank = Tank {};
let square = Square {};

let fruit1: int = tick(tank);
let fruit2: char = tick(square);*/




let a = 1;
let b = 1.0;
let c = true;
let d = 'a';
let e = "f";
let f = e;
let g = heap e;
let h = 2 + 3;
let i = -2;
let j = true || false;
let k = {
    let y = 4;
    y
};

let l = if (true) {
    4
} else {
    3
};

let m = 0;
for (let i = 0; i < 5; i += 1) {
    m += 1;
}

while (m < 0) {
    m -= 1;
}

let x: float = 5 as float;

struct Vector2D {
    x: int;
    y: int;
}

enum Difficulty {
    Easy,
    Medium = 3,
    Hard
}

impl Vector2D {
    const DIMENSIONS: int = 2;
    const DIFFICULTY: Difficulty = Difficulty.Medium;

    fn new(x: int, y: int): Self {
        Vector2D {
            x,
            y
        }
    }

    fn add(&self, other: &Self): Self {
        Vector2D.new(this.x + other.x, this.y + other.y)
    }
}

let p1 = Vector2D.new(0, 0);
let p2 = Vector2D { x: 4, y: 4 };
let p3 = Vector2D.new(p1.x + p2.x, p1.y + p2.y);
let difficulty = Difficulty.Hard as int;